desc: SBP Surround Scope 5.1
// @version 2.1.1
// @author SBP & AI
// @about 5.1 Surround Sound Field Analyzer with heat map, phase correlation, and level meters.
//   Monitoring-only: audio passes through unmodified.
//   Visualises energy distribution in a cinema-like top-down view with temporal decay.
//   Displays phase coherence between all speaker pairs.
//   Reference UI style: floop-master-control (dark charcoal + green accents).
// @changelog v2.1.1 - Fix: Compact UI mode now preserves slider visibility state after transport stop. Previously, @init section always showed all sliders regardless of UI Mode setting, now it checks slider6 state to maintain compact/full view consistency.
// @changelog v2.1.0 - Added per-channel Mute (click channel labels in meter panel to toggle L/R/C/LFE/Ls/Rs) and Divergence (drag cyan bars below meters to spread signal to adjacent ITU-R speakers). Mute applies post-metering so meters still show activity. Divergence uses ITU-R BS.775 adjacency (L↔C, L↔Ls, R↔C, R↔Rs, Ls↔Rs). All parameters stored in hidden sliders (21-23, 26-28) for automation. Right-click divergence to reset.
// @changelog v2.0.2 - Fix: Outside mask now fully covers all heat map square corners. Extended mask radius from 0.5 to 0.75 (beyond diagonal 0.707) to ensure complete coverage of square boundaries while remaining clamped to heat map area.
// @changelog v2.0.1 - Fix: Outside mask (circle darkening) now properly constrained to heat map area boundaries, preventing overlap with UI elements. Increased triangulation steps from 64 to 128 for smoother circular coverage.
// @changelog v2.0 - BREAKING: Migrated from cinema trapezoid to ITU-R BS.775 standard geometry. All speakers now positioned at proper ITU angles (L=-30°, R=+30°, C=0°, Ls=-110°, Rs=+110°) at equal radius 0.35 from listener. Visualization changed from trapezoid to circle. This fixes spatial analysis accuracy and ensures compatibility with industry-standard 5.1 monitoring setups. Heat map, phantom center calculation, and all analysis now use correct ITU-R BS.775 speaker positions.
// @changelog v1.45 - Fix: Phantom Center slider output (slider24/25) now computed in @block instead of @gfx, so it updates continuously even when UI window is closed. Fixes broken link with SBP Phantom Follower via ReaMidiController when Surround Scope window is hidden.
// @changelog v1.44 - Added Rotation Multiplier (slider20, x1-x10) to extend listener rotation range up to +/-1800 degrees (10 full turns) for unrestricted automation. Updated mouse drag interaction to maintain visual 1:1 rotation mapping while respecting the multiplier scale.
// @changelog v1.43 - Fixed rear wall panning Ls→Rs: corrected angle range detection so rear arc (±180° region) properly maps to Rs→Ls pair instead of incorrectly jumping to Ls→L. Added explicit range checks (>=) for all 5 pairs. Eliminates click when panning across rear wall between surround speakers.
// @changelog v1.42 - Proper VBAP pair selection: now uses ADJACENT speaker pairs only (Ls-L, L-C, C-R, R-Rs, Rs-Ls). Eliminates clicks when panning R→C→L by ensuring source always distributed to correct neighboring speakers based on angle, not arbitrary "2 nearest" selection. Fixes non-smooth transitions in frontal arc.
// @changelog v1.36 - Consolidated Phantom Center outputs: removed hidden slider18/19, now using visible sliders 24/25 (Phantom Center X/Y) for external scripting and automation linking. Fixed Compact UI mode to properly hide all toggleable sliders including Goniometer Pair. Improved slider_show() implementation for reliable UI mode switching.
// @changelog v1.35 - Panorama Mix parameter added (slider2): 0=Pure Analyzer (original audio analyzed), 1=Full Panorama (rotated audio analyzed). Fixes "signal bleeding between channels" issue when using with other effects. All analyzers (energy, peak, RMS, LUFS, phase correlation, goniometer, heat map) now work on the analyzed mix. Audio output remains unchanged (pass-through monitoring). Supports blend between pure analysis and panoramic analysis.
// @changelog v1.0 - Initial release: Professional 5.1 surround analyzer with real-time heat map visualization, 10-pair goniometer with phase correlation, ITU-R BS.1770-4 calibrated LUFS metering, rotatable listener panorama (-180° to +180°), phantom center tracking, perceptual colormaps (Viridis/Inferno/Plasma/Magma), COMPACT/FULL UI modes, and interactive draggable controls.

// ======================================================================
// SLIDERS - LOGICAL ORDER BY UI LAYOUT
// ======================================================================
// === PANORAMA CONTROLS ===
slider1:0<-180,180,1>Listener Rotation (deg)
slider2:1<0,1,1{Pure Analyzer (No Pan),Panorama Active}>Panorama Enable
slider3:0<0,1,1{VBAP Clean,Amplitude Bleed}>Panorama Mode
slider20:1<1,10,1>Rotation Multiplier
// === DISPLAY MODES ===
slider4:0<0,1,1{Heat Map,Stereo Goniometer}>Display Mode
slider5:0<0,1,1{Peak,RMS}>Meter Mode
slider6:0<0,1,1{Show All,Compact View}>-UI Mode
// === GONIOMETER CONTROLS ===
slider7:10.0<0.1,15.0,0.1>Goniometer Sensitivity
slider8:0<0,9,1{L-R,L-C,L-Ls,L-Rs,R-C,R-Ls,R-Rs,C-Ls,C-Rs,Ls-Rs}>Goniometer Pair
// === HEAT MAP & VISUALIZATION ===
slider9:1.0<0.1,4.0,0.1>Sensitivity (Heat Map)
slider10:0.96<0.90,0.995,0.001>Decay Speed
slider11:0.15<0.0,1.0,0.01>Brightness
slider12:0<0,9,1{Teal-Green,Rainbow,Cyan-Magenta,Fire,Mono Green,Blue Fire,Viridis,Inferno,Plasma,Magma}>Color Scheme
slider13:0.85<0.0,0.99,0.01>Heatmap Smoothing
slider14:0<0,1,1{Auto Scale,Lock -60dB Floor}>Heatmap Scale
slider15:-23<-60,0,1>Target Level (dB)
// === DRAWING OPTIONS ===
slider16:0<0,1,1{OFF,ON}>Show Grid
slider17:1.0<0.0,2.0,0.01>Wave Rings Visibility
slider18:1<0,1,1{OFF,ON}>Outside Mask
// === PHANTOM CENTER ANALYSIS ===
slider19:0.85<0.0,0.99,0.01>Phantom Center Smoothing
slider24:0.5<0,1,0.001>Phantom Center X
slider25:0.5<0,1,0.001>Phantom Center Y
// === CHANNEL MUTE & DIVERGENCE (hidden) ===
slider21:0<0,63,1>-Channel Mute Mask
slider22:0<0,1,0.01>-L Divergence
slider23:0<0,1,0.01>-R Divergence
slider26:0<0,1,0.01>-C Divergence
slider27:0<0,1,0.01>-Ls Divergence
slider28:0<0,1,0.01>-Rs Divergence
// ======================================================================
// PIN DEFINITIONS (6-channel 5.1 pass-through)
// ======================================================================

in_pin:Front L
in_pin:Front R
in_pin:Center
in_pin:LFE
in_pin:Rear L
in_pin:Rear R

out_pin:Front L
out_pin:Front R
out_pin:Center
out_pin:LFE
out_pin:Rear L
out_pin:Rear R

// ======================================================================
// @init
// ======================================================================
@init

  // --- CONSTANTS ---
  PI = 3.14159265359;
  TWO_PI = 2.0 * PI;
  DEG2RAD = PI / 180.0;

  GRID_W = 64;
  GRID_H = 64;
  GRID_TOTAL = GRID_W * GRID_H;

  NUM_SPEAKERS = 5;       // L, R, C, Ls, Rs (LFE excluded from spatial field)
  NUM_PHASE_PAIRS = 10;   // All possible combinations: L-R, L-C, L-Ls, L-Rs, R-C, R-Ls, R-Rs, C-Ls, C-Rs, Ls-Rs

  // UI constants for slider visibility control
  // Sliders to toggle in compact mode: 1-5, 7-19, 20, 24-25 (bits 0-4, 6-19, 23-24)
  // Exclude slider 6 (bit 5 = UI Mode output)
  UI_SLIDERS_MASK = ((1 << 5) - 1) | (((1 << 14) - 1) << 6) | (3 << 23);
  sliders_showing = 0;              // Track slider visibility state
  
  // Initialize: show/hide sliders based on current UI Mode
  slider_show(UI_SLIDERS_MASK, slider6 ? 0 : 1);

  PEAK_HOLD_FRAMES = 45;  // ~1.5s at 30fps
  PEAK_DECAY = 0.97;
  RMS_WINDOW = 1024;

  // --- OFFSCREEN BUFFER INDICES ---
  HEAT_BUFFER = 127;
  GONIO_BUFFER = 126;
  SURR_BUFFER = 125;  // 5.1 Surround goniometer buffer

  // --- SPEAKER POSITIONS (normalized 0..1) ---
  // ITU-R BS.775 standard 5.1 layout (all speakers equidistant from listener):
  //   L  (Front Left):    -30° at radius 0.35
  //   R  (Front Right):   +30° at radius 0.35
  //   C  (Center):          0° at radius 0.35
  //   Ls (Left Surround): -110° at radius 0.35
  //   Rs (Right Surround): +110° at radius 0.35
  //   Listener at (0.5, 0.5)
  spk_x = 180;   // [180..184] - SAFE MEMORY AREA
  spk_y = 185;   // [185..189] - SAFE MEMORY AREA

  listen_x = 0.5;
  listen_y = 0.50;

  // C = Center (0°, straight ahead)
  spk_x[2] = 0.500;
  spk_y[2] = 0.150;

  // L = Front Left (-30°)
  spk_x[0] = 0.325;
  spk_y[0] = 0.197;

  // R = Front Right (+30°)
  spk_x[1] = 0.675;
  spk_y[1] = 0.197;

  // Ls = Left Surround (-110°, rear left)
  spk_x[3] = 0.171;
  spk_y[3] = 0.620;

  // Rs = Right Surround (+110°, rear right)
  spk_x[4] = 0.829;
  spk_y[4] = 0.620;

  // --- MEMORY LAYOUT ---
  energy       = 100;  // [100..104] smoothed energy per speaker
  peak_level   = 110;  // [110..114]
  rms_acc      = 120;  // [120..124]
  rms_level    = 130;  // [130..134]
  rms_disp     = 170;  // [170..174]
  peak_hold    = 140;  // [140..144]
  peak_hold_tm = 150;  // [150..154]

  lfe_energy   = 160;  // [160]
  lfe_peak     = 161;  // [161]
  lfe_rms_acc  = 162;  // [162]
  lfe_rms      = 163;  // [163]
  lfe_hold     = 164;  // [164]
  lfe_hold_tm  = 165;  // [165]
  
  // Speaker positions - moved to safe area to prevent memory conflicts
  // spk_x = 180; spk_y = 185 (defined above)

  phase_sum_ab = 200;  // [200..209] - 10 pairs
  phase_sum_a2 = 210;  // [210..219] - 10 pairs
  phase_sum_b2 = 220;  // [220..229] - 10 pairs
  phase_corr   = 240;  // [240..249] - 10 pairs
  phase_smooth = 250;  // [250..259] - 10 pairs (smoothed correlation)

  heatmap      = 300;   // [300..4395]   64*64 = 4096
  weight_table = 5000;  // [5000..25479] 4096*5 = 20480
  
  energy_history = 30000;  // [30000..30049] History buffer: 5 speakers * 10 frames each

  rms_counter  = 26000;

  // Goniometer ring buffer for per-sample scatter
  gonio_write  = 26010;
  GONIO_BUF    = 27000; // [27000..27000+GONIO_SIZE*2-1]
  GONIO_SIZE   = 4096;
  
  // 5.1 Surround goniometer: store 5 channels per sample
  surr_write   = 26011;
  SURR_BUF     = 28000; // [28000..28000+GONIO_SIZE*5-1]
  SURR_SIZE    = 4096;

  // Heat map peak tracking
  heatmap_peak = 26012;  // Current peak value
  heatmap_peak_hold = 26013;  // Hold peak value
  heatmap_min = 26014;  // Minimum value for LRA range
  heatmap_min_hold = 26015;  // Hold minimum value
  
  // Phantom center smoothed position
  phantom_center_x = 26016;
  phantom_center_y = 26017;
  
  // Heat map smoothing (separate from energy meters)
  heatmap_energy = 26060;  // [26060..26064]
  
  // K-weighting filter state (ITU-R BS.1770-4) - 5 channels, 2 stages, 2 states each
  kw_z1 = 26020;  // [26020..26039] Stage 1 & 2 z1 for L,R,C,Ls,Rs
  kw_z2 = 26040;  // [26040..26059] Stage 1 & 2 z2 for L,R,C,Ls,Rs

  // --- COLOR SCHEME FUNCTION ---
  // Returns color (cr, cg, cb) for value v [0..1] and scheme [0..9]
  function get_color(v, scheme, cr*, cg*, cb*) (
    scheme == 0 ? (  // Teal-Green (original)
      v < 0.15 ? (
        t = v / 0.15;
        cr = 0;
        cg = t * 0.15;
        cb = t * 0.30;
      ) : v < 0.4 ? (
        t = (v - 0.15) / 0.25;
        cr = t * 0.10;
        cg = 0.15 + t * 0.55;
        cb = 0.30 + t * 0.05;
      ) : v < 0.7 ? (
        t = (v - 0.4) / 0.3;
        cr = 0.10 + t * 0.35;
        cg = 0.70 + t * 0.25;
        cb = 0.35 - t * 0.15;
      ) : (
        t = (v - 0.7) / 0.3;
        cr = 0.45 + t * 0.55;
        cg = 0.95 + t * 0.05;
        cb = 0.20 + t * 0.50;
      );
    ) : scheme == 1 ? (  // Rainbow Spectrum
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0; cg = 0; cb = 0.3 + t * 0.7;  // Dark blue -> bright blue
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0; cg = t * 0.9; cb = 1.0 - t * 0.3;  // Blue -> cyan
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = t * 1.0; cg = 0.9; cb = 0.7 - t * 0.7;  // Cyan -> yellow
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 1.0; cg = 0.9 - t * 0.5; cb = 0;  // Yellow -> orange-red
      );
    ) : scheme == 2 ? (  // Cyan-Magenta
      v < 0.5 ? (
        t = v / 0.5;
        cr = 0; cg = 0.2 + t * 0.7; cb = 0.4 + t * 0.6;  // Dark cyan -> bright cyan
      ) : (
        t = (v - 0.5) / 0.5;
        cr = t * 1.0; cg = 0.9 - t * 0.5; cb = 1.0 - t * 0.3;  // Cyan -> magenta
      );
    ) : scheme == 3 ? (  // Fire (red-orange-yellow-white)
      v < 0.3 ? (
        t = v / 0.3;
        cr = 0.2 + t * 0.6; cg = 0; cb = 0;  // Dark red -> red
      ) : v < 0.6 ? (
        t = (v - 0.3) / 0.3;
        cr = 0.8 + t * 0.2; cg = t * 0.6; cb = 0;  // Red -> orange
      ) : v < 0.85 ? (
        t = (v - 0.6) / 0.25;
        cr = 1.0; cg = 0.6 + t * 0.4; cb = t * 0.4;  // Orange -> yellow
      ) : (
        t = (v - 0.85) / 0.15;
        cr = 1.0; cg = 1.0; cb = 0.4 + t * 0.6;  // Yellow -> white
      );
    ) : scheme == 4 ? (  // Monochrome Green
      t = v;
      cr = t * 0.2; cg = 0.15 + t * 0.85; cb = t * 0.15;
    ) : scheme == 5 ? (  // Blue Fire (blue-purple-pink-white)
      v < 0.3 ? (
        t = v / 0.3;
        cr = 0; cg = 0; cb = 0.2 + t * 0.6;  // Dark blue -> blue
      ) : v < 0.6 ? (
        t = (v - 0.3) / 0.3;
        cr = t * 0.7; cg = 0; cb = 0.8 + t * 0.2;  // Blue -> purple
      ) : v < 0.85 ? (
        t = (v - 0.6) / 0.25;
        cr = 0.7 + t * 0.3; cg = t * 0.5; cb = 1.0;  // Purple -> pink
      ) : (
        t = (v - 0.85) / 0.15;
        cr = 1.0; cg = 0.5 + t * 0.5; cb = 1.0;  // Pink -> white
      );
    ) : scheme == 6 ? (  // Viridis
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.267004 + (0.282327 - 0.267004) * t;
        cg = 0.004874 + (0.140536 - 0.004874) * t;
        cb = 0.329415 + (0.457517 - 0.329415) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.282327 + (0.253935 - 0.282327) * t;
        cg = 0.140536 + (0.265254 - 0.140536) * t;
        cb = 0.457517 + (0.529983 - 0.457517) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.253935 + (0.206756 - 0.253935) * t;
        cg = 0.265254 + (0.371758 - 0.265254) * t;
        cb = 0.529983 + (0.553117 - 0.529983) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.206756 + (0.993248 - 0.206756) * t;
        cg = 0.371758 + (0.906157 - 0.371758) * t;
        cb = 0.553117 + (0.143936 - 0.553117) * t;
      );
    ) : scheme == 7 ? (  // Inferno
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.001462 + (0.221000 - 0.001462) * t;
        cg = 0.000466 + (0.047000 - 0.000466) * t;
        cb = 0.013866 + (0.327000 - 0.013866) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.221000 + (0.476000 - 0.221000) * t;
        cg = 0.047000 + (0.108000 - 0.047000) * t;
        cb = 0.327000 + (0.505000 - 0.327000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.476000 + (0.789000 - 0.476000) * t;
        cg = 0.108000 + (0.260000 - 0.108000) * t;
        cb = 0.505000 + (0.281000 - 0.505000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.789000 + (0.988000 - 0.789000) * t;
        cg = 0.260000 + (0.998000 - 0.260000) * t;
        cb = 0.281000 + (0.645000 - 0.281000) * t;
      );
    ) : scheme == 8 ? (  // Plasma
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.050383 + (0.273000 - 0.050383) * t;
        cg = 0.029803 + (0.074000 - 0.029803) * t;
        cb = 0.527975 + (0.709000 - 0.527975) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.273000 + (0.545000 - 0.273000) * t;
        cg = 0.074000 + (0.135000 - 0.074000) * t;
        cb = 0.709000 + (0.683000 - 0.709000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.545000 + (0.827000 - 0.545000) * t;
        cg = 0.135000 + (0.337000 - 0.135000) * t;
        cb = 0.683000 + (0.444000 - 0.683000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.827000 + (0.944000 - 0.827000) * t;
        cg = 0.337000 + (0.975000 - 0.337000) * t;
        cb = 0.444000 + (0.131000 - 0.444000) * t;
      );
    ) : (  // Magma
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.001462 + (0.179000 - 0.001462) * t;
        cg = 0.000466 + (0.070000 - 0.000466) * t;
        cb = 0.013866 + (0.431000 - 0.013866) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.179000 + (0.444000 - 0.179000) * t;
        cg = 0.070000 + (0.120000 - 0.070000) * t;
        cb = 0.431000 + (0.510000 - 0.431000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.444000 + (0.769000 - 0.444000) * t;
        cg = 0.120000 + (0.220000 - 0.120000) * t;
        cb = 0.510000 + (0.267000 - 0.510000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.769000 + (0.987000 - 0.769000) * t;
        cg = 0.220000 + (0.991000 - 0.220000) * t;
        cb = 0.267000 + (0.749000 - 0.267000) * t;
      );
    );
  );

  // --- CLEAR ARRAYS ---
  i = 0;
  loop(NUM_SPEAKERS,
    energy[i] = 0;
    heatmap_energy[i] = 0;
    peak_level[i] = 0;
    rms_acc[i] = 0;
    rms_level[i] = 0;
    rms_disp[i] = 0;
    peak_hold[i] = 0;
    peak_hold_tm[i] = 0;
    i += 1;
  );
  lfe_energy[0] = 0; lfe_peak[0] = 0; lfe_rms_acc[0] = 0; lfe_rms[0] = 0;
  lfe_hold[0] = 0; lfe_hold_tm[0] = 0;

  i = 0;
  loop(NUM_PHASE_PAIRS,
    phase_sum_ab[i] = 0;
    phase_sum_a2[i] = 0;
    phase_sum_b2[i] = 0;
    phase_corr[i] = 0;
    phase_smooth[i] = 0;
    i += 1;
  );

  memset(heatmap, 0, GRID_TOTAL);
  rms_counter[0] = 0;
  gonio_write[0] = 0;
  surr_write[0] = 0;
  
  // Mouse state tracking for click detection
  last_mouse_cap = 0;
  mouse_clicked_ui = 0;
  
  // Dragging state for listener rotation
  dragging_listener = 0;
  
  // --- K-WEIGHTING FILTER COEFFICIENTS (ITU-R BS.1770-4) ---
  // Two stages: Stage 1 (high-pass ~48Hz), Stage 2 (high-shelf +4dB @ 1681Hz)
  
  // Stage 1: High-pass filter (2nd order Butterworth @ 38 Hz)
  f0_hp = 38.13547087613982;
  Q_hp = 0.5003270373253953;
  K_hp = tan($pi * f0_hp / srate);
  norm_hp = 1.0 / (1.0 + K_hp / Q_hp + K_hp * K_hp);
  kw_b0_hp = norm_hp;
  kw_b1_hp = -2.0 * norm_hp;
  kw_b2_hp = norm_hp;
  kw_a1_hp = 2.0 * (K_hp * K_hp - 1.0) * norm_hp;
  kw_a2_hp = (1.0 - K_hp / Q_hp + K_hp * K_hp) * norm_hp;
  
  // Stage 2: High-shelf filter (+3.999 dB @ 1681.97 Hz)
  f0_hs = 1681.9744509555319;
  Q_hs = 0.7071752369554196;
  gain_hs_db = 3.999843853973347;
  A_hs = pow(10.0, gain_hs_db / 40.0);
  K_hs = tan($pi * f0_hs / srate);
  norm_hs = 1.0 / (1.0 + K_hs / Q_hs + K_hs * K_hs);
  kw_b0_hs = (1.0 + sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_b1_hs = 2.0 * (A_hs * K_hs * K_hs - 1.0) * norm_hs;
  kw_b2_hs = (1.0 - sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_a1_hs = 2.0 * (K_hs * K_hs - 1.0) * norm_hs;
  kw_a2_hs = (1.0 - K_hs / Q_hs + K_hs * K_hs) * norm_hs;
  
  // Clear filter states
  memset(kw_z1, 0, 20);
  memset(kw_z2, 0, 20);

  // --- PRE-COMPUTE WEIGHT TABLE ---
  // Use more gradual gaussian falloff for smooth spatial blending
  // Smaller decay coefficient = wider, softer influence zones = better blending
  decay_coeff = 8.0;  // Was 55.0 - too sharp. 8.0 gives smooth overlapping zones
  
  cell = 0;
  gy = 0;
  loop(GRID_H,
    gx = 0;
    loop(GRID_W,
      cx = (gx + 0.5) / GRID_W;
      cy = (gy + 0.5) / GRID_H;
      total_w = 0;
      s = 0;
      loop(NUM_SPEAKERS,
        dx = cx - spk_x[s];
        dy = cy - spk_y[s];
        dist_sq = dx * dx + dy * dy + 0.0001;
        // Wider gaussian = more overlap = smoother field
        w = exp(-dist_sq * decay_coeff);
        weight_table[cell * NUM_SPEAKERS + s] = w;
        total_w += w;
        s += 1;
      );
      total_w > 0.0001 ? (
        s = 0;
        loop(NUM_SPEAKERS,
          weight_table[cell * NUM_SPEAKERS + s] /= total_w;
          s += 1;
        );
      );
      cell += 1;
      gx += 1;
    );
    gy += 1;
  );

  // --- STATE ---
  last_w = 0;
  last_h = 0;
  energy_smooth = 0.80;

  // Read slider defaults
  decay_factor = 0.96;
  sensitivity = 1.0;
  display_mode = 0;
  meter_mode = 0;
  heatmap_brightness = 0.15;
  color_scheme = 0;
  show_grid = 0;
  wave_rings_vis = 1.0;
  outside_mask = 1;
  target_level = -23;
  phantom_smoothing = 0.85;
  heatmap_smoothing = 0.85;
  heatmap_lock_floor = 0;
  lufs_short = -120;
  lufs_mom = -120;
  lufs_int = -120;
  lufs_short_disp = -120;
  lufs_mom_disp = -120;
  lufs_int_disp = -120;
  lufs_short_acc = 0;
  lufs_short_cnt = 0;
  lufs_mom_acc = 0;
  lufs_mom_cnt = 0;
  lufs_int_acc = 0;
  lufs_int_cnt = 0;
  lufs_m_db = -100;
  lufs_s_db = -100;
  lufs_i_db = -100;
  lufs_win_pos = 0;
  lufs_win_cnt = 0;
  lufs_win_acc = 0;
  lufs_cur_buf = 0;
  lufs_cur_buf2 = 0;
  lufs_m_sum = 0;
  lufs_s_sum = 0;
  lufs_a_sum = 0;
  lufs_a_sum_cnt = 0;
  lufs_i_sum = 0;
  lufs_i_cnt = 0;

  // LUFS windowing (Cockos/REAPER)
  LOUD_METER_UPDATE = 0.10; // 100ms
  lufs_m_win_cnt = max(1, (0.4 / LOUD_METER_UPDATE) | 0);
  lufs_s_win_cnt = max(1, (3.0 / LOUD_METER_UPDATE) | 0);
  lufs_win_len = max(1, (LOUD_METER_UPDATE * srate) | 0);
  lufs_i_win_len = 1.0 / (lufs_m_win_cnt * lufs_win_len);
  lufs_i_win_len2 = 1.0 / (lufs_s_win_cnt * lufs_win_len);
  NUM_BINS = 1024;
  BINS_PER_DB = 10;
  DB_PER_BIN = 1.0 / BINS_PER_DB;

  // LUFS buffers and histograms (memory-safe region)
  lufs_buf = 50000;     // [50000..50000+lufs_m_win_cnt-1]
  lufs_buf2 = 50010;    // [50010..50010+lufs_s_win_cnt-1]
  lufs_a_hist = 50050;  // [50050..50050+NUM_BINS*2-1]
  
  // Per-meter peak hold for LUFS mode
  i = 0;
  loop(6,
    peak_hold_db[i] = -120;
    peak_hold_tm_db[i] = 0;
    i += 1;
  );

  // Clear LUFS buffers and histograms
  i = 0;
  loop(lufs_m_win_cnt,
    lufs_buf[i] = 0;
    i += 1;
  );
  i = 0;
  loop(lufs_s_win_cnt,
    lufs_buf2[i] = 0;
    i += 1;
  );
  i = 0;
  loop(NUM_BINS * 2,
    lufs_a_hist[i] = 0;
    i += 1;
  );

  // Heat map peak tracking
  heatmap_peak[0] = 0;
  heatmap_peak_hold[0] = 0;
  heatmap_min[0] = 1.0;
  heatmap_min_hold[0] = 1.0;
  
  // Phantom center
  phantom_center_x[0] = listen_x;
  phantom_center_y[0] = listen_y;
  heatmap_peak_hold[0] = 0;

// ======================================================================
// @slider
// ======================================================================
@slider
  listener_rotation = slider1 * slider20 * ($pi / 180.0);  // Convert degrees (-180 to +180) to radians
  display_mode     = slider4;
  meter_mode       = slider5;
  ui_mode          = slider6;
  gonio_sensitivity_user = slider7;
  gonio_pair       = slider8|0;
  sensitivity      = slider9;
  decay_factor     = slider10;
  heatmap_brightness = slider11;
  color_scheme     = slider12|0;
  heatmap_smoothing = slider13;
  heatmap_lock_floor = slider14;
  target_level     = slider15;
  show_grid        = slider16;
  wave_rings_vis   = slider17;
  outside_mask     = slider18;
  phantom_smoothing = slider19;
  // Phantom Center coordinates
  // (handled separately in phantom center calculations)

// ======================================================================
// @sample — Audio Processing Chain
// ORDER: Input -> PANORAMA ROTATION -> Energy/Peak/Metrics -> Output
// ======================================================================
@sample
  // === STEP 1: READ INPUT ===
  in_L   = spl0;
  in_R   = spl1;
  in_C   = spl2;
  in_LFE = spl3;
  in_Ls  = spl4;
  in_Rs  = spl5;

  // Synchronize listener rotation with slider1 (important for drag)
  listener_rotation = slider1 * slider20 * ($pi / 180.0);  // Convert degrees to radians

  // === STEP 2: 5.1 PANORAMA ROTATION ===
  // Choose mode based on slider3 (VBAP vs Amplitude)
  // Rotate audio around listener when slider1 changes
  // IMPORTANT: Rotating AUDIO for analysis with different panning modes
  // Listener arrow shows center channel direction.
  // Direction: slider right → sound rotates right (clockwise).
  
  // Read panorama control sliders
  panorama_enable = slider2;   // 0=Original (no pan), 1=Panorama Active
  panorama_mode = slider3;     // 0=VBAP clean, 1=Amplitude bleed
  
  // CORRECT IMPLEMENTATION: rotate each channel around listener
  // Each input channel has its physical angle, after rotation redistribute
  // signal between nearest output speakers (amplitude panning or VBAP).
  
  rot_angle = -listener_rotation;  // INVERTED: slider right = rotation left
  
  // Define output speaker angles (in radians, 0=up/center, positive clockwise)
  // Use speaker coordinates to calculate angles
  ang_C  = 0;                    // Center: 0° (up)
  ang_L  = atan2(spk_x[0] - 0.5, 0.5 - spk_y[0]);  // Front Left
  ang_R  = atan2(spk_x[1] - 0.5, 0.5 - spk_y[1]);  // Front Right  
  ang_Ls = atan2(spk_x[3] - 0.5, 0.5 - spk_y[3]);  // Rear Left
  ang_Rs = atan2(spk_x[4] - 0.5, 0.5 - spk_y[4]);  // Rear Right
  
  // VBAP function: Vector Base Amplitude Panning (clean, no crosstalk)
  // Distributes signal to the correct ADJACENT pair of speakers based on angle
  function distribute_vbap(source_angle, source_signal, outL*, outR*, outC*, outLs*, outRs*)
  local(ang_normalized, pair_idx, ang1, ang2, idx1, idx2, 
        g1, g2, total_g, ang_span, ang_in_span)
  (
    // Normalize angle to -π..π
    ang_normalized = source_angle;
    ang_normalized > $pi ? ang_normalized -= TWO_PI;
    ang_normalized < -$pi ? ang_normalized += TWO_PI;
    
    // Define 5 VBAP speaker pairs in clockwise order (indices into weights array)
    // Pair boundaries (angles sorted clockwise from -π to π):
    // ang_Ls (-128°) → ang_L (-40°) → ang_C (0°) → ang_R (+40°) → ang_Rs (+128°) → wrap to ang_Ls
    
    // Determine which adjacent pair contains this angle
    // Go clockwise: Ls → L → C → R → Rs → Ls (wrap)
    
    ang_normalized >= ang_Ls && ang_normalized < ang_L ? (
      // Between Ls and L (left wall)
      idx1 = 3; idx2 = 1;  // Ls → L
      ang1 = ang_Ls; ang2 = ang_L;
      ang_span = ang2 - ang1;  // Normal span (positive)
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_L && ang_normalized < ang_C ? (
      // Between L and C (front left)
      idx1 = 1; idx2 = 0;  // L → C
      ang1 = ang_L; ang2 = ang_C;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_C && ang_normalized < ang_R ? (
      // Between C and R (front right)
      idx1 = 0; idx2 = 2;  // C → R
      ang1 = ang_C; ang2 = ang_R;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_R && ang_normalized < ang_Rs ? (
      // Between R and Rs (right wall)
      idx1 = 2; idx2 = 4;  // R → Rs
      ang1 = ang_R; ang2 = ang_Rs;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : (
      // Between Rs and Ls (rear wall wrap: +128° → ±180° → -128°)
      // This covers: ang >= ang_Rs OR ang < ang_Ls
      idx1 = 4; idx2 = 3;  // Rs → Ls
      ang1 = ang_Rs; ang2 = ang_Ls;
      // Span goes through -180°/+180° boundary
      ang_span = TWO_PI - (ang1 - ang2);  // 360° - (128° - (-128°)) = 360° - 256° = 104°
      ang_in_span = ang_normalized - ang1;
      ang_in_span < 0 ? ang_in_span += TWO_PI;  // Wrap to positive
    );
    
    // Calculate gain using angular position within pair span
    // Linear interpolation between adjacent speakers (classic VBAP)
    g2 = ang_in_span / ang_span;  // 0.0 at ang1 (idx1), 1.0 at ang2 (idx2)
    g1 = 1.0 - g2;                // 1.0 at ang1, 0.0 at ang2
    
    // Gains are already normalized (g1 + g2 = 1.0)
    
    // Distribute to the correct pair
    // idx: 0=C, 1=L, 2=R, 3=Ls, 4=Rs
    idx1 == 0 ? (outC += source_signal * g1;) :
    idx1 == 1 ? (outL += source_signal * g1;) :
    idx1 == 2 ? (outR += source_signal * g1;) :
    idx1 == 3 ? (outLs += source_signal * g1;) :
                (outRs += source_signal * g1;);
    
    idx2 == 0 ? (outC += source_signal * g2;) :
    idx2 == 1 ? (outL += source_signal * g2;) :
    idx2 == 2 ? (outR += source_signal * g2;) :
    idx2 == 3 ? (outLs += source_signal * g2;) :
                (outRs += source_signal * g2;);
  );
  
  // Amplitude panning function: distributes signal between 5 speakers
  // based on source_angle (after rotation) - allows crosstalk
  function distribute_amplitude(source_angle, source_signal, outL*, outR*, outC*, outLs*, outRs*)
  local(ang_diff_C, ang_diff_L, ang_diff_R, ang_diff_Ls, ang_diff_Rs,
        weight_C, weight_L, weight_R, weight_Ls, weight_Rs, total_weight,
        ang_wrap)
  (
    // Normalize angle wrapping
    source_angle > $pi ? source_angle -= TWO_PI;
    source_angle < -$pi ? source_angle += TWO_PI;
    
    // Calculate angular distance to each speaker
    ang_diff_C = source_angle - ang_C;
    ang_diff_L = source_angle - ang_L;
    ang_diff_R = source_angle - ang_R;
    ang_diff_Ls = source_angle - ang_Ls;
    ang_diff_Rs = source_angle - ang_Rs;
    
    // Normalize differences to -π..π
    ang_diff_C > $pi ? ang_diff_C -= TWO_PI : ang_diff_C < -$pi ? ang_diff_C += TWO_PI;
    ang_diff_L > $pi ? ang_diff_L -= TWO_PI : ang_diff_L < -$pi ? ang_diff_L += TWO_PI;
    ang_diff_R > $pi ? ang_diff_R -= TWO_PI : ang_diff_R < -$pi ? ang_diff_R += TWO_PI;
    ang_diff_Ls > $pi ? ang_diff_Ls -= TWO_PI : ang_diff_Ls < -$pi ? ang_diff_Ls += TWO_PI;
    ang_diff_Rs > $pi ? ang_diff_Rs -= TWO_PI : ang_diff_Rs < -$pi ? ang_diff_Rs += TWO_PI;
    
    // Weight inversely proportional to angular distance (use cos for smooth transition)
    // All speakers contribute (amplitude bleed/crosstalk)
    weight_C = max(0, cos(ang_diff_C));
    weight_L = max(0, cos(ang_diff_L));
    weight_R = max(0, cos(ang_diff_R));
    weight_Ls = max(0, cos(ang_diff_Ls));
    weight_Rs = max(0, cos(ang_diff_Rs));
    
    total_weight = weight_C + weight_L + weight_R + weight_Ls + weight_Rs + 0.0001;
    
    // Normalize and add to outputs
    outC += source_signal * (weight_C / total_weight);
    outL += source_signal * (weight_L / total_weight);
    outR += source_signal * (weight_R / total_weight);
    outLs += source_signal * (weight_Ls / total_weight);
    outRs += source_signal * (weight_Rs / total_weight);
  );
  
  // Initialize output channels
  L_rotated = 0;
  R_rotated = 0;
  C_rotated = 0;
  Ls_rotated = 0;
  Rs_rotated = 0;
  
  // Choose panning mode based on slider3 (Panorama Mode)
  // Mode 0: VBAP (clean, no crosstalk)
  // Mode 1: Amplitude (bleed/crosstalk between speakers)
  panorama_mode == 0 ? (
    // VBAP: clean rotation, only 2 nearest speakers
    distribute_vbap(ang_L - rot_angle, in_L, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_R - rot_angle, in_R, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_C - rot_angle, in_C, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_Ls - rot_angle, in_Ls, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_Rs - rot_angle, in_Rs, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
  ) : (
    // Amplitude: bleed/crosstalk between all speakers
    distribute_amplitude(ang_L - rot_angle, in_L, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_R - rot_angle, in_R, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_C - rot_angle, in_C, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_Ls - rot_angle, in_Ls, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_Rs - rot_angle, in_Rs, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
  );
  
  // LFE not rotated (subwoofer is omnidirectional)
  LFE_rotated = in_LFE;

  // Select original or rotated audio based on slider2 (Panorama Enable)
  // 0 = Original (no panning, pure analyzer)
  // 1 = Panorama Active (rotated audio)
  panorama_enable = slider2;
  
  panorama_enable == 1 ? (
    // Panorama active - use rotated channels
    L_analyzed = L_rotated;
    R_analyzed = R_rotated;
    C_analyzed = C_rotated;
    Ls_analyzed = Ls_rotated;
    Rs_analyzed = Rs_rotated;
  ) : (
    // Original - no panorama
    L_analyzed = in_L;
    R_analyzed = in_R;
    C_analyzed = in_C;
    Ls_analyzed = in_Ls;
    Rs_analyzed = in_Rs;
  );
  LFE_analyzed = LFE_rotated;  // LFE not affected by panorama

  // --- DIVERGENCE (cross-feed to adjacent ITU-R speakers) ---
  div_L  = slider22;
  div_R  = slider23;
  div_C  = slider26;
  div_Ls = slider27;
  div_Rs = slider28;

  (div_L > 0.005 || div_R > 0.005 || div_C > 0.005 || div_Ls > 0.005 || div_Rs > 0.005) ? (
    pre_L  = L_analyzed;
    pre_R  = R_analyzed;
    pre_C  = C_analyzed;
    pre_Ls = Ls_analyzed;
    pre_Rs = Rs_analyzed;

    // Channel keeps (1-div), each neighbor gets div*0.5
    // Adjacency: L↔C, L↔Ls, R↔C, R↔Rs, Ls↔Rs (rear wrap)
    L_analyzed  = pre_L*(1-div_L)  + pre_C*div_C*0.5  + pre_Ls*div_Ls*0.5;
    R_analyzed  = pre_R*(1-div_R)  + pre_C*div_C*0.5  + pre_Rs*div_Rs*0.5;
    C_analyzed  = pre_C*(1-div_C)  + pre_L*div_L*0.5   + pre_R*div_R*0.5;
    Ls_analyzed = pre_Ls*(1-div_Ls)+ pre_L*div_L*0.5   + pre_Rs*div_Rs*0.5;
    Rs_analyzed = pre_Rs*(1-div_Rs)+ pre_R*div_R*0.5   + pre_Ls*div_Ls*0.5;
  );

  // --- CHANNEL MUTE (applied to analysis channels, affects scope/heatmap/phantom) ---
  mute_mask = slider21;
  mute_mask > 0 ? (
    (mute_mask & 1)  ? L_analyzed = 0;
    (mute_mask & 2)  ? R_analyzed = 0;
    (mute_mask & 4)  ? C_analyzed = 0;
    (mute_mask & 16) ? Ls_analyzed = 0;
    (mute_mask & 32) ? Rs_analyzed = 0;
    (mute_mask & 8)  ? LFE_analyzed = 0;
  );

  // --- ENERGY TRACKING (from analyzed audio - mix of original and rotated) ---
  abs_L   = abs(L_analyzed);
  abs_R   = abs(R_analyzed);
  abs_C   = abs(C_analyzed);
  abs_Ls  = abs(Ls_analyzed);
  abs_Rs  = abs(Rs_analyzed);
  abs_LFE = abs(LFE_analyzed);

  es = energy_smooth;
  esi = 1.0 - es;
  energy[0] = energy[0] * es + abs_L   * esi;
  energy[1] = energy[1] * es + abs_R   * esi;
  energy[2] = energy[2] * es + abs_C   * esi;
  energy[3] = energy[3] * es + abs_Ls  * esi;
  energy[4] = energy[4] * es + abs_Rs  * esi;
  lfe_energy[0] = lfe_energy[0] * es + abs_LFE * esi;

  // Additional heat map smoothing (user-controlled)
  hs = heatmap_smoothing;
  hsi = 1.0 - hs;
  heatmap_energy[0] = heatmap_energy[0] * hs + energy[0] * hsi;
  heatmap_energy[1] = heatmap_energy[1] * hs + energy[1] * hsi;
  heatmap_energy[2] = heatmap_energy[2] * hs + energy[2] * hsi;
  heatmap_energy[3] = heatmap_energy[3] * hs + energy[3] * hsi;
  heatmap_energy[4] = heatmap_energy[4] * hs + energy[4] * hsi;

  // --- PEAK TRACKING (from rotated channels) ---
  m_dec = 0.9998;
  peak_level[0] = max(peak_level[0] * m_dec, abs_L);
  peak_level[1] = max(peak_level[1] * m_dec, abs_R);
  peak_level[2] = max(peak_level[2] * m_dec, abs_C);
  peak_level[3] = max(peak_level[3] * m_dec, abs_Ls);
  peak_level[4] = max(peak_level[4] * m_dec, abs_Rs);
  lfe_peak[0]   = max(lfe_peak[0] * m_dec, abs_LFE);

  // --- RMS ACCUMULATION (from analyzed channels) ---
  rms_acc[0] += L_analyzed  * L_analyzed;
  rms_acc[1] += R_analyzed  * R_analyzed;
  rms_acc[2] += C_analyzed  * C_analyzed;
  rms_acc[3] += Ls_analyzed * Ls_analyzed;
  rms_acc[4] += Rs_analyzed * Rs_analyzed;
  lfe_rms_acc[0] += LFE_analyzed * LFE_analyzed;

  // --- LUFS (Cockos/REAPER: K-weighted from analyzed channels) ---
  // Apply K-weighting filters to analyzed channels
  
  // Channel 0: L (analyzed)
  kw_in = L_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[0] + kw_b2_hp * kw_z2[0] - kw_a1_hp * kw_z1[1] - kw_a2_hp * kw_z2[1];
  kw_z2[0] = kw_z1[0]; kw_z1[0] = kw_in;
  kw_z2[1] = kw_z1[1]; kw_z1[1] = kw_out;
  kw_in = kw_out;
  kw_L = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[2] + kw_b2_hs * kw_z2[2] - kw_a1_hs * kw_z1[3] - kw_a2_hs * kw_z2[3];
  kw_z2[2] = kw_z1[2]; kw_z1[2] = kw_in;
  kw_z2[3] = kw_z1[3]; kw_z1[3] = kw_L;
  
  // Channel 1: R (analyzed)
  kw_in = R_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[4] + kw_b2_hp * kw_z2[4] - kw_a1_hp * kw_z1[5] - kw_a2_hp * kw_z2[5];
  kw_z2[4] = kw_z1[4]; kw_z1[4] = kw_in;
  kw_z2[5] = kw_z1[5]; kw_z1[5] = kw_out;
  kw_in = kw_out;
  kw_R = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[6] + kw_b2_hs * kw_z2[6] - kw_a1_hs * kw_z1[7] - kw_a2_hs * kw_z2[7];
  kw_z2[6] = kw_z1[6]; kw_z1[6] = kw_in;
  kw_z2[7] = kw_z1[7]; kw_z1[7] = kw_R;
  
  // Channel 2: C (analyzed)
  kw_in = C_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[8] + kw_b2_hp * kw_z2[8] - kw_a1_hp * kw_z1[9] - kw_a2_hp * kw_z2[9];
  kw_z2[8] = kw_z1[8]; kw_z1[8] = kw_in;
  kw_z2[9] = kw_z1[9]; kw_z1[9] = kw_out;
  kw_in = kw_out;
  kw_C = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[10] + kw_b2_hs * kw_z2[10] - kw_a1_hs * kw_z1[11] - kw_a2_hs * kw_z2[11];
  kw_z2[10] = kw_z1[10]; kw_z1[10] = kw_in;
  kw_z2[11] = kw_z1[11]; kw_z1[11] = kw_C;
  
  // Channel 3: Ls (analyzed)
  kw_in = Ls_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[12] + kw_b2_hp * kw_z2[12] - kw_a1_hp * kw_z1[13] - kw_a2_hp * kw_z2[13];
  kw_z2[12] = kw_z1[12]; kw_z1[12] = kw_in;
  kw_z2[13] = kw_z1[13]; kw_z1[13] = kw_out;
  kw_in = kw_out;
  kw_Ls = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[14] + kw_b2_hs * kw_z2[14] - kw_a1_hs * kw_z1[15] - kw_a2_hs * kw_z2[15];
  kw_z2[14] = kw_z1[14]; kw_z1[14] = kw_in;
  kw_z2[15] = kw_z1[15]; kw_z1[15] = kw_Ls;
  
  // Channel 4: Rs (analyzed)
  kw_in = Rs_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[16] + kw_b2_hp * kw_z2[16] - kw_a1_hp * kw_z1[17] - kw_a2_hp * kw_z2[17];
  kw_z2[16] = kw_z1[16]; kw_z1[16] = kw_in;
  kw_z2[17] = kw_z1[17]; kw_z1[17] = kw_out;
  kw_in = kw_out;
  kw_Rs = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[18] + kw_b2_hs * kw_z2[18] - kw_a1_hs * kw_z1[19] - kw_a2_hs * kw_z2[19];
  kw_z2[18] = kw_z1[18]; kw_z1[18] = kw_in;
  kw_z2[19] = kw_z1[19]; kw_z1[19] = kw_Rs;
  
  // Cockos/REAPER weights (LUFS): L, R, C = 1.0; Ls/Rs = √2 (power * 1.7)
  // Power calculation with K-weighted samples: z[n] = L² + R² + C² + 1.7*Ls² + 1.7*Rs²
  // LFE not included in loudness measurement
  // Weighted mean square using K-weighted samples
  lufs_ms = kw_L*kw_L + kw_R*kw_R + kw_C*kw_C + 1.7*kw_Ls*kw_Ls + 1.7*kw_Rs*kw_Rs;

  // Cockos-style LUFS windowing (momentary/short/integrated with gating)
  lufs_win_acc += lufs_ms;
  (lufs_win_pos += 1) >= lufs_win_len ? (
    lufs_win_pos = 0;
    lufs_win_cnt += 1;
    lval = lufs_win_acc;
    lufs_win_acc = 0;

    prev_lval = lufs_buf[lufs_cur_buf];
    lufs_buf[lufs_cur_buf] = lval;
    lufs_cur_buf += 1;
    lufs_cur_buf >= lufs_m_win_cnt ? lufs_cur_buf = 0;

    prev_lval2 = lufs_buf2[lufs_cur_buf2];
    lufs_buf2[lufs_cur_buf2] = lval;
    lufs_cur_buf2 += 1;
    lufs_cur_buf2 >= lufs_s_win_cnt ? lufs_cur_buf2 = 0;

    lufs_m_sum += (lval - prev_lval) * lufs_i_win_len;
    lufs_s_sum += (lval - prev_lval2) * lufs_i_win_len2;

    lufs_m_sum > 0 && lufs_win_cnt >= lufs_m_win_cnt ? (
      lufs_m_db = 0.8 + log(lufs_m_sum) * 10 / log(10);

      a = ((lufs_m_db + 70) * BINS_PER_DB) | 0;
      a >= 0 ? (
        a >= NUM_BINS ? a = NUM_BINS - 1;
        lufs_a_sum += lufs_m_sum;
        lufs_a_sum_cnt += 1;
        lufs_a_hist[2 * a] += 1;
        lufs_a_hist[2 * a + 1] += lufs_m_sum;

        lufs_a_db = 0.8 + log(lufs_a_sum / lufs_a_sum_cnt) * 10 / log(10);
        lufs_a_gate = ((lufs_a_db - 10 + 70) * BINS_PER_DB) | 0;

        lufs_i_sum = 0;
        lufs_i_cnt = 0;
        bin = max(lufs_a_gate, 0);
        loop(NUM_BINS - bin,
          lufs_i_cnt += lufs_a_hist[2 * bin];
          lufs_i_sum += lufs_a_hist[2 * bin + 1];
          bin += 1;
        );
        lufs_i_db = lufs_i_sum > 0 ? 0.8 + log(lufs_i_sum / lufs_i_cnt) * 10 / log(10) : -100;
      );
    );

    lufs_s_sum > 0 && lufs_win_cnt >= lufs_s_win_cnt ? (
      lufs_s_db = 0.8 + log(lufs_s_sum) * 10 / log(10);
    );

    lufs_mom = lufs_m_db;
    lufs_short = lufs_s_db;
    lufs_int = lufs_i_db;
  );

  // Smooth LUFS display to avoid strobing
  // Momentary (400ms window) - fastest response
  lufs_mom_disp = lufs_mom_disp * 0.95 + lufs_mom * 0.05;
  // Short-term (3s window) - medium response
  lufs_short_disp = lufs_short_disp * 0.98 + lufs_short * 0.02;
  // Integrated (continuous) - slowest, most stable
  lufs_int_disp = lufs_int_disp * 0.995 + lufs_int * 0.005;

  // --- PHASE CORRELATION ACCUMULATION (10 pairs from analyzed channels) ---
  // Pair 0: L-R
  phase_sum_ab[0] += L_analyzed * R_analyzed;
  phase_sum_a2[0] += L_analyzed * L_analyzed;
  phase_sum_b2[0] += R_analyzed * R_analyzed;
  // Pair 1: L-C
  phase_sum_ab[1] += L_analyzed * C_analyzed;
  phase_sum_a2[1] += L_analyzed * L_analyzed;
  phase_sum_b2[1] += C_analyzed * C_analyzed;
  // Pair 2: L-Ls
  phase_sum_ab[2] += L_analyzed * Ls_analyzed;
  phase_sum_a2[2] += L_analyzed * L_analyzed;
  phase_sum_b2[2] += Ls_analyzed * Ls_analyzed;
  // Pair 3: L-Rs
  phase_sum_ab[3] += L_analyzed * Rs_analyzed;
  phase_sum_a2[3] += L_analyzed * L_analyzed;
  phase_sum_b2[3] += Rs_analyzed * Rs_analyzed;
  // Pair 4: R-C
  phase_sum_ab[4] += R_analyzed * C_analyzed;
  phase_sum_a2[4] += R_analyzed * R_analyzed;
  phase_sum_b2[4] += C_analyzed * C_analyzed;
  // Pair 5: R-Ls
  phase_sum_ab[5] += R_analyzed * Ls_analyzed;
  phase_sum_a2[5] += R_analyzed * R_analyzed;
  phase_sum_b2[5] += Ls_analyzed * Ls_analyzed;
  // Pair 6: R-Rs
  phase_sum_ab[6] += R_analyzed * Rs_analyzed;
  phase_sum_a2[6] += R_analyzed * R_analyzed;
  phase_sum_b2[6] += Rs_analyzed * Rs_analyzed;
  // Pair 7: C-Ls
  phase_sum_ab[7] += C_analyzed * Ls_analyzed;
  phase_sum_a2[7] += C_analyzed * C_analyzed;
  phase_sum_b2[7] += Ls_analyzed * Ls_analyzed;
  // Pair 8: C-Rs
  phase_sum_ab[8] += C_analyzed * Rs_analyzed;
  phase_sum_a2[8] += C_analyzed * C_analyzed;
  phase_sum_b2[8] += Rs_analyzed * Rs_analyzed;
  // Pair 9: Ls-Rs
  phase_sum_ab[9] += Ls_analyzed * Rs_analyzed;
  phase_sum_a2[9] += Ls_analyzed * Ls_analyzed;
  phase_sum_b2[9] += Rs_analyzed * Rs_analyzed;

  // --- GONIOMETER SAMPLE BUFFER (from analyzed channels) ---
  // Store selected channel pair based on gonio_pair slider
  gw = gonio_write[0];
  gonio_pair == 0 ? (  // L-R
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = R_analyzed;
  ) : gonio_pair == 1 ? (  // L-C
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = C_analyzed;
  ) : gonio_pair == 2 ? (  // L-Ls
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 3 ? (  // L-Rs
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : gonio_pair == 4 ? (  // R-C
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = C_analyzed;
  ) : gonio_pair == 5 ? (  // R-Ls
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 6 ? (  // R-Rs
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : gonio_pair == 7 ? (  // C-Ls
    GONIO_BUF[gw * 2]     = C_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 8 ? (  // C-Rs
    GONIO_BUF[gw * 2]     = C_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : (  // 9: Ls-Rs
    GONIO_BUF[gw * 2]     = Ls_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  );
  gw += 1;
  gw >= GONIO_SIZE ? gw = 0;
  gonio_write[0] = gw;

  // --- 5.1 SURROUND GONIOMETER BUFFER (from analyzed channels) ---
  sw = surr_write[0];
  SURR_BUF[sw * 5]     = L_analyzed;
  SURR_BUF[sw * 5 + 1] = R_analyzed;
  SURR_BUF[sw * 5 + 2] = C_analyzed;
  SURR_BUF[sw * 5 + 3] = Ls_analyzed;
  SURR_BUF[sw * 5 + 4] = Rs_analyzed;
  sw += 1;
  sw >= SURR_SIZE ? sw = 0;
  surr_write[0] = sw;

  // --- PERIODIC RMS + PHASE COMPUTATION ---
  rms_counter[0] += 1;
  rms_counter[0] >= RMS_WINDOW ? (
    inv_n = 1.0 / RMS_WINDOW;
    s = 0;
    loop(NUM_SPEAKERS,
      rms_level[s] = sqrt(rms_acc[s] * inv_n);
      rms_disp[s] = rms_disp[s] * 0.7 + rms_level[s] * 0.3;
      rms_acc[s] = 0;
      s += 1;
    );
    lfe_rms[0] = sqrt(lfe_rms_acc[0] * inv_n);
    lfe_rms_acc[0] = 0;

    p = 0;
    loop(NUM_PHASE_PAIRS,
      denom = sqrt(phase_sum_a2[p] * phase_sum_b2[p]);
      denom > 0.00001 ? (
        phase_corr[p] = phase_sum_ab[p] / denom;
      ) : (
        phase_corr[p] = 0;
      );
      phase_smooth[p] = phase_smooth[p] * 0.7 + phase_corr[p] * 0.3;
      phase_sum_ab[p] = 0;
      phase_sum_a2[p] = 0;
      phase_sum_b2[p] = 0;
      p += 1;
    );
    rms_counter[0] = 0;
  );

  // === STEP 4: OUTPUT (binary panorama enable from slider2) ===
  // slider2=0 (Original): pass through original audio unchanged
  // slider2=1 (Panorama Active): use rotated audio
  // slider3: chooses panning mode (0=VBAP clean, 1=Amplitude bleed)
  // Binary selection to avoid phase cancellation from mixing
  panorama_enable == 1 ? (
    spl0 = L_rotated;
    spl1 = R_rotated;
    spl2 = C_rotated;
    spl3 = in_LFE;  // LFE not rotated
    spl4 = Ls_rotated;
    spl5 = Rs_rotated;
  ) : (
    spl0 = in_L;
    spl1 = in_R;
    spl2 = in_C;
    spl3 = in_LFE;
    spl4 = in_Ls;
    spl5 = in_Rs;
  );

  // === CHANNEL MUTE (post-metering, affects output only) ===
  mute_mask = slider21;
  mute_mask > 0 ? (
    (mute_mask & 1)  ? spl0 = 0;   // L
    (mute_mask & 2)  ? spl1 = 0;   // R
    (mute_mask & 4)  ? spl2 = 0;   // C
    (mute_mask & 8)  ? spl3 = 0;   // LFE
    (mute_mask & 16) ? spl4 = 0;   // Ls
    (mute_mask & 32) ? spl5 = 0;   // Rs
  );

// ======================================================================
// @block — Per-block processing (runs always, independent of UI)
// ======================================================================
@block
  // === PHANTOM CENTER CALCULATION ===
  // Computed here (not in @gfx) so slider output works even when UI window is closed.
  // Uses speaker energies to calculate weighted centroid of the sound field.
  phantom_x = 0;
  phantom_y = 0;
  total_weight = 0;

  s = 0;
  loop(NUM_SPEAKERS,
    e = heatmap_energy[s] * sensitivity * 10.0;
    e = min(e, 1.0);
    e > 0.05 ? (
      weight = e * e;
      phantom_x += spk_x[s] * weight;
      phantom_y += spk_y[s] * weight;
      total_weight += weight;
    );
    s += 1;
  );

  total_weight > 0.001 ? (
    phantom_x /= total_weight;
    phantom_y /= total_weight;

    // Smooth phantom center movement (controllable via slider)
    phantom_center_x[0] = phantom_center_x[0] * phantom_smoothing + phantom_x * (1.0 - phantom_smoothing);
    phantom_center_y[0] = phantom_center_y[0] * phantom_smoothing + phantom_y * (1.0 - phantom_smoothing);
  ) : (
    // Default to listener position if no energy
    slow_return = min(0.95, phantom_smoothing + 0.1);
    phantom_center_x[0] = phantom_center_x[0] * slow_return + listen_x * (1.0 - slow_return);
    phantom_center_y[0] = phantom_center_y[0] * slow_return + listen_y * (1.0 - slow_return);
  );

  // Output phantom center coordinates to sliders for automation
  slider24 = phantom_center_x[0];
  slider25 = phantom_center_y[0];
  sliderchange(slider24 | slider25);

// ======================================================================
// @gfx — Drawing
// ======================================================================
@gfx 640 520

  // --- COLOR PALETTE ---
  bg_r = 0.10; bg_g = 0.10; bg_b = 0.12;
  pnl_r = 0.07; pnl_g = 0.07; pnl_b = 0.08;
  brd_r = 0.149; brd_g = 0.149; brd_b = 0.173;
  acc_r = 0.20; acc_g = 0.80; acc_b = 0.40;
  mtr_r = 0.15; mtr_g = 0.65; mtr_b = 0.35;
  txt_r = 0.80; txt_g = 0.80; txt_b = 0.80;

  // --- BUFFER RESIZE ---
  (gfx_w != last_w || gfx_h != last_h) ? (
    last_w = gfx_w;
    last_h = gfx_h;
    gfx_setimgdim(HEAT_BUFFER, GRID_W, GRID_H);
    gfx_dest = HEAT_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, GRID_W, GRID_H);
    gfx_dest = -1;

    gfx_setimgdim(GONIO_BUFFER, 256, 256);
    gfx_dest = GONIO_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, 256, 256);
    gfx_dest = -1;

    gfx_setimgdim(SURR_BUFFER, GRID_W, GRID_H);
    gfx_dest = SURR_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, GRID_W, GRID_H);
    gfx_dest = -1;
  );

  // --- FONT SETUP ---
  sc = min(gfx_w / 640, gfx_h / 520);
  sc < 0.5 ? sc = 0.5;
  sc > 2.0 ? sc = 2.0;
  font_sm  = max(10, (11 * sc)|0);
  font_md  = max(11, (13 * sc)|0);
  font_lg  = max(13, (16 * sc)|0);
  gfx_setfont(1, "Arial", font_lg, 'b');
  gfx_setfont(2, "Arial", font_md);
  gfx_setfont(3, "Arial", font_sm);

  // Synchronize listener rotation for display
  listener_rotation = slider1 * slider20 * ($pi / 180.0);

  // --- LAYOUT ---
  title_h = max(26, (30 * sc)|0);
  phase_h = max(44, (55 * sc)|0);
  lfe_h   = max(24, (30 * sc)|0);
  pad     = max(8,  (12 * sc)|0);

  field_top  = title_h + pad;
  field_bot  = gfx_h - phase_h - lfe_h - pad * 2;
  field_left = pad;
  field_right = gfx_w - pad;
  field_w = field_right - field_left;
  field_h = field_bot - field_top;

  legend_w = max(18, (26 * sc)|0);
  legend_gap = max(6, (10 * sc)|0);
  meter_panel_w = max(100, (130 * sc)|0);
  meter_panel_gap = max(6, (10 * sc)|0);

  main_w = field_w - legend_w - legend_gap - meter_panel_gap - meter_panel_w;
  main_w < 100 ? main_w = 100;
  field_size = min(main_w, field_h);
  field_size < 100 ? field_size = 100;
  
  field_x0 = field_left + legend_w + legend_gap + (main_w - field_size) * 0.5;
  field_y0 = field_top + (field_h - field_size) * 0.5;
  
  // Goniometer with proper sizing and positioning to avoid overlap
  display_mode == 1 ? (
    // Goniometer same size and position as heat map (centered)
    gon_size = field_size;
  ) : (
    // Heat map: center normally with padding
    field_x0 = max(field_x0, field_left + pad);
    field_y0 = max(field_y0, field_top + pad);
  );

  phase_top = gfx_h - phase_h - lfe_h - pad;
  lfe_top   = gfx_h - lfe_h - (pad * 0.5);

  // =====================================================
  // BACKGROUND
  // =====================================================
  gfx_set(bg_r, bg_g, bg_b, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);

  // --- TITLE BAR ---
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(0, 0, gfx_w, title_h);
  gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_line(0, title_h, gfx_w, title_h);

  gfx_setfont(1);
  gfx_set(acc_r, acc_g, acc_b, 1);
  gfx_x = pad; gfx_y = (title_h - font_lg) * 0.5;
  gfx_drawstr("SBP SURROUND SCOPE 5.1");

  // Mode buttons after title
  title_end_x = gfx_x;
  btn_gap = max(10, (12 * sc)|0);
  btn_h = max(18, (20 * sc)|0);
  btn_y = (title_h -btn_h) * 0.5;
  gfx_setfont(4);
  
  // Sound Field button
  #btn1_text = "SOUND FIELD";
  gfx_measurestr(#btn1_text, btn1_w, btn1_h);
  btn1_w += max(8, (12 * sc)|0);
  btn1_x = title_end_x + btn_gap;
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h);
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h, 0);
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn1_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn1_h) * 0.5;
  gfx_drawstr(#btn1_text);
  
  // Goniometer button
  #btn2_text = "GONIOMETER";
  gfx_measurestr(#btn2_text, btn2_w, btn2_h);
  btn2_w += max(8, (12 * sc)|0);
  btn2_x = btn1_x + btn1_w + max(4, (6 * sc)|0);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h, 0);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn2_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn2_h) * 0.5;
  gfx_drawstr(#btn2_text);
  
  // Compact View button on the right
  #btn3_text = ui_mode == 0 ? "COMPACT" : "FULL UI";
  gfx_measurestr(#btn3_text, btn3_w, btn3_h);
  btn3_w += max(8, (12 * sc)|0);
  btn3_x = gfx_w - pad - btn3_w;
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h, 0);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn3_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn3_h) * 0.5;
  gfx_drawstr(#btn3_text);
  
  // Show goniometer pair label in compact mode
  display_mode == 1 && ui_mode == 1 ? (
    gfx_set(txt_r, txt_g, txt_b, 0.4);
    gonio_pair == 0 ? #pair_str = "L-R" :
    gonio_pair == 1 ? #pair_str = "L-C" :
    gonio_pair == 2 ? #pair_str = "L-Ls" :
    gonio_pair == 3 ? #pair_str = "L-Rs" :
    gonio_pair == 4 ? #pair_str = "R-C" :
    gonio_pair == 5 ? #pair_str = "R-Ls" :
    gonio_pair == 6 ? #pair_str = "R-Rs" :
    gonio_pair == 7 ? #pair_str = "C-Ls" :
    gonio_pair == 8 ? #pair_str = "C-Rs" :
                      #pair_str = "Ls-Rs";
    sprintf(#mode_str, "[%s]", #pair_str);
    gfx_measurestr(#mode_str, mw, mh);
    gfx_x = btn3_x - btn_gap - mw;
    gfx_y = (title_h - mh) * 0.5;
    gfx_drawstr(#mode_str);
  );
  
  // =====================================================
  // MOUSE INTERACTION - Title Bar Buttons
  // =====================================================
  mouse_clicked_ui = 0;  // Reset each frame
  
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    // Sound Field button
    mouse_x >= btn1_x && mouse_x <= btn1_x + btn1_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider4 = 0;
      display_mode = 0;
      sliderchange(slider4);
      mouse_clicked_ui = 1;
    ) : 
    // Goniometer button
    mouse_x >= btn2_x && mouse_x <= btn2_x + btn2_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider4 = 1;
      display_mode = 1;
      sliderchange(slider4);
      mouse_clicked_ui = 1;
    ) : 
    // Compact/Full UI button - toggle slider visibility
    mouse_x >= btn3_x && mouse_x <= btn3_x + btn3_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider6 = 1 - slider6;
      ui_mode = slider6;
      sliders_showing = slider_show(UI_SLIDERS_MASK, slider6 ? 0 : 1) > 0;
      sliderchange(slider6);
      mouse_clicked_ui = 1;
    );
  );

  // =====================================================
  // HEAT MAP (Display Mode 0 or 2)
  // =====================================================
  display_mode == 0 ? (

    // Reset current peak and min for this frame
    heatmap_peak[0] = 0;
    heatmap_min[0] = 1.0;

    // Determine heat map field size and reserve space for legend + meters
    hm_size = field_size;
    hm_x0 = field_x0;
    hm_y0 = field_y0;
    legend_x0 = field_x0 - legend_gap - legend_w;
    legend_y0 = field_y0;
    legend_h = hm_size;

    // --- DECAY HEAT MAP BUFFER ---
    gfx_dest = HEAT_BUFFER;
    gfx_muladdrect(0, 0, GRID_W, GRID_H,
      decay_factor, decay_factor, decay_factor, 1.0,
      0, 0, 0, 0
    );

    // --- UPDATE HEAT MAP ---
    gfx_mode = 1; // additive blending
    
    // Heat map uses ORIGINAL speaker positions (not rotated visualization)
    // The rotated AUDIO will naturally show up in different places on the static visualization
    
    cell = 0;
    gy = 0;
    loop(GRID_H,
      gx = 0;
      loop(GRID_W,
        cx = (gx + 0.5) / GRID_W;
        cy = (gy + 0.5) / GRID_H;
        
        val = 0;
        total_w = 0;
        s = 0;
        loop(NUM_SPEAKERS,
          // Use ORIGINAL speaker positions (visualization does NOT rotate)
          dx = cx - spk_x[s];
          dy = cy - spk_y[s];
          dist_sq = dx * dx + dy * dy + 0.0001;
          
          // Weight using rotated positions
          w = exp(-dist_sq * 8.0);  // decay_coeff = 8.0
          val += heatmap_energy[s] * w;
          total_w += w;
          s += 1;
        );
        
        // Normalize weights
        total_w > 0.0001 ? (
          val /= total_w;
        );
        val *= sensitivity * 10.0;

        // Optional dB scaling with locked floor
        heatmap_lock_floor > 0.5 ? (
          floor_db = -60.0;
          val_db = 20.0 * log(max(val, 0.000001)) / log(10);
          val = (val_db - floor_db) / (0.0 - floor_db);
        );

        val = max(0.0, min(val, 1.0));
        
        // Softer contrast curve - less aggressive power curve
        // Old: val = val * val produces too much contrast
        // New: more linear in low range, slight curve in high range
        val < 0.5 ? (
          val = val * 0.8;  // Soften low values: 0..0.5 -> 0..0.4
        ) : (
          val = 0.4 + (val - 0.5) * 1.2;  // Slight boost in high range
        );

        val > 0.0015 ? (  // Lower threshold to show more detail
          // Track peak and minimum (only in active range above 5%)
          val > heatmap_peak[0] ? heatmap_peak[0] = val;
          val > 0.05 && val < heatmap_min[0] ? heatmap_min[0] = val;  // Min only for audible content
          
          // Apply color scheme
          get_color(val, color_scheme, cr, cg, cb);
          
          // Apply brightness - simple linear scaling
          cr = min(1.0, cr * heatmap_brightness);
          cg = min(1.0, cg * heatmap_brightness);
          cb = min(1.0, cb * heatmap_brightness);

          gfx_x = gx;
          gfx_y = gy;
          gfx_setpixel(cr, cg, cb);
        );

        cell += 1;
        gx += 1;
      );
      gy += 1;
    );
    gfx_mode = 0;
    gfx_dest = -1;

    // Update peak hold and min hold with decay (speed depends on meter mode)
    // Peak: fast, RMS: medium, LUFS: slow
    decay_speed = meter_mode == 0 ? 0.99 : meter_mode == 1 ? 0.995 : 0.998;
    
    heatmap_peak[0] > heatmap_peak_hold[0] ? heatmap_peak_hold[0] = heatmap_peak[0];
    heatmap_peak_hold[0] *= decay_speed;
    
    heatmap_min[0] < heatmap_min_hold[0] ? heatmap_min_hold[0] = heatmap_min[0];
    heatmap_min_hold[0] = heatmap_min_hold[0] * decay_speed + heatmap_min[0] * (1.0 - decay_speed);

    // --- FIELD BACKGROUND ---
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(hm_x0, hm_y0, hm_size, hm_size);

    // --- BLIT HEAT MAP ---
    gfx_blit(HEAT_BUFFER, 1, 0,
      0, 0, GRID_W, GRID_H,
      hm_x0, hm_y0, hm_size, hm_size
    );

    // --- PHANTOM CENTER MARKER ---
    // Use smoothed position for stable visualization
    pcx = hm_x0 + phantom_center_x[0] * hm_size;
    pcy = hm_y0 + phantom_center_y[0] * hm_size;
    
    // Draw circle with cross marker (doubled size)
    marker_r = max(12, (16 * sc)|0);
    
    // Outer circle (dark outline)
    gfx_set(0.0, 0.0, 0.0, 0.8);
    gfx_circle(pcx, pcy, marker_r + 1, 0, 1);
    
    // Inner circle (bright accent)
    gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 0.9);
    gfx_circle(pcx, pcy, marker_r, 0, 1);
    
    // Cross lines
    gfx_set(1.0, 1.0, 1.0, 0.9);
    cross_len = marker_r * 0.6;
    gfx_line(pcx - cross_len, pcy, pcx + cross_len, pcy);
    gfx_line(pcx, pcy - cross_len, pcx, pcy + cross_len);
    
    // Center dot
    gfx_circle(pcx, pcy, 1.5, 1, 1);

    // --- SPEAKER ICONS + LABELS + EXPANDING WAVE RINGS ---
    // (Drawn before outside mask so wave rings are properly clipped)
    s = 0;
    loop(NUM_SPEAKERS,
      sx = hm_x0 + spk_x[s] * hm_size;
      sy = hm_y0 + spk_y[s] * hm_size;

      e = energy[s] * sensitivity * 4.0;
      e = min(e, 1.0);
      
      // Expanding wave rings with decay animation (clipped to heat map bounds)
      wave_rings_vis > 0.01 ? (
        // Draw 4 expanding wave rings from energy history with bigger size and brighter
        ring = 0;
        loop(4,
          // Base ring radius - increased for better visibility
          base_r = 12 + (e * 35);  // Was: 6 + (e * 22)
          ring_r = base_r + ring * 10;  // Each ring is spaced 10 pixels apart (was 6)
          
          // Opacity - brighter for better visibility
          opacity_ring = e * wave_rings_vis * pow(0.7, ring) * 1.5;  // Added 1.5x multiplier
          opacity_ring = min(opacity_ring, 0.9);  // Cap at 0.9
          opacity_ring > 0.01 ? (
            // Draw circle segments that stay within heat map bounds
            // Draw full circle only if center + radius is inside bounds
            (sx >= hm_x0 + ring_r && sx <= hm_x0 + hm_size - ring_r &&
             sy >= hm_y0 + ring_r && sy <= hm_y0 + hm_size - ring_r) ? (
              gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, opacity_ring);  // Brighter color
              gfx_circle(sx, sy, ring_r, 0);  // Draw outline only
            );
          );
          
          ring += 1;
        );
      );

      s += 1;
    );

    // --- DARKEN AREA OUTSIDE LISTENING ZONE ---
    // Darken area outside ITU-R BS.775 circle (radius 0.35)
    outside_mask > 0.5 ? (
      gfx_mode = 0;  // Normal blending
      gfx_set(0.02, 0.02, 0.03, 1.0);

      // ITU-R BS.775 circle: radius 0.35 from center
      circle_cx = hm_x0 + hm_size * 0.5;
      circle_cy = hm_y0 + hm_size * 0.5;
      circle_r = hm_size * 0.35;

      // Darken entire heat map area outside circle using radial triangles
      // Extend to corners of square (diagonal = sqrt(2) * 0.5 = 0.707)
      steps = 128;  // More steps for smoother coverage
      i = 0;
      loop(steps,
        angle = i * TWO_PI / steps;
        angle_next = (i + 1) * TWO_PI / steps;

        // Points on circle edge
        x1 = circle_cx + cos(angle) * circle_r;
        y1 = circle_cy + sin(angle) * circle_r;
        x1_next = circle_cx + cos(angle_next) * circle_r;
        y1_next = circle_cy + sin(angle_next) * circle_r;

        // Extend to heat map corners (radius to corner = 0.707 of size)
        extend_r = hm_size * 0.75;  // Slightly beyond diagonal to ensure full coverage
        x2 = circle_cx + cos(angle) * extend_r;
        y2 = circle_cy + sin(angle) * extend_r;
        x2_next = circle_cx + cos(angle_next) * extend_r;
        y2_next = circle_cy + sin(angle_next) * extend_r;

        // Clamp to heat map boundaries (this prevents overflow beyond heat map area)
        x2 = max(hm_x0, min(hm_x0 + hm_size, x2));
        y2 = max(hm_y0, min(hm_y0 + hm_size, y2));
        x2_next = max(hm_x0, min(hm_x0 + hm_size, x2_next));
        y2_next = max(hm_y0, min(hm_y0 + hm_size, y2_next));

        // Draw two triangles to fill the wedge from circle to boundary
        gfx_triangle(x1, y1, x2, y2, x1_next, y1_next);
        gfx_triangle(x2, y2, x2_next, y2_next, x1_next, y1_next);

        i += 1;
      );
    );

    // --- WAVE RINGS FOR REAR SPEAKERS (drawn after mask to prevent dimming) ---
    wave_rings_vis > 0.01 ? (
      // Draw rear speaker wave rings (Ls=3, Rs=4)
      rear_spks = 0;
      loop(2,
        spk_idx = rear_spks == 0 ? 3 : 4;  // Ls or Rs
        sx = hm_x0 + spk_x[spk_idx] * hm_size;
        sy = hm_y0 + spk_y[spk_idx] * hm_size;
        e = energy[spk_idx] * sensitivity;
        e = min(e, 1.0);
        
        ring = 0;
        loop(4,
          base_r = 12 + (e * 35);
          ring_r = base_r + ring * 10;
          opacity_ring = e * wave_rings_vis * pow(0.7, ring) * 1.5;
          opacity_ring = min(opacity_ring, 0.9);
          opacity_ring > 0.01 ? (
            gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, opacity_ring);
            gfx_circle(sx, sy, ring_r, 0);
          );
          ring += 1;
        );
        rear_spks += 1;
      );
    );

    // --- SPEAKER ICONS AND LABELS (drawn AFTER mask) ---
    s = 0;
    loop(NUM_SPEAKERS,
      sx = hm_x0 + spk_x[s] * hm_size;
      sy = hm_y0 + spk_y[s] * hm_size;

      // Speaker dot (20% bigger)
      gfx_set(0.85, 0.85, 0.85, 0.9);
      gfx_circle(sx, sy, 4.8 * sc, 1);
      // Dot border
      gfx_set(acc_r, acc_g, acc_b, 0.7);
      gfx_circle(sx, sy, 4.8 * sc, 0);

      // Label
      gfx_setfont(2);
      gfx_set(1.0, 1.0, 1.0, 0.85);
      s == 0 ? ( gfx_x = sx - 18 * sc; gfx_y = sy - 18 * sc; gfx_drawstr("L"); );
      s == 1 ? ( gfx_x = sx + 10 * sc;  gfx_y = sy - 18 * sc; gfx_drawstr("R"); );
      s == 2 ? ( gfx_x = sx - 3 * sc;  gfx_y = sy - 18 * sc; gfx_drawstr("C"); );
      s == 3 ? ( gfx_x = sx - 20 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("Ls"); );
      s == 4 ? ( gfx_x = sx + 8 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("Rs"); );

      s += 1;
    );

    // --- DIVERGENCE CIRCLES (expanding rings around speakers) ---
    s = 0;
    loop(NUM_SPEAKERS,
      s == 0 ? div_v = slider22 :   // L
      s == 1 ? div_v = slider23 :   // R
      s == 2 ? div_v = slider26 :   // C
      s == 3 ? div_v = slider27 :   // Ls
               div_v = slider28;    // Rs

      div_v > 0.005 ? (
        sx = hm_x0 + spk_x[s] * hm_size;
        sy = hm_y0 + spk_y[s] * hm_size;

        // Max radius = distance to nearest ITU-R neighbor (in pixels)
        s == 0 ? max_r = 0.181 * hm_size :   // L nearest = C
        s == 1 ? max_r = 0.181 * hm_size :   // R nearest = C
        s == 2 ? max_r = 0.181 * hm_size :   // C nearest = L/R
        s == 3 ? max_r = 0.450 * hm_size :   // Ls nearest = L
                 max_r = 0.450 * hm_size;    // Rs nearest = R

        r = div_v * max_r;

        // Semi-transparent cyan fill
        gfx_set(0.0, 0.7, 0.9, 0.06 + div_v * 0.08);
        gfx_circle(sx, sy, r, 1);

        // Cyan outline ring
        gfx_set(0.0, 0.7, 0.9, 0.3 + div_v * 0.4);
        gfx_circle(sx, sy, r, 0);
      );

      s += 1;
    );

    // --- ROOM OUTLINE ---
    gfx_set(brd_r, brd_g, brd_b, 0.6);

    // ITU-R BS.775 circle (radius 0.35 from center)
    circle_cx = hm_x0 + hm_size * 0.5;
    circle_cy = hm_y0 + hm_size * 0.5;
    circle_r = hm_size * 0.35;
    gfx_circle(circle_cx, circle_cy, circle_r, 0);

    // --- GRID ---
    show_grid ? (
      lx = hm_x0 + listen_x * hm_size;
      ly = hm_y0 + listen_y * hm_size;
      gfx_set(brd_r, brd_g, brd_b, 0.15);
      gfx_line(lx, hm_y0, lx, hm_y0 + hm_size);
      gfx_line(hm_x0, ly, hm_x0 + hm_size, ly);
      gfx_set(brd_r, brd_g, brd_b, 0.10);
      gfx_circle(lx, ly, hm_size * 0.15, 0);
      gfx_circle(lx, ly, hm_size * 0.30, 0);
    );

    // --- HEAT MAP LEGEND (LEFT) ---
    legend_pad = max(4, (6 * sc)|0);
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(legend_x0, legend_y0, legend_w, legend_h);
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    gfx_line(legend_x0, legend_y0, legend_x0 + legend_w, legend_y0);
    gfx_line(legend_x0, legend_y0 + legend_h, legend_x0 + legend_w, legend_y0 + legend_h);
    gfx_line(legend_x0, legend_y0, legend_x0, legend_y0 + legend_h);
    gfx_line(legend_x0 + legend_w, legend_y0, legend_x0 + legend_w, legend_y0 + legend_h);

    steps = 48;
    j = 0;
    loop(steps,
      v = j / (steps - 1);
      get_color(v, color_scheme, cr, cg, cb);
      // Legend shows full saturation colors (independent of brightness slider)
      gfx_set(cr, cg, cb, 1.0);
      ly = legend_y0 + (1.0 - v) * legend_h;
      gfx_rect(legend_x0 + legend_pad, ly, legend_w - legend_pad * 2, (legend_h / steps) + 1);
      j += 1;
    );

    // --- LRA RANGE INDICATOR ON LEGEND ---
    heatmap_peak_hold[0] > 0.001 && heatmap_min_hold[0] < 0.999 ? (
      peak_y = legend_y0 + (1.0 - heatmap_peak_hold[0]) * legend_h;
      min_y = legend_y0 + (1.0 - heatmap_min_hold[0]) * legend_h;
      range_h = min_y - peak_y;
      
      // Draw semi-transparent filled rectangle for LRA range (very light, barely visible)
      gfx_set(1.0, 1.0, 1.0, 0.08);
      gfx_rect(legend_x0, peak_y, legend_w, range_h);
      
      // Draw border lines
      gfx_set(1.0, 1.0, 1.0, 0.8);
      gfx_line(legend_x0, peak_y, legend_x0 + legend_w, peak_y);
      gfx_line(legend_x0, min_y, legend_x0 + legend_w, min_y);
      
      // Draw small triangular markers on right edge
      gfx_triangle(legend_x0 + legend_w, peak_y,
                   legend_x0 + legend_w + 4, peak_y - 3,
                   legend_x0 + legend_w + 4, peak_y + 3);
      gfx_triangle(legend_x0 + legend_w, min_y,
                   legend_x0 + legend_w + 4, min_y - 3,
                   legend_x0 + legend_w + 4, min_y + 3);
      
      // Display LRA value (range in percentage)
      lra_val = (heatmap_peak_hold[0] - heatmap_min_hold[0]) * 100;
      sprintf(#lra_str, "%.0f%%", lra_val);
      gfx_setfont(3);
      gfx_set(1.0, 1.0, 1.0, 0.9);
      gfx_measurestr(#lra_str, lw, lh);
      gfx_x = legend_x0 + legend_w + 8;
      gfx_y = peak_y + (range_h - lh) * 0.5;
      gfx_drawstr(#lra_str);
    );

    // Legend scale labels (dynamic for scale mode)
    gfx_setfont(3);
    floor_db = heatmap_lock_floor > 0.5 ? -60.0 : -120.0;
    step_db = floor_db / 4.0;
    k = 0;
    loop(5,
      label_db = k * step_db;
      k == 0 ? (
        #label_str = "0";
      ) : (
        sprintf(#label_str, "%d", label_db | 0);
      );
      label_y = legend_y0 + (k / 4.0) * legend_h;
      gfx_measurestr(#label_str, lw, lh);
      label_x = legend_x0 + (legend_w - lw) * 0.5;
      // Dark shadow for better contrast on bright colors
      gfx_set(0.1, 0.1, 0.1, 0.9);
      gfx_x = label_x + 1; gfx_y = label_y - lh * 0.5 + 1;
      gfx_drawstr(#label_str);
      // Main text (light)
      gfx_set(txt_r, txt_g, txt_b, 1.0);
      gfx_x = label_x; gfx_y = label_y - lh * 0.5;
      gfx_drawstr(#label_str);
      k += 1;
    );
    
    // Note: LEVELS panel moved to universal section (always visible)
    // Legend complete

    // Listener position
    lx = hm_x0 + listen_x * hm_size;
    ly = hm_y0 + listen_y * hm_size;
    
    // Listener circle (grey dot)
    gfx_set(0.5, 0.5, 0.5, 0.35);
    gfx_circle(lx, ly, 3 * sc, 1);
    gfx_set(0.5, 0.5, 0.5, 0.2);
    gfx_circle(lx, ly, 3 * sc, 0);
    
    // Dragging interaction area (hint circle - shows when hovering)
    mouse_dx = mouse_x - lx;
    mouse_dy = mouse_y - ly;
    mouse_dist = sqrt(mouse_dx * mouse_dx + mouse_dy * mouse_dy);
    drag_radius = max(25, (30 * sc)|0);
    
    mouse_dist < drag_radius ? (
      gfx_set(0.8, 0.6, 0.2, 0.15);
      gfx_circle(lx, ly, drag_radius, 1);
      gfx_set(0.8, 0.6, 0.2, 0.3);
      gfx_circle(lx, ly, drag_radius, 0);
    );
    
    // Listener rotation arrow (pointing to center channel direction)
    // LARGER DRAGGABLE ARROW for better visibility and interaction
    // Range -180° to +180° (0° = up to center, +90° = right, -90° = left)
    // Drag with LMB or RMB to reset to 0°
    arrow_len = max(20, (24 * sc)|0);  // Larger arrow for better visibility
    arrow_angle = -listener_rotation + $pi * 0.5;  // +90° offset so 0° points up (INVERTED)
    arrow_x = lx + arrow_len * cos(arrow_angle);
    arrow_y = ly - arrow_len * sin(arrow_angle);  // Y inverted for screen coords
    
    // Arrow color - brighter when dragging
    dragging_listener ? (
      gfx_set(1.0, 0.8, 0.3, 1.0);
    ) : (
      gfx_set(0.8, 0.6, 0.2, 0.85);
    );
    gfx_line(lx, ly, arrow_x, arrow_y);
    
    // Arrow head (two small lines) 
    arrow_head_len = max(6, (8 * sc)|0);  // Larger arrow head
    arrow_back_angle1 = arrow_angle + 2.88;  // ~165 degrees
    arrow_back_angle2 = arrow_angle - 2.88;  // ~-165 degrees
    gfx_line(arrow_x, arrow_y, 
             arrow_x + arrow_head_len * cos(arrow_back_angle1), 
             arrow_y - arrow_head_len * sin(arrow_back_angle1));
    gfx_line(arrow_x, arrow_y, 
             arrow_x + arrow_head_len * cos(arrow_back_angle2), 
             arrow_y - arrow_head_len * sin(arrow_back_angle2));
    
    // Draggable listener rotation control
    // Start dragging on mouse down (only if UI buttons not clicked)
    !mouse_clicked_ui ? (
      // RIGHT CLICK - Reset rotation to 0 degrees
      mouse_cap & 2 && !(last_mouse_cap & 2) ? (
        slider1 = 0;
        listener_rotation = 0;
        sliderchange(slider1);
      );
      
      // LEFT CLICK - Drag to rotate
      mouse_cap & 1 ? (
        !dragging_listener && mouse_dist < drag_radius ? (
          dragging_listener = 1;
        );
        
        // Update rotation while dragging (INSIDE mouse_cap block!)
        dragging_listener ? (
          // Calculate angle from listener center to mouse
          mouse_angle = atan2(-(mouse_y - ly), mouse_x - lx);  // Y inverted, atan2(y, x)
          // Remove the +90° offset to get actual rotation (INVERTED)
          actual_rotation = -(mouse_angle - $pi * 0.5);
          // Convert to degrees
          slider1 = (actual_rotation * (180.0 / $pi)) / slider20;
          // Normalize to -180 to +180 range
          slider1 > 180 ? slider1 -= 360;
          slider1 < -180 ? slider1 += 360;
          // Update listener_rotation directly (same as @slider)
          listener_rotation = slider1 * slider20 * ($pi / 180.0);
          sliderchange(slider1);
        );
      ) : (
        // Stop dragging on mouse up
        dragging_listener = 0;
      );
    );
  );

  // =====================================================
  // GONIOMETER (Display Mode 1 or 2)
  // =====================================================
  display_mode == 1 ? (

    // Center goniometer with a left correlation column (same width as heat map legend)
    corr_w = legend_w;
    corr_gap = legend_gap;
    available_w = field_w - meter_panel_gap - meter_panel_w - corr_w - corr_gap;
    available_h = field_h;
    gon_size = min(available_w, available_h);
    gon_size = max(100, gon_size);
    // Center horizontally and vertically in the space left of the panel
    gon_x0 = field_left + corr_w + corr_gap + (available_w - gon_size) * 0.5;
    gon_y0 = field_top + (available_h - gon_size) * 0.5;

    // Decay goniometer buffer
    gfx_dest = GONIO_BUFFER;
    gon_dec = decay_factor * 0.98; // slightly faster decay for gonio
    gfx_muladdrect(0, 0, 256, 256,
      gon_dec, gon_dec, gon_dec, 1.0,
      0, 0, 0, 0
    );

    // Draw new samples
    gfx_mode = 1; // additive
    gw_cur = gonio_write[0];
    // Draw last N samples (skip some for performance)
    draw_count = min(GONIO_SIZE, (srate / 30)|0); // ~1 frame worth of samples
    idx = gw_cur - draw_count;
    idx < 0 ? idx += GONIO_SIZE;

    i = 0;
    loop(draw_count,
      gl = GONIO_BUF[idx * 2];
      gr = GONIO_BUF[idx * 2 + 1];

      // Mid/Side transform rotated 45 degrees
      gm = (gl + gr) * 0.707;
      gs = (gl - gr) * 0.707;

      // Map to buffer coordinates (center = 128, 128)
      // Separate goniometer sensitivity (decoupled from heat map sensitivity)
      gonio_sensitivity = gonio_sensitivity_user * 2.0;  // base scale
      gs_scaled = (gs * gonio_sensitivity) / (1.0 + abs(gs * gonio_sensitivity));
      gm_scaled = (gm * gonio_sensitivity) / (1.0 + abs(gm * gonio_sensitivity));
      gon_px = 128 + gs_scaled * 127.0;
      gon_py = 128 - gm_scaled * 127.0;
      gon_px = max(0, min(255, gon_px));
      gon_py = max(0, min(255, gon_py));

      // Draw dot
      gfx_x = gon_px;
      gfx_y = gon_py;
      amp = max(abs(gl), abs(gr)) * gonio_sensitivity_user;
      amp = min(amp, 1.0);
      gfx_setpixel(acc_r * amp * 0.8, acc_g * amp * 0.8, acc_b * amp * 0.4);

      idx += 1;
      idx >= GONIO_SIZE ? idx = 0;
      i += 1;
    );

    gfx_mode = 0;
    gfx_dest = -1;

    // Background
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(gon_x0, gon_y0, gon_size, gon_size);

    // Blit
    gfx_blit(GONIO_BUFFER, 1, 0,
      0, 0, 256, 256,
      gon_x0, gon_y0, gon_size, gon_size
    );

    // Reference lines: +45 and -45 degrees (L and R axes)
    gon_cx = gon_x0 + gon_size * 0.5;
    gon_cy = gon_y0 + gon_size * 0.5;
    gfx_set(1.0, 1.0, 1.0, 0.12);
    // Diagonal L axis
    gfx_line(gon_x0, gon_y0, gon_x0 + gon_size, gon_y0 + gon_size);
    // Diagonal R axis
    gfx_line(gon_x0 + gon_size, gon_y0, gon_x0, gon_y0 + gon_size);
    // Crosshair
    gfx_set(1.0, 1.0, 1.0, 0.08);
    gfx_line(gon_cx, gon_y0, gon_cx, gon_y0 + gon_size);
    gfx_line(gon_x0, gon_cy, gon_x0 + gon_size, gon_cy);

    // Labels - dynamic based on selected pair
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.5);
    
    // Get channel names for current pair
    gonio_pair == 0 ? (#ch1_name = "L"; #ch2_name = "R";) :     // L-R
    gonio_pair == 1 ? (#ch1_name = "L"; #ch2_name = "C";) :     // L-C
    gonio_pair == 2 ? (#ch1_name = "L"; #ch2_name = "Ls";) :    // L-Ls
    gonio_pair == 3 ? (#ch1_name = "L"; #ch2_name = "Rs";) :    // L-Rs
    gonio_pair == 4 ? (#ch1_name = "R"; #ch2_name = "C";) :     // R-C
    gonio_pair == 5 ? (#ch1_name = "R"; #ch2_name = "Ls";) :    // R-Ls
    gonio_pair == 6 ? (#ch1_name = "R"; #ch2_name = "Rs";) :    // R-Rs
    gonio_pair == 7 ? (#ch1_name = "C"; #ch2_name = "Ls";) :    // C-Ls
    gonio_pair == 8 ? (#ch1_name = "C"; #ch2_name = "Rs";) :    // C-Rs
                      (#ch1_name = "Ls"; #ch2_name = "Rs";);    // Ls-Rs
    
    gfx_x = gon_x0 + 2; gfx_y = gon_y0 + 2;
    gfx_drawstr(#ch1_name);
    gfx_measurestr(#ch2_name, lw, lh);
    gfx_x = gon_x0 + gon_size - lw - 2; gfx_y = gon_y0 + 2;
    gfx_drawstr(#ch2_name);
    gfx_x = gon_cx - 3; gfx_y = gon_y0 + 2;
    gfx_drawstr("M");
    gfx_x = gon_cx - 3; gfx_y = gon_y0 + gon_size - 14;
    gfx_drawstr("S");
    
    // Show phase correlation for selected pair
    corr_val = phase_smooth[gonio_pair];
    gfx_setfont(2);
    corr_val >= 0 ? gfx_set(0.3, 0.9, 0.4, 0.9) : gfx_set(0.9, 0.3, 0.2, 0.9);
    sprintf(#corr_str, "φ %.2f", corr_val);
    gfx_measurestr(#corr_str, cw, ch);
    gfx_x = gon_x0 + gon_size - cw - 4;
    gfx_y = gon_y0 + gon_size - ch - 4;
    gfx_drawstr(#corr_str);

    // Left vertical correlation column (aligns with heat map legend width)
    corr_x0 = field_left;
    corr_y0 = gon_y0;
    corr_h = gon_size;
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(corr_x0, corr_y0, corr_w, corr_h);
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    gfx_line(corr_x0, corr_y0, corr_x0 + corr_w, corr_y0);
    gfx_line(corr_x0, corr_y0 + corr_h, corr_x0 + corr_w, corr_y0 + corr_h);
    gfx_line(corr_x0, corr_y0, corr_x0, corr_y0 + corr_h);
    gfx_line(corr_x0 + corr_w, corr_y0, corr_x0 + corr_w, corr_y0 + corr_h);

    // Center line
    corr_cy = corr_y0 + corr_h * 0.5;
    gfx_set(0.35, 0.35, 0.35, 0.5);
    gfx_line(corr_x0 + 2, corr_cy, corr_x0 + corr_w - 2, corr_cy);

    // Correlation fill
    corr_val > 0 ? (
      corr_fill_h = corr_val * corr_h * 0.5;
      gfx_set(0.14, 0.62, 0.32, 0.85);
      gfx_rect(corr_x0 + 2, corr_cy - corr_fill_h, corr_w - 4, corr_fill_h);
    ) : (
      corr_fill_h = abs(corr_val) * corr_h * 0.5;
      gfx_set(0.90, 0.15, 0.10, 0.85);
      gfx_rect(corr_x0 + 2, corr_cy, corr_w - 4, corr_fill_h);
    );

    // Labels
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.6);
    gfx_measurestr("+1", lw, lh);
    gfx_x = corr_x0 + (corr_w - lw) * 0.5;
    gfx_y = corr_y0 - lh * 0.5;
    gfx_drawstr("+1");
    gfx_measurestr("-1", lw, lh);
    gfx_x = corr_x0 + (corr_w - lw) * 0.5;
    gfx_y = corr_y0 + corr_h - lh * 0.5;
    gfx_drawstr("-1");

  );

  // =====================================================
  // 5.1 SURROUND GONIOMETER (Display Mode 3)
  // =====================================================
  (display_mode == 3) ? (

    surr_size = field_size;
    surr_x0 = field_x0;
    surr_y0 = field_y0;

    // Background
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(surr_x0, surr_y0, surr_size, surr_size);

    // Room outline
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    // ITU-R BS.775 circle (radius 0.35 from center)
    circle_cx = surr_x0 + surr_size * 0.5;
    circle_cy = surr_y0 + surr_size * 0.5;
    circle_r = surr_size * 0.35;
    gfx_circle(circle_cx, circle_cy, circle_r, 0);

    // Draw large energy blobs for each channel at speaker positions
    s = 0;
    loop(NUM_SPEAKERS,
      sx = surr_x0 + spk_x[s] * surr_size;
      sy = surr_y0 + spk_y[s] * surr_size;

      // Channel-specific colors
      s == 0 ? (cr = 0.8; cg = 0.3; cb = 0.3;);  // L: red
      s == 1 ? (cr = 0.3; cg = 0.3; cb = 0.8;);  // R: blue
      s == 2 ? (cr = 0.3; cg = 0.8; cb = 0.3;);  // C: green
      s == 3 ? (cr = 0.9; cg = 0.6; cb = 0.2;);  // Ls: orange
      s == 4 ? (cr = 0.6; cg = 0.2; cb = 0.8;);  // Rs: purple

      // Use smoothed energy per speaker (same as heat map mode)
      e = energy[s] * sensitivity * 5.0;
      e = min(e, 1.0);
      
      // Proportional blob size (4..48px radius)
      blob_r = 4 + e * 44;

      // Outer glow (very soft, low opacity)
      gfx_set(cr * e, cg * e, cb * e, e * 0.25);
      gfx_circle(sx, sy, blob_r * 1.8, 1);
      
      // Mid glow (brighter)
      gfx_set(cr * e, cg * e, cb * e, e * 0.55);
      gfx_circle(sx, sy, blob_r, 1);
      
      // Inner core (brightest)
      gfx_set(cr, cg, cb, e * 0.85);
      gfx_circle(sx, sy, blob_r * 0.5, 1);

      // Speaker dot (always visible, 20% bigger)
      gfx_set(0.95, 0.95, 0.95, 0.95);
      gfx_circle(sx, sy, 6 * sc, 1);
      gfx_set(cr, cg, cb, 0.8);
      gfx_circle(sx, sy, 6 * sc, 0);

      // Label
      gfx_setfont(2);
      gfx_set(1.0, 1.0, 1.0, 0.9);
      s == 0 ? ( gfx_x = sx - 18 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("L"); );
      s == 1 ? ( gfx_x = sx + 10 * sc;  gfx_y = sy + 10 * sc; gfx_drawstr("R"); );
      s == 2 ? ( gfx_x = sx - 4 * sc;   gfx_y = sy + 12 * sc; gfx_drawstr("C"); );
      s == 3 ? ( gfx_x = sx + 12 * sc;  gfx_y = sy - 8 * sc; gfx_drawstr("Ls"); );
      s == 4 ? ( gfx_x = sx - 24 * sc;  gfx_y = sy - 8 * sc; gfx_drawstr("Rs"); );

      s += 1;
    );

  );


  // =====================================================
  // LEVELS METER PANEL (Always visible in all display modes)
  // =====================================================
  // Position meters at right side for all modes
  panel_w = meter_panel_w;
  panel_h = phase_top - field_top - pad;
  panel_x0 = gfx_w - pad - panel_w;
  panel_y0 = field_top + pad;

  panel_pad = max(4, (6 * sc)|0);
  bar_gap = max(4, (6 * sc)|0);
  scale_w = max(20, (24 * sc)|0);

  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(panel_x0, panel_y0, panel_w, panel_h);
  gfx_set(brd_r, brd_g, brd_b, 0.6);
  gfx_line(panel_x0, panel_y0, panel_x0 + panel_w, panel_y0);
  gfx_line(panel_x0, panel_y0 + panel_h, panel_x0 + panel_w, panel_y0 + panel_h);
  gfx_line(panel_x0, panel_y0, panel_x0, panel_y0 + panel_h);
  gfx_line(panel_x0 + panel_w, panel_y0, panel_x0 + panel_w, panel_y0 + panel_h);

  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = panel_x0 + panel_pad;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr("LEVELS");
  meter_mode == 0 ? #mode_lbl = "PEAK" : #mode_lbl = "RMS";
  gfx_measurestr(#mode_lbl, mw, mh);
  gfx_x = panel_x0 + panel_w - panel_pad - mw;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr(#mode_lbl);

  left_scale_w = max(10, (12 * sc)|0);
  meter_area_w = panel_w - panel_pad * 2 - scale_w - left_scale_w;
  bar_w = (meter_area_w - bar_gap * 4) / 5;
  bar_w < 4 ? bar_w = 4;
  label_y = panel_y0 + panel_pad + font_sm + 20 * sc;
  value_y = label_y + font_sm + 4 * sc;
  bar_top = value_y + font_sm + 6 * sc;
  
  // Calculate LUFS block size early
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_calc = panel_y0 + panel_h - panel_pad - lufs_block_h;

  // Vertical divergence sliders (taller than old horizontal bars)
  div_v_h = max(30, (40 * sc)|0);
  div_gap = max(2, (3 * sc)|0);

  // Mute toggle squares
  mute_sq_size = max(14, (18 * sc)|0);
  mute_gap = max(2, (3 * sc)|0);

  // Subtract divergence + mute from bar height
  bar_h = lufs_y0_calc - bar_top - panel_pad - div_v_h - div_gap - mute_sq_size - mute_gap;
  bar_h < 30 ? bar_h = 30;
  scale_span = 60.0;
  center_y = bar_top + bar_h * 0.5;
  meter_x0 = panel_x0 + panel_pad + left_scale_w;

  // Target reference line centered (meters only)
  gfx_set(0.70, 0.90, 0.25, 0.55);
  gfx_line(meter_x0, center_y, meter_x0 + meter_area_w, center_y);

  // Left-side reference and 0 dB markers
  zero_y = center_y - (0 - target_level) / scale_span * bar_h;
  zero_y = min(bar_top + bar_h, max(bar_top, zero_y));
  gfx_set(0.55, 0.55, 0.55, 0.6);
  gfx_line(panel_x0 + panel_pad, zero_y, meter_x0 - 2, zero_y);
  sprintf(#zero_str, "%d", 0);
  gfx_setfont(3);
  gfx_measurestr(#zero_str, zw, zh);
  gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
  gfx_rect(panel_x0 + 1, zero_y - zh * 0.5, zw + 2, zh + 2);
  gfx_set(txt_r, txt_g, txt_b, 0.8);
  gfx_x = panel_x0 + 2;
  gfx_y = zero_y - zh * 0.5;
  gfx_drawstr(#zero_str);

  gfx_set(0.30, 0.90, 0.30, 0.85);
  gfx_line(panel_x0 + panel_pad, center_y, meter_x0 - 2, center_y);
  sprintf(#ref_str, "%d", target_level);
  gfx_setfont(2);
  gfx_measurestr(#ref_str, rw, rh);
  gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
  gfx_rect(panel_x0 + 1, center_y - rh * 0.5, rw + 2, rh + 2);
  gfx_set(0.30, 0.90, 0.30, 0.9);
  gfx_x = panel_x0 + 2;
  gfx_y = center_y - rh * 0.5;
  gfx_drawstr(#ref_str);
  gfx_setfont(3);

  // Read mute mask for visual feedback
  mute_mask = slider21;

  // Divergence slider geometry (vertical, below each meter bar)
  div_y = bar_top + bar_h + div_gap;
  div_bar_h = div_v_h;

  // Mute square geometry (below divergence sliders)
  mute_y = div_y + div_v_h + mute_gap;

  i = 0;
  loop(5,
    sp_idx = i == 0 ? 3 : i == 1 ? 0 : i == 2 ? 2 : i == 3 ? 1 : 4;
    i == 0 ? #lbl = "Ls" : i == 1 ? #lbl = "L" : i == 2 ? #lbl = "C" : i == 3 ? #lbl = "R" : #lbl = "Rs";
    bx = meter_x0 + i * (bar_w + bar_gap);

    // Determine mute state for this channel
    i == 0 ? mute_bit = 16 :    // Ls
    i == 1 ? mute_bit = 1 :     // L
    i == 2 ? mute_bit = 4 :     // C
    i == 3 ? mute_bit = 2 :     // R
             mute_bit = 32;     // Rs
    is_muted = (mute_mask & mute_bit) > 0;

    // Channel label (always normal color - mute shown by square below)
    gfx_setfont(3);
    gfx_measurestr(#lbl, lw, lh);
    gfx_set(txt_r, txt_g, txt_b, 0.7);
    gfx_x = bx + (bar_w - lw) * 0.5;
    gfx_y = label_y - lh - 2 * sc;
    gfx_drawstr(#lbl);

    // Bar background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx, bar_top, bar_w, bar_h);

    // Meter level
    meter_mode == 0 ? (
      lvl = peak_level[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    ) : (
      lvl = rms_disp[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    );

    lvl_y = center_y - (lvl_db - target_level) / scale_span * bar_h;
    lvl_y = min(bar_top + bar_h, max(bar_top, lvl_y));

    is_muted ? (
      // Muted: dim gray bar
      gfx_set(0.3, 0.3, 0.35, 0.3);
      gfx_rect(bx, lvl_y, bar_w, (bar_top + bar_h) - lvl_y);
    ) : (
      // Normal: colored bar
      lvl_db > -6 ? (
        gfx_set(0.90, 0.20, 0.15, 0.9);
      ) : lvl_db > -18 ? (
        gfx_set(0.90, 0.80, 0.10, 0.9);
      ) : (
        gfx_set(mtr_r, mtr_g, mtr_b, 0.9);
      );
      gfx_rect(bx, lvl_y, bar_w, (bar_top + bar_h) - lvl_y);
    );

    // dB value display
    gfx_set(txt_r, txt_g, txt_b, 0.6);
    gfx_setfont(3);
    lvl_db > -99 ? (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawnumber(lvl_db, 1);
    ) : (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawstr("-inf");
    );

    // Peak hold (skip visual for muted channels)
    cur_pk = meter_mode == 0 ? peak_level[sp_idx] : rms_level[sp_idx];
    cur_pk > peak_hold[sp_idx] ? (
      peak_hold[sp_idx] = cur_pk;
      peak_hold_tm[sp_idx] = PEAK_HOLD_FRAMES;
    ) : (
      peak_hold_tm[sp_idx] > 0 ? (
        peak_hold_tm[sp_idx] -= 1;
      ) : (
        peak_hold[sp_idx] *= PEAK_DECAY;
      );
    );
    !is_muted ? (
      hold_db = peak_hold[sp_idx] > 0.00001 ? 20.0 * log10(peak_hold[sp_idx]) : -120.0;
      hold_y = center_y - (hold_db - target_level) / scale_span * bar_h;
      hold_y = min(bar_top + bar_h, max(bar_top, hold_y));
      gfx_set(1.0, 1.0, 1.0, 0.6);
      gfx_line(bx, hold_y, bx + bar_w, hold_y);
    );

    // === VERTICAL DIVERGENCE SLIDER (below meter bar) ===
    i == 0 ? div_val = slider27 :  // Ls
    i == 1 ? div_val = slider22 :  // L
    i == 2 ? div_val = slider26 :  // C
    i == 3 ? div_val = slider23 :  // R
             div_val = slider28;   // Rs

    // Background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx, div_y, bar_w, div_bar_h);

    // Cyan fill from bottom upward (proportional to divergence)
    div_val > 0.005 ? (
      fill_h = div_bar_h * div_val;
      gfx_set(0.0, 0.7, 0.9, 0.8);
      gfx_rect(bx, div_y + div_bar_h - fill_h, bar_w, fill_h);
    );

    // Percentage text (centered in slider)
    div_val > 0.01 ? (
      gfx_setfont(3);
      sprintf(#div_str, "%.0f", div_val * 100);
      gfx_set(txt_r, txt_g, txt_b, 0.6);
      gfx_measurestr(#div_str, dw, dh);
      gfx_x = bx + (bar_w - dw) * 0.5;
      gfx_y = div_y + (div_bar_h - dh) * 0.5;
      gfx_drawstr(#div_str);
    );

    // === MUTE TOGGLE SQUARE (below divergence slider) ===
    mute_sq_x = bx + (bar_w - mute_sq_size) * 0.5;

    is_muted ? (
      // Filled red square
      gfx_set(0.9, 0.25, 0.2, 0.9);
      gfx_rect(mute_sq_x, mute_y, mute_sq_size, mute_sq_size);
      // White "M" text
      gfx_set(1, 1, 1, 1);
    ) : (
      // Outlined dim square
      gfx_set(0.4, 0.4, 0.45, 0.5);
      gfx_rect(mute_sq_x, mute_y, mute_sq_size, mute_sq_size);
      gfx_set(0.15, 0.15, 0.17, 1);
      gfx_rect(mute_sq_x + 1, mute_y + 1, mute_sq_size - 2, mute_sq_size - 2);
      // Dim "M" text
      gfx_set(0.5, 0.5, 0.5, 0.4);
    );
    gfx_setfont(3);
    gfx_measurestr("M", mw_m, mh_m);
    gfx_x = mute_sq_x + (mute_sq_size - mw_m) * 0.5;
    gfx_y = mute_y + (mute_sq_size - mh_m) * 0.5;
    gfx_drawstr("M");

    // === MOUSE INTERACTION ===
    // Mute toggle (click on square)
    mouse_cap == 1 && last_mouse_cap == 0 && !mouse_clicked_ui ? (
      mouse_x >= mute_sq_x && mouse_x <= mute_sq_x + mute_sq_size &&
      mouse_y >= mute_y && mouse_y <= mute_y + mute_sq_size ? (
        // Toggle mute bit
        (slider21 & mute_bit) ? (
          slider21 = slider21 - mute_bit;
        ) : (
          slider21 = slider21 | mute_bit;
        );
        sliderchange(slider21);
        mouse_clicked_ui = 1;
      );
    );

    // Divergence vertical drag (hold mouse on divergence slider)
    mouse_cap == 1 && !mouse_clicked_ui ? (
      mouse_x >= bx && mouse_x <= bx + bar_w &&
      mouse_y >= div_y && mouse_y <= div_y + div_bar_h ? (
        new_div = max(0, min(1, 1.0 - (mouse_y - div_y) / div_bar_h));
        i == 0 ? (slider27 = new_div; sliderchange(slider27)) :
        i == 1 ? (slider22 = new_div; sliderchange(slider22)) :
        i == 2 ? (slider26 = new_div; sliderchange(slider26)) :
        i == 3 ? (slider23 = new_div; sliderchange(slider23)) :
                 (slider28 = new_div; sliderchange(slider28));
        mouse_clicked_ui = 1;
      );
    );

    // Right-click reset divergence
    mouse_cap & 2 && !(last_mouse_cap & 2) ? (
      mouse_x >= bx && mouse_x <= bx + bar_w &&
      mouse_y >= div_y && mouse_y <= div_y + div_bar_h ? (
        i == 0 ? (slider27 = 0; sliderchange(slider27)) :
        i == 1 ? (slider22 = 0; sliderchange(slider22)) :
        i == 2 ? (slider26 = 0; sliderchange(slider26)) :
        i == 3 ? (slider23 = 0; sliderchange(slider23)) :
                 (slider28 = 0; sliderchange(slider28));
      );
    );

    i += 1;
  );

  // dB scale on the right side of the meter panel (relative to target level)
  scale_x = panel_x0 + panel_w - panel_pad - scale_w;
  gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_line(scale_x, bar_top, scale_x + scale_w, bar_top);
  gfx_line(scale_x, bar_top + bar_h, scale_x + scale_w, bar_top + bar_h);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_setfont(3);
  db_step = 6;
  db_span = 30;
  db_mark = 0;
  loop(11,
    offset_db = db_span - db_mark * db_step;
    ref_db = target_level + offset_db;
    db_y = center_y - (offset_db / scale_span) * bar_h;
    db_y >= bar_top && db_y <= (bar_top + bar_h) ? (
      gfx_set(brd_r, brd_g, brd_b, 0.3);
      gfx_line(meter_x0, db_y, scale_x - 2, db_y);
      sprintf(#step_str, "%d", ref_db);
      gfx_setfont(3);
      gfx_measurestr(#step_str, sw, sh);
      gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
      gfx_rect(scale_x + 1, db_y - sh * 0.5, sw + 2, sh + 2);
      gfx_set(txt_r, txt_g, txt_b, 0.6);
      gfx_x = scale_x + 2;
      gfx_y = db_y - sh * 0.5;
      gfx_drawstr(#step_str);
    );
    db_mark += 1;
  );

  // LUFS block - more prominent display
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_new = panel_y0 + panel_h - panel_pad - lufs_block_h;
  
  gfx_set(0.08, 0.08, 0.10, 0.95);
  gfx_rect(panel_x0 + panel_pad, lufs_y0_new, panel_w - panel_pad * 2, lufs_block_h);
  gfx_set(acc_r, acc_g, acc_b, 0.6);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new, panel_x0 + panel_w - panel_pad, lufs_y0_new);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new + lufs_block_h, panel_x0 + panel_w - panel_pad, lufs_y0_new + lufs_block_h);
  
  gfx_setfont(2);
  lufs_row_h_new = lufs_block_h / 3;
  lufs_label_x_new = panel_x0 + panel_pad + 6;
  lufs_val_x_new = panel_x0 + panel_w - panel_pad - 6;

  // LUFS-I (Integrated) - most important, at top
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 0 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  gfx_drawstr("LUFS-I");
  gfx_measurestr(lufs_int_disp > -99 ? sprintf(#tmp, "%.1f", lufs_int_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  lufs_int_disp > -99 ? gfx_drawnumber(lufs_int_disp, 1) : gfx_drawstr("-inf");

  // LUFS-S (Short-term) - middle
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 1 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.90, 0.90, 0.20, 0.95);
  gfx_drawstr("LUFS-S");
  gfx_measurestr(lufs_short_disp > -99 ? sprintf(#tmp, "%.1f", lufs_short_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.95, 0.95, 0.95, 1.0);
  lufs_short_disp > -99 ? gfx_drawnumber(lufs_short_disp, 1) : gfx_drawstr("-inf");

  // LUFS-M (Momentary) - bottom, fastest
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 2 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.70, 0.70, 0.70, 0.90);
  gfx_drawstr("LUFS-M");
  gfx_measurestr(lufs_mom_disp > -99 ? sprintf(#tmp, "%.1f", lufs_mom_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.85, 0.85, 0.85, 0.95);
  lufs_mom_disp > -99 ? gfx_drawnumber(lufs_mom_disp, 1) : gfx_drawstr("-inf");
  
  // Mouse click detection for LUFS reset
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    mouse_x >= panel_x0 + panel_pad && mouse_x <= panel_x0 + panel_w - panel_pad &&
    mouse_y >= lufs_y0_new && mouse_y <= lufs_y0_new + lufs_block_h ? (
      // Reset LUFS Integrated
      lufs_int = -120;
      lufs_int_disp = -120;
      lufs_m_db = -100;
      lufs_s_db = -100;
      lufs_i_db = -100;
      lufs_win_pos = 0;
      lufs_win_cnt = 0;
      lufs_win_acc = 0;
      lufs_cur_buf = 0;
      lufs_cur_buf2 = 0;
      lufs_m_sum = 0;
      lufs_s_sum = 0;
      lufs_a_sum = 0;
      lufs_a_sum_cnt = 0;
      lufs_i_sum = 0;
      lufs_i_cnt = 0;
      i = 0;
      loop(lufs_m_win_cnt,
        lufs_buf[i] = 0;
        i += 1;
      );
      i = 0;
      loop(lufs_s_win_cnt,
        lufs_buf2[i] = 0;
        i += 1;
      );
      i = 0;
      loop(NUM_BINS * 2,
        lufs_a_hist[i] = 0;
        i += 1;
      );
    );
  );

  // =====================================================
  // PHASE CORRELATION BARS
  // =====================================================
  // Panel background
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(pad, phase_top, gfx_w - pad * 2, phase_h);
  gfx_set(brd_r, brd_g, brd_b, 0.8);
  gfx_line(pad, phase_top, gfx_w - pad, phase_top);

  // Section label
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.4);
  label_x = pad + 4;
  label_y = phase_top + 3;
  gfx_x = label_x; gfx_y = label_y;
  gfx_drawstr("PHASE");
  
  // Hint for mouse interaction in goniometer mode
  display_mode == 1 ? (
    gfx_set(txt_r, txt_g, txt_b, 0.3);
    gfx_x = label_x; gfx_y = label_y + font_sm + 2;
    gfx_drawstr("(click to switch)");
  );

  // 10 correlation bars (all speaker pair combinations)
  bar_area_left = pad + 50 * sc;
  bar_area_right = gfx_w - pad - 4;
  bar_area_w = bar_area_right - bar_area_left;
  bar_w_each = bar_area_w / NUM_PHASE_PAIRS;
  bar_inner_h = phase_h - 20 * sc;
  bar_top = phase_top + 8 * sc;

  p = 0;
  loop(NUM_PHASE_PAIRS,
    bx = bar_area_left + p * bar_w_each;
    bar_inner_w = bar_w_each - 4 * sc;
    center_y = bar_top + bar_inner_h * 0.5;

    // Highlight selected pair (used in goniometer)
    p == gonio_pair && display_mode == 1 ? (
      gfx_set(acc_r, acc_g, acc_b, 0.3);
      gfx_rect(bx, bar_top - 2, bar_w_each, bar_inner_h + 4);
    );

    // Bar background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx + 2, bar_top, bar_inner_w, bar_inner_h);

    // Center line (zero)
    gfx_set(0.35, 0.35, 0.35, 0.5);
    gfx_line(bx + 2, center_y, bx + 2 + bar_inner_w, center_y);

    // +1 and -1 ticks
    gfx_set(0.25, 0.25, 0.25, 0.3);
    gfx_line(bx + 2, bar_top + 1, bx + 2 + bar_inner_w, bar_top + 1);
    gfx_line(bx + 2, bar_top + bar_inner_h - 1, bx + 2 + bar_inner_w, bar_top + bar_inner_h - 1);

    // Correlation value
    corr = phase_smooth[p];

    // Color: green (+1) -> yellow (0) -> red (-1)
    corr > 0.3 ? (
      pr = 0.14; pg = 0.62; pb = 0.32;
    ) : corr > 0 ? (
      t = corr / 0.3;
      pr = 0.90 * (1.0 - t) + 0.14 * t;
      pg = 0.75 * (1.0 - t) + 0.62 * t;
      pb = 0.10 * (1.0 - t) + 0.32 * t;
    ) : corr > -0.3 ? (
      t = (corr + 0.3) / 0.3;
      pr = 0.90;
      pg = 0.30 * t + 0.20 * (1.0 - t);
      pb = 0.10;
    ) : (
      pr = 0.90; pg = 0.15; pb = 0.10;
    );

    gfx_set(pr, pg, pb, 1.0);

    corr > 0 ? (
      bar_px = corr * bar_inner_h * 0.5;
      gfx_rect(bx + 4, center_y - bar_px, bar_inner_w - 4, bar_px);
    ) : (
      bar_px = abs(corr) * bar_inner_h * 0.5;
      gfx_rect(bx + 4, center_y, bar_inner_w - 4, bar_px);
    );

    // Correlation value text (numeric) - brighter with better contrast
    gfx_setfont(3);
    sprintf(#corr_val, "%.2f", corr);
    // Boost brightness: use max(color * 1.8, 1.0) for saturation
    pr_bright = min(1.0, pr * 1.8);
    pg_bright = min(1.0, pg * 1.8);
    pb_bright = min(1.0, pb * 1.8);
    // Increase alpha for better text visibility
    gfx_set(pr_bright, pg_bright, pb_bright, 1.0);
    gfx_measurestr(#corr_val, cw, ch);
    gfx_x = bx + (bar_w_each - cw) * 0.5;
    gfx_y = center_y - ch * 0.5;
    gfx_drawstr(#corr_val);
    
    // Pair label below
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.5);
    // Pair label below
    p == 0 ? ( #lbl = "L-R";   );
    p == 1 ? ( #lbl = "L-C";   );
    p == 2 ? ( #lbl = "L-Ls";  );
    p == 3 ? ( #lbl = "L-Rs";  );
    p == 4 ? ( #lbl = "R-C";   );
    p == 5 ? ( #lbl = "R-Ls";  );
    p == 6 ? ( #lbl = "R-Rs";  );
    p == 7 ? ( #lbl = "C-Ls";  );
    p == 8 ? ( #lbl = "C-Rs";  );
    p == 9 ? ( #lbl = "Ls-Rs"; );
    gfx_measurestr(#lbl, lw, lh);
    gfx_x = bx + (bar_w_each - lw) * 0.5;
    gfx_y = bar_top + bar_inner_h + 2;
    gfx_drawstr(#lbl);
    
    // Mouse click detection for switching goniometer pair
    mouse_cap == 1 && last_mouse_cap == 0 ? (
      mouse_x >= bx && mouse_x <= bx + bar_w_each &&
      mouse_y >= bar_top && mouse_y <= bar_top + bar_inner_h + lh + 4 ? (
        slider14 = p;
        gonio_pair = p;
        sliderchange(slider14);
      );
    );

    p += 1;
  );

  // =====================================================
  // LFE METER
  // =====================================================
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(pad, lfe_top, gfx_w - pad * 2, lfe_h);
  gfx_set(brd_r, brd_g, brd_b, 0.8);
  gfx_line(pad, lfe_top, gfx_w - pad, lfe_top);

  gfx_setfont(3);
  lfe_is_muted = (slider21 & 8) > 0;
  lfe_is_muted ? gfx_set(0.9, 0.25, 0.2, 1.0) : gfx_set(0.55, 0.40, 0.75, 0.8);
  gfx_x = pad + 4; gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  gfx_drawstr("LFE");
  lfe_is_muted ? (
    gfx_set(0.9, 0.25, 0.2, 0.8);
    gfx_drawstr(" M");
  );

  lfe_bar_x = pad + 36 * sc;
  lfe_bar_w = gfx_w - pad * 2 - 90 * sc;
  lfe_bar_h = max(8, lfe_h - 10 * sc);
  lfe_bar_y = lfe_top + (lfe_h - lfe_bar_h) * 0.5;

  // Background
  gfx_set(0.12, 0.12, 0.14, 0.7);
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_bar_w, lfe_bar_h);

  // Value
  meter_mode == 0 ? (
    lfe_val = lfe_peak[0];
  ) : (
    lfe_val = lfe_rms[0];
  );
  lfe_db = lfe_val > 0.00001 ? 20.0 * log10(lfe_val) : -60.0;
  lfe_norm = max(0.0, (lfe_db + 60.0) / 60.0);

  // LFE color: purple gradient
  lfe_norm < 0.6 ? (
    gfx_set(0.30, 0.20, 0.60, 0.85);
  ) : lfe_norm < 0.85 ? (
    gfx_set(0.50, 0.30, 0.70, 0.85);
  ) : (
    gfx_set(0.90, 0.20, 0.15, 0.85);
  );
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_norm * lfe_bar_w, lfe_bar_h);

  // LFE peak hold
  lfe_cur_pk = meter_mode == 0 ? lfe_peak[0] : lfe_rms[0];
  lfe_cur_pk > lfe_hold[0] ? (
    lfe_hold[0] = lfe_cur_pk;
    lfe_hold_tm[0] = PEAK_HOLD_FRAMES;
  ) : (
    lfe_hold_tm[0] > 0 ? (
      lfe_hold_tm[0] -= 1;
    ) : (
      lfe_hold[0] *= PEAK_DECAY;
    );
  );
  lfe_hld_db = lfe_hold[0] > 0.00001 ? 20.0 * log10(lfe_hold[0]) : -60.0;
  lfe_hld_norm = max(0.0, (lfe_hld_db + 60.0) / 60.0);
  lfe_hld_x = lfe_bar_x + lfe_hld_norm * lfe_bar_w;
  gfx_set(1.0, 1.0, 1.0, 0.5);
  gfx_line(lfe_hld_x, lfe_bar_y, lfe_hld_x, lfe_bar_y + lfe_bar_h);

  // dB readout
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = lfe_bar_x + lfe_bar_w + 6;
  gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  lfe_db > -59.0 ? (
    gfx_drawnumber(lfe_db, 1);
    gfx_drawstr(" dB");
  ) : (
    gfx_drawstr("-inf dB");
  );

  // LFE mute click
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    mouse_x >= pad + 4 && mouse_x <= pad + 40 * sc &&
    mouse_y >= lfe_top && mouse_y <= lfe_top + lfe_h ? (
      // Toggle LFE mute bit
      (slider21 & 8) ? (
        slider21 = slider21 - 8;
      ) : (
        slider21 = slider21 | 8;
      );
      sliderchange(slider21);
    );
  );

  // Update mouse state for click detection
  last_mouse_cap = mouse_cap;

  // =====================================================
  // VERSION WATERMARK
  // =====================================================
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.15);
  #wm = "v2.1.0";
  gfx_measurestr(#wm, wmw, wmh);
  gfx_x = gfx_w - wmw - 4;
  gfx_y = gfx_h - wmh - 2;
  gfx_drawstr(#wm);
