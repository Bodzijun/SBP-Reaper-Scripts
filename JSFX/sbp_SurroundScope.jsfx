desc: SBP Surround Scope 5.1
// @version 1.35
// @author SBP & AI
// @about 5.1 Surround Sound Field Analyzer with heat map, phase correlation, and level meters.
//   Monitoring-only: audio passes through unmodified.
//   Visualises energy distribution in a cinema-like top-down view with temporal decay.
//   Displays phase coherence between all speaker pairs.
//   Reference UI style: floop-master-control (dark charcoal + green accents).
// @changelog v1.35 - Panorama Mix parameter added (slider2): 0=Pure Analyzer (original audio analyzed), 1=Full Panorama (rotated audio analyzed). Fixes "signal bleeding between channels" issue when using with other effects. All analyzers (energy, peak, RMS, LUFS, phase correlation, goniometer, heat map) now work on the analyzed mix. Audio output remains unchanged (pass-through monitoring). Supports blend between pure analysis and panoramic analysis.
// @changelog v1.0 - Initial release: Professional 5.1 surround analyzer with real-time heat map visualization, 10-pair goniometer with phase correlation, ITU-R BS.1770-4 calibrated LUFS metering, rotatable listener panorama (-180° to +180°), phantom center tracking, perceptual colormaps (Viridis/Inferno/Plasma/Magma), COMPACT/FULL UI modes, and interactive draggable controls.

// ======================================================================
// SLIDERS - LOGICAL ORDER BY UI LAYOUT
// ======================================================================
// === PANORAMA CONTROLS ===
slider1:0<-180,180,1>Listener Rotation (deg)
slider2:1<0,1,1{Pure Analyzer (No Pan),Panorama Active}>Panorama Enable
slider3:0<0,1,1{VBAP Clean,Amplitude Bleed}>Panorama Mode
// === DISPLAY MODES ===
slider4:0<0,1,1{Heat Map,Stereo Goniometer}>Display Mode
slider5:0<0,1,1{Peak,RMS}>Meter Mode
slider6:0<0,1,1{Show All,Compact View}>-UI Mode
// === SENSITIVITY CONTROLS ===
slider7:1.0<0.1,4.0,0.1>Sensitivity (Heat Map)
slider8:10.0<0.1,15.0,0.1>Goniometer Sensitivity
// === HEAT MAP & VISUALIZATION ===
slider9:0.96<0.90,0.995,0.001>Decay Speed
slider10:0.15<0.0,1.0,0.01>Brightness
slider11:0<0,9,1{Teal-Green,Rainbow,Cyan-Magenta,Fire,Mono Green,Blue Fire,Viridis,Inferno,Plasma,Magma}>Color Scheme
slider12:0.85<0.0,0.99,0.01>Heatmap Smoothing
slider13:0<0,1,1{Auto Scale,Lock -60dB Floor}>Heatmap Scale
slider14:-23<-60,0,1>Target Level (dB)
// === DRAWING OPTIONS ===
slider15:0<0,1,1{OFF,ON}>Show Grid
slider16:1.0<0.0,2.0,0.01>Wave Rings Visibility
slider17:1<0,1,1{OFF,ON}>Outside Mask
// === PHANTOM CENTER ANALYSIS ===
slider18:0.5<0,1,0.001>-Phantom Center X
slider19:0.5<0,1,0.001>-Phantom Center Y
slider20:0.85<0.0,0.99,0.01>Phantom Center Smoothing
// === GONIOMETER ANALYSIS ===
slider21:0<0,9,1{L-R,L-C,L-Ls,L-Rs,R-C,R-Ls,R-Rs,C-Ls,C-Rs,Ls-Rs}>Goniometer Pair
// ======================================================================
// PIN DEFINITIONS (6-channel 5.1 pass-through)
// ======================================================================

in_pin:Front L
in_pin:Front R
in_pin:Center
in_pin:LFE
in_pin:Rear L
in_pin:Rear R

out_pin:Front L
out_pin:Front R
out_pin:Center
out_pin:LFE
out_pin:Rear L
out_pin:Rear R

// ======================================================================
// @init
// ======================================================================
@init

  // --- CONSTANTS ---
  PI = 3.14159265359;
  TWO_PI = 2.0 * PI;
  DEG2RAD = PI / 180.0;

  GRID_W = 64;
  GRID_H = 64;
  GRID_TOTAL = GRID_W * GRID_H;

  NUM_SPEAKERS = 5;       // L, R, C, Ls, Rs (LFE excluded from spatial field)
  NUM_PHASE_PAIRS = 10;   // All possible combinations: L-R, L-C, L-Ls, L-Rs, R-C, R-Ls, R-Rs, C-Ls, C-Rs, Ls-Rs

  // UI constants for slider visibility control
  // Show/hide all sliders 0-18. UI Mode (slider4) remains hidden.
  UI_SLIDERS_MASK = (1 << 19) - 1;  // Sliders 0-18
  sliders_showing = 0;              // Track slider visibility state

  PEAK_HOLD_FRAMES = 45;  // ~1.5s at 30fps
  PEAK_DECAY = 0.97;
  RMS_WINDOW = 1024;

  // --- OFFSCREEN BUFFER INDICES ---
  HEAT_BUFFER = 127;
  GONIO_BUFFER = 126;
  SURR_BUFFER = 125;  // 5.1 Surround goniometer buffer

  // --- SPEAKER POSITIONS (normalized 0..1) ---
  // Aligned to cinema trapezoid geometry - speakers at trapezoid corners and center:
  //   Front wall: y=0.15, x from 0.20 to 0.80 (width 0.6)
  //   Rear wall:  y=0.85, x from 0.05 to 0.95 (width 0.9)
  //   Left wall:  (0.20,0.15) → (0.05,0.85)
  //   Right wall: (0.80,0.15) → (0.95,0.85)
  spk_x = 180;   // [180..184] - SAFE MEMORY AREA
  spk_y = 185;   // [185..189] - SAFE MEMORY AREA

  listen_x = 0.5;
  listen_y = 0.50;

  // C = center of front wall (screen center)
  spk_x[2] = 0.50;
  spk_y[2] = 0.15;

  // L = Front Left corner of trapezoid
  spk_x[0] = 0.20;
  spk_y[0] = 0.15;

  // R = Front Right corner of trapezoid
  spk_x[1] = 0.80;
  spk_y[1] = 0.15;

  // Ls = Left Surround - rear left corner of trapezoid
  spk_x[3] = 0.05;
  spk_y[3] = 0.85;

  // Rs = Right Surround - rear right corner of trapezoid
  spk_x[4] = 0.95;
  spk_y[4] = 0.85;

  // --- MEMORY LAYOUT ---
  energy       = 100;  // [100..104] smoothed energy per speaker
  peak_level   = 110;  // [110..114]
  rms_acc      = 120;  // [120..124]
  rms_level    = 130;  // [130..134]
  rms_disp     = 170;  // [170..174]
  peak_hold    = 140;  // [140..144]
  peak_hold_tm = 150;  // [150..154]

  lfe_energy   = 160;  // [160]
  lfe_peak     = 161;  // [161]
  lfe_rms_acc  = 162;  // [162]
  lfe_rms      = 163;  // [163]
  lfe_hold     = 164;  // [164]
  lfe_hold_tm  = 165;  // [165]
  
  // Speaker positions - moved to safe area to prevent memory conflicts
  // spk_x = 180; spk_y = 185 (defined above)

  phase_sum_ab = 200;  // [200..209] - 10 pairs
  phase_sum_a2 = 210;  // [210..219] - 10 pairs
  phase_sum_b2 = 220;  // [220..229] - 10 pairs
  phase_corr   = 240;  // [240..249] - 10 pairs
  phase_smooth = 250;  // [250..259] - 10 pairs (smoothed correlation)

  heatmap      = 300;   // [300..4395]   64*64 = 4096
  weight_table = 5000;  // [5000..25479] 4096*5 = 20480
  
  energy_history = 30000;  // [30000..30049] History buffer: 5 speakers * 10 frames each

  rms_counter  = 26000;

  // Goniometer ring buffer for per-sample scatter
  gonio_write  = 26010;
  GONIO_BUF    = 27000; // [27000..27000+GONIO_SIZE*2-1]
  GONIO_SIZE   = 4096;
  
  // 5.1 Surround goniometer: store 5 channels per sample
  surr_write   = 26011;
  SURR_BUF     = 28000; // [28000..28000+GONIO_SIZE*5-1]
  SURR_SIZE    = 4096;

  // Heat map peak tracking
  heatmap_peak = 26012;  // Current peak value
  heatmap_peak_hold = 26013;  // Hold peak value
  heatmap_min = 26014;  // Minimum value for LRA range
  heatmap_min_hold = 26015;  // Hold minimum value
  
  // Phantom center smoothed position
  phantom_center_x = 26016;
  phantom_center_y = 26017;
  
  // Heat map smoothing (separate from energy meters)
  heatmap_energy = 26060;  // [26060..26064]
  
  // K-weighting filter state (ITU-R BS.1770-4) - 5 channels, 2 stages, 2 states each
  kw_z1 = 26020;  // [26020..26039] Stage 1 & 2 z1 for L,R,C,Ls,Rs
  kw_z2 = 26040;  // [26040..26059] Stage 1 & 2 z2 for L,R,C,Ls,Rs

  // --- COLOR SCHEME FUNCTION ---
  // Returns color (cr, cg, cb) for value v [0..1] and scheme [0..9]
  function get_color(v, scheme, cr*, cg*, cb*) (
    scheme == 0 ? (  // Teal-Green (original)
      v < 0.15 ? (
        t = v / 0.15;
        cr = 0;
        cg = t * 0.15;
        cb = t * 0.30;
      ) : v < 0.4 ? (
        t = (v - 0.15) / 0.25;
        cr = t * 0.10;
        cg = 0.15 + t * 0.55;
        cb = 0.30 + t * 0.05;
      ) : v < 0.7 ? (
        t = (v - 0.4) / 0.3;
        cr = 0.10 + t * 0.35;
        cg = 0.70 + t * 0.25;
        cb = 0.35 - t * 0.15;
      ) : (
        t = (v - 0.7) / 0.3;
        cr = 0.45 + t * 0.55;
        cg = 0.95 + t * 0.05;
        cb = 0.20 + t * 0.50;
      );
    ) : scheme == 1 ? (  // Rainbow Spectrum
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0; cg = 0; cb = 0.3 + t * 0.7;  // Dark blue -> bright blue
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0; cg = t * 0.9; cb = 1.0 - t * 0.3;  // Blue -> cyan
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = t * 1.0; cg = 0.9; cb = 0.7 - t * 0.7;  // Cyan -> yellow
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 1.0; cg = 0.9 - t * 0.5; cb = 0;  // Yellow -> orange-red
      );
    ) : scheme == 2 ? (  // Cyan-Magenta
      v < 0.5 ? (
        t = v / 0.5;
        cr = 0; cg = 0.2 + t * 0.7; cb = 0.4 + t * 0.6;  // Dark cyan -> bright cyan
      ) : (
        t = (v - 0.5) / 0.5;
        cr = t * 1.0; cg = 0.9 - t * 0.5; cb = 1.0 - t * 0.3;  // Cyan -> magenta
      );
    ) : scheme == 3 ? (  // Fire (red-orange-yellow-white)
      v < 0.3 ? (
        t = v / 0.3;
        cr = 0.2 + t * 0.6; cg = 0; cb = 0;  // Dark red -> red
      ) : v < 0.6 ? (
        t = (v - 0.3) / 0.3;
        cr = 0.8 + t * 0.2; cg = t * 0.6; cb = 0;  // Red -> orange
      ) : v < 0.85 ? (
        t = (v - 0.6) / 0.25;
        cr = 1.0; cg = 0.6 + t * 0.4; cb = t * 0.4;  // Orange -> yellow
      ) : (
        t = (v - 0.85) / 0.15;
        cr = 1.0; cg = 1.0; cb = 0.4 + t * 0.6;  // Yellow -> white
      );
    ) : scheme == 4 ? (  // Monochrome Green
      t = v;
      cr = t * 0.2; cg = 0.15 + t * 0.85; cb = t * 0.15;
    ) : scheme == 5 ? (  // Blue Fire (blue-purple-pink-white)
      v < 0.3 ? (
        t = v / 0.3;
        cr = 0; cg = 0; cb = 0.2 + t * 0.6;  // Dark blue -> blue
      ) : v < 0.6 ? (
        t = (v - 0.3) / 0.3;
        cr = t * 0.7; cg = 0; cb = 0.8 + t * 0.2;  // Blue -> purple
      ) : v < 0.85 ? (
        t = (v - 0.6) / 0.25;
        cr = 0.7 + t * 0.3; cg = t * 0.5; cb = 1.0;  // Purple -> pink
      ) : (
        t = (v - 0.85) / 0.15;
        cr = 1.0; cg = 0.5 + t * 0.5; cb = 1.0;  // Pink -> white
      );
    ) : scheme == 6 ? (  // Viridis
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.267004 + (0.282327 - 0.267004) * t;
        cg = 0.004874 + (0.140536 - 0.004874) * t;
        cb = 0.329415 + (0.457517 - 0.329415) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.282327 + (0.253935 - 0.282327) * t;
        cg = 0.140536 + (0.265254 - 0.140536) * t;
        cb = 0.457517 + (0.529983 - 0.457517) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.253935 + (0.206756 - 0.253935) * t;
        cg = 0.265254 + (0.371758 - 0.265254) * t;
        cb = 0.529983 + (0.553117 - 0.529983) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.206756 + (0.993248 - 0.206756) * t;
        cg = 0.371758 + (0.906157 - 0.371758) * t;
        cb = 0.553117 + (0.143936 - 0.553117) * t;
      );
    ) : scheme == 7 ? (  // Inferno
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.001462 + (0.221000 - 0.001462) * t;
        cg = 0.000466 + (0.047000 - 0.000466) * t;
        cb = 0.013866 + (0.327000 - 0.013866) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.221000 + (0.476000 - 0.221000) * t;
        cg = 0.047000 + (0.108000 - 0.047000) * t;
        cb = 0.327000 + (0.505000 - 0.327000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.476000 + (0.789000 - 0.476000) * t;
        cg = 0.108000 + (0.260000 - 0.108000) * t;
        cb = 0.505000 + (0.281000 - 0.505000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.789000 + (0.988000 - 0.789000) * t;
        cg = 0.260000 + (0.998000 - 0.260000) * t;
        cb = 0.281000 + (0.645000 - 0.281000) * t;
      );
    ) : scheme == 8 ? (  // Plasma
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.050383 + (0.273000 - 0.050383) * t;
        cg = 0.029803 + (0.074000 - 0.029803) * t;
        cb = 0.527975 + (0.709000 - 0.527975) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.273000 + (0.545000 - 0.273000) * t;
        cg = 0.074000 + (0.135000 - 0.074000) * t;
        cb = 0.709000 + (0.683000 - 0.709000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.545000 + (0.827000 - 0.545000) * t;
        cg = 0.135000 + (0.337000 - 0.135000) * t;
        cb = 0.683000 + (0.444000 - 0.683000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.827000 + (0.944000 - 0.827000) * t;
        cg = 0.337000 + (0.975000 - 0.337000) * t;
        cb = 0.444000 + (0.131000 - 0.444000) * t;
      );
    ) : (  // Magma
      v < 0.25 ? (
        t = v / 0.25;
        cr = 0.001462 + (0.179000 - 0.001462) * t;
        cg = 0.000466 + (0.070000 - 0.000466) * t;
        cb = 0.013866 + (0.431000 - 0.013866) * t;
      ) : v < 0.5 ? (
        t = (v - 0.25) / 0.25;
        cr = 0.179000 + (0.444000 - 0.179000) * t;
        cg = 0.070000 + (0.120000 - 0.070000) * t;
        cb = 0.431000 + (0.510000 - 0.431000) * t;
      ) : v < 0.75 ? (
        t = (v - 0.5) / 0.25;
        cr = 0.444000 + (0.769000 - 0.444000) * t;
        cg = 0.120000 + (0.220000 - 0.120000) * t;
        cb = 0.510000 + (0.267000 - 0.510000) * t;
      ) : (
        t = (v - 0.75) / 0.25;
        cr = 0.769000 + (0.987000 - 0.769000) * t;
        cg = 0.220000 + (0.991000 - 0.220000) * t;
        cb = 0.267000 + (0.749000 - 0.267000) * t;
      );
    );
  );

  // --- CLEAR ARRAYS ---
  i = 0;
  loop(NUM_SPEAKERS,
    energy[i] = 0;
    heatmap_energy[i] = 0;
    peak_level[i] = 0;
    rms_acc[i] = 0;
    rms_level[i] = 0;
    rms_disp[i] = 0;
    peak_hold[i] = 0;
    peak_hold_tm[i] = 0;
    i += 1;
  );
  lfe_energy[0] = 0; lfe_peak[0] = 0; lfe_rms_acc[0] = 0; lfe_rms[0] = 0;
  lfe_hold[0] = 0; lfe_hold_tm[0] = 0;

  i = 0;
  loop(NUM_PHASE_PAIRS,
    phase_sum_ab[i] = 0;
    phase_sum_a2[i] = 0;
    phase_sum_b2[i] = 0;
    phase_corr[i] = 0;
    phase_smooth[i] = 0;
    i += 1;
  );

  memset(heatmap, 0, GRID_TOTAL);
  rms_counter[0] = 0;
  gonio_write[0] = 0;
  surr_write[0] = 0;
  
  // Mouse state tracking for click detection
  last_mouse_cap = 0;
  mouse_clicked_ui = 0;
  
  // Dragging state for listener rotation
  dragging_listener = 0;
  
  // --- K-WEIGHTING FILTER COEFFICIENTS (ITU-R BS.1770-4) ---
  // Two stages: Stage 1 (high-pass ~48Hz), Stage 2 (high-shelf +4dB @ 1681Hz)
  
  // Stage 1: High-pass filter (2nd order Butterworth @ 38 Hz)
  f0_hp = 38.13547087613982;
  Q_hp = 0.5003270373253953;
  K_hp = tan($pi * f0_hp / srate);
  norm_hp = 1.0 / (1.0 + K_hp / Q_hp + K_hp * K_hp);
  kw_b0_hp = norm_hp;
  kw_b1_hp = -2.0 * norm_hp;
  kw_b2_hp = norm_hp;
  kw_a1_hp = 2.0 * (K_hp * K_hp - 1.0) * norm_hp;
  kw_a2_hp = (1.0 - K_hp / Q_hp + K_hp * K_hp) * norm_hp;
  
  // Stage 2: High-shelf filter (+3.999 dB @ 1681.97 Hz)
  f0_hs = 1681.9744509555319;
  Q_hs = 0.7071752369554196;
  gain_hs_db = 3.999843853973347;
  A_hs = pow(10.0, gain_hs_db / 40.0);
  K_hs = tan($pi * f0_hs / srate);
  norm_hs = 1.0 / (1.0 + K_hs / Q_hs + K_hs * K_hs);
  kw_b0_hs = (1.0 + sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_b1_hs = 2.0 * (A_hs * K_hs * K_hs - 1.0) * norm_hs;
  kw_b2_hs = (1.0 - sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_a1_hs = 2.0 * (K_hs * K_hs - 1.0) * norm_hs;
  kw_a2_hs = (1.0 - K_hs / Q_hs + K_hs * K_hs) * norm_hs;
  
  // Clear filter states
  memset(kw_z1, 0, 20);
  memset(kw_z2, 0, 20);

  // --- PRE-COMPUTE WEIGHT TABLE ---
  // Use more gradual gaussian falloff for smooth spatial blending
  // Smaller decay coefficient = wider, softer influence zones = better blending
  decay_coeff = 8.0;  // Was 55.0 - too sharp. 8.0 gives smooth overlapping zones
  
  cell = 0;
  gy = 0;
  loop(GRID_H,
    gx = 0;
    loop(GRID_W,
      cx = (gx + 0.5) / GRID_W;
      cy = (gy + 0.5) / GRID_H;
      total_w = 0;
      s = 0;
      loop(NUM_SPEAKERS,
        dx = cx - spk_x[s];
        dy = cy - spk_y[s];
        dist_sq = dx * dx + dy * dy + 0.0001;
        // Wider gaussian = more overlap = smoother field
        w = exp(-dist_sq * decay_coeff);
        weight_table[cell * NUM_SPEAKERS + s] = w;
        total_w += w;
        s += 1;
      );
      total_w > 0.0001 ? (
        s = 0;
        loop(NUM_SPEAKERS,
          weight_table[cell * NUM_SPEAKERS + s] /= total_w;
          s += 1;
        );
      );
      cell += 1;
      gx += 1;
    );
    gy += 1;
  );

  // --- STATE ---
  last_w = 0;
  last_h = 0;
  energy_smooth = 0.80;

  // Read slider defaults
  decay_factor = 0.96;
  sensitivity = 1.0;
  display_mode = 0;
  meter_mode = 0;
  heatmap_brightness = 0.15;
  color_scheme = 0;
  show_grid = 0;
  wave_rings_vis = 1.0;
  outside_mask = 1;
  target_level = -23;
  phantom_smoothing = 0.85;
  heatmap_smoothing = 0.85;
  heatmap_lock_floor = 0;
  lufs_short = -120;
  lufs_mom = -120;
  lufs_int = -120;
  lufs_short_disp = -120;
  lufs_mom_disp = -120;
  lufs_int_disp = -120;
  lufs_short_acc = 0;
  lufs_short_cnt = 0;
  lufs_mom_acc = 0;
  lufs_mom_cnt = 0;
  lufs_int_acc = 0;
  lufs_int_cnt = 0;
  lufs_m_db = -100;
  lufs_s_db = -100;
  lufs_i_db = -100;
  lufs_win_pos = 0;
  lufs_win_cnt = 0;
  lufs_win_acc = 0;
  lufs_cur_buf = 0;
  lufs_cur_buf2 = 0;
  lufs_m_sum = 0;
  lufs_s_sum = 0;
  lufs_a_sum = 0;
  lufs_a_sum_cnt = 0;
  lufs_i_sum = 0;
  lufs_i_cnt = 0;

  // LUFS windowing (Cockos/REAPER)
  LOUD_METER_UPDATE = 0.10; // 100ms
  lufs_m_win_cnt = max(1, (0.4 / LOUD_METER_UPDATE) | 0);
  lufs_s_win_cnt = max(1, (3.0 / LOUD_METER_UPDATE) | 0);
  lufs_win_len = max(1, (LOUD_METER_UPDATE * srate) | 0);
  lufs_i_win_len = 1.0 / (lufs_m_win_cnt * lufs_win_len);
  lufs_i_win_len2 = 1.0 / (lufs_s_win_cnt * lufs_win_len);
  NUM_BINS = 1024;
  BINS_PER_DB = 10;
  DB_PER_BIN = 1.0 / BINS_PER_DB;

  // LUFS buffers and histograms (memory-safe region)
  lufs_buf = 50000;     // [50000..50000+lufs_m_win_cnt-1]
  lufs_buf2 = 50010;    // [50010..50010+lufs_s_win_cnt-1]
  lufs_a_hist = 50050;  // [50050..50050+NUM_BINS*2-1]
  
  // Per-meter peak hold for LUFS mode
  i = 0;
  loop(6,
    peak_hold_db[i] = -120;
    peak_hold_tm_db[i] = 0;
    i += 1;
  );

  // Clear LUFS buffers and histograms
  i = 0;
  loop(lufs_m_win_cnt,
    lufs_buf[i] = 0;
    i += 1;
  );
  i = 0;
  loop(lufs_s_win_cnt,
    lufs_buf2[i] = 0;
    i += 1;
  );
  i = 0;
  loop(NUM_BINS * 2,
    lufs_a_hist[i] = 0;
    i += 1;
  );

  // Heat map peak tracking
  heatmap_peak[0] = 0;
  heatmap_peak_hold[0] = 0;
  heatmap_min[0] = 1.0;
  heatmap_min_hold[0] = 1.0;
  
  // Phantom center
  phantom_center_x[0] = listen_x;
  phantom_center_y[0] = listen_y;
  heatmap_peak_hold[0] = 0;

// ======================================================================
// @slider
// ======================================================================
@slider
  listener_rotation = slider1 * ($pi / 180.0);  // Convert degrees (-180 to +180) to radians
  display_mode     = slider4;
  meter_mode       = slider5;
  ui_mode          = slider6;
  sensitivity      = slider7;
  gonio_sensitivity_user = slider8;
  decay_factor     = slider9;
  heatmap_brightness = slider10;
  color_scheme     = slider11|0;
  heatmap_smoothing = slider12;
  heatmap_lock_floor = slider13;
  target_level     = slider14;
  show_grid        = slider15;
  wave_rings_vis   = slider16;
  outside_mask     = slider17;
  phantom_smoothing = slider20;
  gonio_pair       = slider21|0;
  // Phantom Center coordinates
  // (handled separately in phantom center calculations)

// ======================================================================
// @sample — Audio Processing Chain
// ORDER: Input -> PANORAMA ROTATION -> Energy/Peak/Metrics -> Output
// ======================================================================
@sample
  // === STEP 1: READ INPUT ===
  in_L   = spl0;
  in_R   = spl1;
  in_C   = spl2;
  in_LFE = spl3;
  in_Ls  = spl4;
  in_Rs  = spl5;

  // Synchronize listener rotation with slider1 (important for drag)
  listener_rotation = slider1 * ($pi / 180.0);  // Convert degrees to radians

  // === STEP 2: 5.1 PANORAMA ROTATION ===
  // Choose mode based on slider3 (VBAP vs Amplitude)
  // Rotate audio around listener when slider1 changes
  // IMPORTANT: Rotating AUDIO for analysis with different panning modes
  // Listener arrow shows center channel direction.
  // Direction: slider right → sound rotates right (clockwise).
  
  // Read panorama control sliders
  panorama_enable = slider2;   // 0=Original (no pan), 1=Panorama Active
  panorama_mode = slider3;     // 0=VBAP clean, 1=Amplitude bleed
  
  // CORRECT IMPLEMENTATION: rotate each channel around listener
  // Each input channel has its physical angle, after rotation redistribute
  // signal between nearest output speakers (amplitude panning or VBAP).
  
  rot_angle = -listener_rotation;  // INVERTED: slider right = rotation left
  
  // Define output speaker angles (in radians, 0=up/center, positive clockwise)
  // Use speaker coordinates to calculate angles
  ang_C  = 0;                    // Center: 0° (up)
  ang_L  = atan2(spk_x[0] - 0.5, 0.5 - spk_y[0]);  // Front Left
  ang_R  = atan2(spk_x[1] - 0.5, 0.5 - spk_y[1]);  // Front Right  
  ang_Ls = atan2(spk_x[3] - 0.5, 0.5 - spk_y[3]);  // Rear Left
  ang_Rs = atan2(spk_x[4] - 0.5, 0.5 - spk_y[4]);  // Rear Right
  
  // VBAP function: Vector Base Amplitude Panning (clean, no crosstalk)
  // Finds 2 nearest speakers and distributes signal only to them
  function distribute_vbap(source_angle, source_signal, outL*, outR*, outC*, outLs*, outRs*)
  local(ang_diff_C, ang_diff_L, ang_diff_R, ang_diff_Ls, ang_diff_Rs,
        weight_C, weight_L, weight_R, weight_Ls, weight_Rs,
        total_weight, max_weight, second_weight, max_idx, second_idx, i, weights)
  (
    // Normalize angle wrapping
    source_angle > $pi ? source_angle -= TWO_PI;
    source_angle < -$pi ? source_angle += TWO_PI;
    
    // Calculate angular distance to each speaker
    ang_diff_C = source_angle - ang_C;
    ang_diff_L = source_angle - ang_L;
    ang_diff_R = source_angle - ang_R;
    ang_diff_Ls = source_angle - ang_Ls;
    ang_diff_Rs = source_angle - ang_Rs;
    
    // Normalize differences to -π..π
    ang_diff_C > $pi ? ang_diff_C -= TWO_PI : ang_diff_C < -$pi ? ang_diff_C += TWO_PI;
    ang_diff_L > $pi ? ang_diff_L -= TWO_PI : ang_diff_L < -$pi ? ang_diff_L += TWO_PI;
    ang_diff_R > $pi ? ang_diff_R -= TWO_PI : ang_diff_R < -$pi ? ang_diff_R += TWO_PI;
    ang_diff_Ls > $pi ? ang_diff_Ls -= TWO_PI : ang_diff_Ls < -$pi ? ang_diff_Ls += TWO_PI;
    ang_diff_Rs > $pi ? ang_diff_Rs -= TWO_PI : ang_diff_Rs < -$pi ? ang_diff_Rs += TWO_PI;
    
    // Weight based on angular distance (use cos for smooth transition)
    // Only positive weights contribute (zero out negative)
    weight_C = max(0, cos(ang_diff_C));
    weight_L = max(0, cos(ang_diff_L));
    weight_R = max(0, cos(ang_diff_R));
    weight_Ls = max(0, cos(ang_diff_Ls));
    weight_Rs = max(0, cos(ang_diff_Rs));
    
    // Find two nearest speakers (find max and second_max correctly)
    // Collect all weights into local array
    weights = 1000;  // Use memory area 1000-1004 for temp weights
    weights[0] = weight_C;
    weights[1] = weight_L;
    weights[2] = weight_R;
    weights[3] = weight_Ls;
    weights[4] = weight_Rs;
    
    // Find max and second_max
    max_weight = 0; second_weight = -1;
    max_idx = -1; second_idx = -1;
    
    i = 0;
    loop(5,
      weights[i] > max_weight ? (
        second_weight = max_weight;
        second_idx = max_idx;
        max_weight = weights[i];
        max_idx = i;
      ) : weights[i] > second_weight ? (
        second_weight = weights[i];
        second_idx = i;
      );
      i += 1;
    );
    
    // If max weight is very dominant (> 0.9), send 100% there (mono)
    // Otherwise distribute to top 2
    max_weight > 0.9 ? (
      // Clearly aligned to one speaker - send all there
      max_idx == 0 ? (outC += source_signal;) : 
      max_idx == 1 ? (outL += source_signal;) :
      max_idx == 2 ? (outR += source_signal;) :
      max_idx == 3 ? (outLs += source_signal;) :
                     (outRs += source_signal;);
    ) : (
      // Some significant offset - normalize and distribute to top 2
      total_weight = max_weight + second_weight + 0.0001;
      max_weight /= total_weight;
      second_weight /= total_weight;
      
      max_idx == 0 ? (outC += source_signal * max_weight;) : 
      max_idx == 1 ? (outL += source_signal * max_weight;) :
      max_idx == 2 ? (outR += source_signal * max_weight;) :
      max_idx == 3 ? (outLs += source_signal * max_weight;) :
                     (outRs += source_signal * max_weight;);
      
      second_idx == 0 ? (outC += source_signal * second_weight;) : 
      second_idx == 1 ? (outL += source_signal * second_weight;) :
      second_idx == 2 ? (outR += source_signal * second_weight;) :
      second_idx == 3 ? (outLs += source_signal * second_weight;) :
                        (outRs += source_signal * second_weight;);
    );
  );
  
  // Amplitude panning function: distributes signal between 5 speakers
  // based on source_angle (after rotation) - allows crosstalk
  function distribute_amplitude(source_angle, source_signal, outL*, outR*, outC*, outLs*, outRs*)
  local(ang_diff_C, ang_diff_L, ang_diff_R, ang_diff_Ls, ang_diff_Rs,
        weight_C, weight_L, weight_R, weight_Ls, weight_Rs, total_weight,
        ang_wrap)
  (
    // Normalize angle wrapping
    source_angle > $pi ? source_angle -= TWO_PI;
    source_angle < -$pi ? source_angle += TWO_PI;
    
    // Calculate angular distance to each speaker
    ang_diff_C = source_angle - ang_C;
    ang_diff_L = source_angle - ang_L;
    ang_diff_R = source_angle - ang_R;
    ang_diff_Ls = source_angle - ang_Ls;
    ang_diff_Rs = source_angle - ang_Rs;
    
    // Normalize differences to -π..π
    ang_diff_C > $pi ? ang_diff_C -= TWO_PI : ang_diff_C < -$pi ? ang_diff_C += TWO_PI;
    ang_diff_L > $pi ? ang_diff_L -= TWO_PI : ang_diff_L < -$pi ? ang_diff_L += TWO_PI;
    ang_diff_R > $pi ? ang_diff_R -= TWO_PI : ang_diff_R < -$pi ? ang_diff_R += TWO_PI;
    ang_diff_Ls > $pi ? ang_diff_Ls -= TWO_PI : ang_diff_Ls < -$pi ? ang_diff_Ls += TWO_PI;
    ang_diff_Rs > $pi ? ang_diff_Rs -= TWO_PI : ang_diff_Rs < -$pi ? ang_diff_Rs += TWO_PI;
    
    // Weight inversely proportional to angular distance (use cos for smooth transition)
    // All speakers contribute (amplitude bleed/crosstalk)
    weight_C = max(0, cos(ang_diff_C));
    weight_L = max(0, cos(ang_diff_L));
    weight_R = max(0, cos(ang_diff_R));
    weight_Ls = max(0, cos(ang_diff_Ls));
    weight_Rs = max(0, cos(ang_diff_Rs));
    
    total_weight = weight_C + weight_L + weight_R + weight_Ls + weight_Rs + 0.0001;
    
    // Normalize and add to outputs
    outC += source_signal * (weight_C / total_weight);
    outL += source_signal * (weight_L / total_weight);
    outR += source_signal * (weight_R / total_weight);
    outLs += source_signal * (weight_Ls / total_weight);
    outRs += source_signal * (weight_Rs / total_weight);
  );
  
  // Initialize output channels
  L_rotated = 0;
  R_rotated = 0;
  C_rotated = 0;
  Ls_rotated = 0;
  Rs_rotated = 0;
  
  // Choose panning mode based on slider3 (Panorama Mode)
  // Mode 0: VBAP (clean, no crosstalk)
  // Mode 1: Amplitude (bleed/crosstalk between speakers)
  panorama_mode == 0 ? (
    // VBAP: clean rotation, only 2 nearest speakers
    distribute_vbap(ang_L - rot_angle, in_L, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_R - rot_angle, in_R, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_C - rot_angle, in_C, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_Ls - rot_angle, in_Ls, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_vbap(ang_Rs - rot_angle, in_Rs, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
  ) : (
    // Amplitude: bleed/crosstalk between all speakers
    distribute_amplitude(ang_L - rot_angle, in_L, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_R - rot_angle, in_R, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_C - rot_angle, in_C, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_Ls - rot_angle, in_Ls, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
    distribute_amplitude(ang_Rs - rot_angle, in_Rs, L_rotated, R_rotated, C_rotated, Ls_rotated, Rs_rotated);
  );
  
  // LFE not rotated (subwoofer is omnidirectional)
  LFE_rotated = in_LFE;

  // Select original or rotated audio based on slider2 (Panorama Enable)
  // 0 = Original (no panning, pure analyzer)
  // 1 = Panorama Active (rotated audio)
  panorama_enable = slider2;
  
  panorama_enable == 1 ? (
    // Panorama active - use rotated channels
    L_analyzed = L_rotated;
    R_analyzed = R_rotated;
    C_analyzed = C_rotated;
    Ls_analyzed = Ls_rotated;
    Rs_analyzed = Rs_rotated;
  ) : (
    // Original - no panorama
    L_analyzed = in_L;
    R_analyzed = in_R;
    C_analyzed = in_C;
    Ls_analyzed = in_Ls;
    Rs_analyzed = in_Rs;
  );
  LFE_analyzed = LFE_rotated;  // LFE not affected by panorama

  // --- ENERGY TRACKING (from analyzed audio - mix of original and rotated) ---
  abs_L   = abs(L_analyzed);
  abs_R   = abs(R_analyzed);
  abs_C   = abs(C_analyzed);
  abs_Ls  = abs(Ls_analyzed);
  abs_Rs  = abs(Rs_analyzed);
  abs_LFE = abs(LFE_analyzed);

  es = energy_smooth;
  esi = 1.0 - es;
  energy[0] = energy[0] * es + abs_L   * esi;
  energy[1] = energy[1] * es + abs_R   * esi;
  energy[2] = energy[2] * es + abs_C   * esi;
  energy[3] = energy[3] * es + abs_Ls  * esi;
  energy[4] = energy[4] * es + abs_Rs  * esi;
  lfe_energy[0] = lfe_energy[0] * es + abs_LFE * esi;

  // Additional heat map smoothing (user-controlled)
  hs = heatmap_smoothing;
  hsi = 1.0 - hs;
  heatmap_energy[0] = heatmap_energy[0] * hs + energy[0] * hsi;
  heatmap_energy[1] = heatmap_energy[1] * hs + energy[1] * hsi;
  heatmap_energy[2] = heatmap_energy[2] * hs + energy[2] * hsi;
  heatmap_energy[3] = heatmap_energy[3] * hs + energy[3] * hsi;
  heatmap_energy[4] = heatmap_energy[4] * hs + energy[4] * hsi;

  // --- PEAK TRACKING (from rotated channels) ---
  m_dec = 0.9998;
  peak_level[0] = max(peak_level[0] * m_dec, abs_L);
  peak_level[1] = max(peak_level[1] * m_dec, abs_R);
  peak_level[2] = max(peak_level[2] * m_dec, abs_C);
  peak_level[3] = max(peak_level[3] * m_dec, abs_Ls);
  peak_level[4] = max(peak_level[4] * m_dec, abs_Rs);
  lfe_peak[0]   = max(lfe_peak[0] * m_dec, abs_LFE);

  // --- RMS ACCUMULATION (from analyzed channels) ---
  rms_acc[0] += L_analyzed  * L_analyzed;
  rms_acc[1] += R_analyzed  * R_analyzed;
  rms_acc[2] += C_analyzed  * C_analyzed;
  rms_acc[3] += Ls_analyzed * Ls_analyzed;
  rms_acc[4] += Rs_analyzed * Rs_analyzed;
  lfe_rms_acc[0] += LFE_analyzed * LFE_analyzed;

  // --- LUFS (Cockos/REAPER: K-weighted from analyzed channels) ---
  // Apply K-weighting filters to analyzed channels
  
  // Channel 0: L (analyzed)
  kw_in = L_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[0] + kw_b2_hp * kw_z2[0] - kw_a1_hp * kw_z1[1] - kw_a2_hp * kw_z2[1];
  kw_z2[0] = kw_z1[0]; kw_z1[0] = kw_in;
  kw_z2[1] = kw_z1[1]; kw_z1[1] = kw_out;
  kw_in = kw_out;
  kw_L = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[2] + kw_b2_hs * kw_z2[2] - kw_a1_hs * kw_z1[3] - kw_a2_hs * kw_z2[3];
  kw_z2[2] = kw_z1[2]; kw_z1[2] = kw_in;
  kw_z2[3] = kw_z1[3]; kw_z1[3] = kw_L;
  
  // Channel 1: R (analyzed)
  kw_in = R_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[4] + kw_b2_hp * kw_z2[4] - kw_a1_hp * kw_z1[5] - kw_a2_hp * kw_z2[5];
  kw_z2[4] = kw_z1[4]; kw_z1[4] = kw_in;
  kw_z2[5] = kw_z1[5]; kw_z1[5] = kw_out;
  kw_in = kw_out;
  kw_R = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[6] + kw_b2_hs * kw_z2[6] - kw_a1_hs * kw_z1[7] - kw_a2_hs * kw_z2[7];
  kw_z2[6] = kw_z1[6]; kw_z1[6] = kw_in;
  kw_z2[7] = kw_z1[7]; kw_z1[7] = kw_R;
  
  // Channel 2: C (analyzed)
  kw_in = C_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[8] + kw_b2_hp * kw_z2[8] - kw_a1_hp * kw_z1[9] - kw_a2_hp * kw_z2[9];
  kw_z2[8] = kw_z1[8]; kw_z1[8] = kw_in;
  kw_z2[9] = kw_z1[9]; kw_z1[9] = kw_out;
  kw_in = kw_out;
  kw_C = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[10] + kw_b2_hs * kw_z2[10] - kw_a1_hs * kw_z1[11] - kw_a2_hs * kw_z2[11];
  kw_z2[10] = kw_z1[10]; kw_z1[10] = kw_in;
  kw_z2[11] = kw_z1[11]; kw_z1[11] = kw_C;
  
  // Channel 3: Ls (analyzed)
  kw_in = Ls_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[12] + kw_b2_hp * kw_z2[12] - kw_a1_hp * kw_z1[13] - kw_a2_hp * kw_z2[13];
  kw_z2[12] = kw_z1[12]; kw_z1[12] = kw_in;
  kw_z2[13] = kw_z1[13]; kw_z1[13] = kw_out;
  kw_in = kw_out;
  kw_Ls = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[14] + kw_b2_hs * kw_z2[14] - kw_a1_hs * kw_z1[15] - kw_a2_hs * kw_z2[15];
  kw_z2[14] = kw_z1[14]; kw_z1[14] = kw_in;
  kw_z2[15] = kw_z1[15]; kw_z1[15] = kw_Ls;
  
  // Channel 4: Rs (analyzed)
  kw_in = Rs_analyzed;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[16] + kw_b2_hp * kw_z2[16] - kw_a1_hp * kw_z1[17] - kw_a2_hp * kw_z2[17];
  kw_z2[16] = kw_z1[16]; kw_z1[16] = kw_in;
  kw_z2[17] = kw_z1[17]; kw_z1[17] = kw_out;
  kw_in = kw_out;
  kw_Rs = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[18] + kw_b2_hs * kw_z2[18] - kw_a1_hs * kw_z1[19] - kw_a2_hs * kw_z2[19];
  kw_z2[18] = kw_z1[18]; kw_z1[18] = kw_in;
  kw_z2[19] = kw_z1[19]; kw_z1[19] = kw_Rs;
  
  // Cockos/REAPER weights (LUFS): L, R, C = 1.0; Ls/Rs = √2 (power * 1.7)
  // Power calculation with K-weighted samples: z[n] = L² + R² + C² + 1.7*Ls² + 1.7*Rs²
  // LFE not included in loudness measurement
  // Weighted mean square using K-weighted samples
  lufs_ms = kw_L*kw_L + kw_R*kw_R + kw_C*kw_C + 1.7*kw_Ls*kw_Ls + 1.7*kw_Rs*kw_Rs;

  // Cockos-style LUFS windowing (momentary/short/integrated with gating)
  lufs_win_acc += lufs_ms;
  (lufs_win_pos += 1) >= lufs_win_len ? (
    lufs_win_pos = 0;
    lufs_win_cnt += 1;
    lval = lufs_win_acc;
    lufs_win_acc = 0;

    prev_lval = lufs_buf[lufs_cur_buf];
    lufs_buf[lufs_cur_buf] = lval;
    lufs_cur_buf += 1;
    lufs_cur_buf >= lufs_m_win_cnt ? lufs_cur_buf = 0;

    prev_lval2 = lufs_buf2[lufs_cur_buf2];
    lufs_buf2[lufs_cur_buf2] = lval;
    lufs_cur_buf2 += 1;
    lufs_cur_buf2 >= lufs_s_win_cnt ? lufs_cur_buf2 = 0;

    lufs_m_sum += (lval - prev_lval) * lufs_i_win_len;
    lufs_s_sum += (lval - prev_lval2) * lufs_i_win_len2;

    lufs_m_sum > 0 && lufs_win_cnt >= lufs_m_win_cnt ? (
      lufs_m_db = 0.8 + log(lufs_m_sum) * 10 / log(10);

      a = ((lufs_m_db + 70) * BINS_PER_DB) | 0;
      a >= 0 ? (
        a >= NUM_BINS ? a = NUM_BINS - 1;
        lufs_a_sum += lufs_m_sum;
        lufs_a_sum_cnt += 1;
        lufs_a_hist[2 * a] += 1;
        lufs_a_hist[2 * a + 1] += lufs_m_sum;

        lufs_a_db = 0.8 + log(lufs_a_sum / lufs_a_sum_cnt) * 10 / log(10);
        lufs_a_gate = ((lufs_a_db - 10 + 70) * BINS_PER_DB) | 0;

        lufs_i_sum = 0;
        lufs_i_cnt = 0;
        bin = max(lufs_a_gate, 0);
        loop(NUM_BINS - bin,
          lufs_i_cnt += lufs_a_hist[2 * bin];
          lufs_i_sum += lufs_a_hist[2 * bin + 1];
          bin += 1;
        );
        lufs_i_db = lufs_i_sum > 0 ? 0.8 + log(lufs_i_sum / lufs_i_cnt) * 10 / log(10) : -100;
      );
    );

    lufs_s_sum > 0 && lufs_win_cnt >= lufs_s_win_cnt ? (
      lufs_s_db = 0.8 + log(lufs_s_sum) * 10 / log(10);
    );

    lufs_mom = lufs_m_db;
    lufs_short = lufs_s_db;
    lufs_int = lufs_i_db;
  );

  // Smooth LUFS display to avoid strobing
  // Momentary (400ms window) - fastest response
  lufs_mom_disp = lufs_mom_disp * 0.95 + lufs_mom * 0.05;
  // Short-term (3s window) - medium response
  lufs_short_disp = lufs_short_disp * 0.98 + lufs_short * 0.02;
  // Integrated (continuous) - slowest, most stable
  lufs_int_disp = lufs_int_disp * 0.995 + lufs_int * 0.005;

  // --- PHASE CORRELATION ACCUMULATION (10 pairs from analyzed channels) ---
  // Pair 0: L-R
  phase_sum_ab[0] += L_analyzed * R_analyzed;
  phase_sum_a2[0] += L_analyzed * L_analyzed;
  phase_sum_b2[0] += R_analyzed * R_analyzed;
  // Pair 1: L-C
  phase_sum_ab[1] += L_analyzed * C_analyzed;
  phase_sum_a2[1] += L_analyzed * L_analyzed;
  phase_sum_b2[1] += C_analyzed * C_analyzed;
  // Pair 2: L-Ls
  phase_sum_ab[2] += L_analyzed * Ls_analyzed;
  phase_sum_a2[2] += L_analyzed * L_analyzed;
  phase_sum_b2[2] += Ls_analyzed * Ls_analyzed;
  // Pair 3: L-Rs
  phase_sum_ab[3] += L_analyzed * Rs_analyzed;
  phase_sum_a2[3] += L_analyzed * L_analyzed;
  phase_sum_b2[3] += Rs_analyzed * Rs_analyzed;
  // Pair 4: R-C
  phase_sum_ab[4] += R_analyzed * C_analyzed;
  phase_sum_a2[4] += R_analyzed * R_analyzed;
  phase_sum_b2[4] += C_analyzed * C_analyzed;
  // Pair 5: R-Ls
  phase_sum_ab[5] += R_analyzed * Ls_analyzed;
  phase_sum_a2[5] += R_analyzed * R_analyzed;
  phase_sum_b2[5] += Ls_analyzed * Ls_analyzed;
  // Pair 6: R-Rs
  phase_sum_ab[6] += R_analyzed * Rs_analyzed;
  phase_sum_a2[6] += R_analyzed * R_analyzed;
  phase_sum_b2[6] += Rs_analyzed * Rs_analyzed;
  // Pair 7: C-Ls
  phase_sum_ab[7] += C_analyzed * Ls_analyzed;
  phase_sum_a2[7] += C_analyzed * C_analyzed;
  phase_sum_b2[7] += Ls_analyzed * Ls_analyzed;
  // Pair 8: C-Rs
  phase_sum_ab[8] += C_analyzed * Rs_analyzed;
  phase_sum_a2[8] += C_analyzed * C_analyzed;
  phase_sum_b2[8] += Rs_analyzed * Rs_analyzed;
  // Pair 9: Ls-Rs
  phase_sum_ab[9] += Ls_analyzed * Rs_analyzed;
  phase_sum_a2[9] += Ls_analyzed * Ls_analyzed;
  phase_sum_b2[9] += Rs_analyzed * Rs_analyzed;

  // --- GONIOMETER SAMPLE BUFFER (from analyzed channels) ---
  // Store selected channel pair based on gonio_pair slider
  gw = gonio_write[0];
  gonio_pair == 0 ? (  // L-R
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = R_analyzed;
  ) : gonio_pair == 1 ? (  // L-C
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = C_analyzed;
  ) : gonio_pair == 2 ? (  // L-Ls
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 3 ? (  // L-Rs
    GONIO_BUF[gw * 2]     = L_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : gonio_pair == 4 ? (  // R-C
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = C_analyzed;
  ) : gonio_pair == 5 ? (  // R-Ls
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 6 ? (  // R-Rs
    GONIO_BUF[gw * 2]     = R_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : gonio_pair == 7 ? (  // C-Ls
    GONIO_BUF[gw * 2]     = C_analyzed;
    GONIO_BUF[gw * 2 + 1] = Ls_analyzed;
  ) : gonio_pair == 8 ? (  // C-Rs
    GONIO_BUF[gw * 2]     = C_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  ) : (  // 9: Ls-Rs
    GONIO_BUF[gw * 2]     = Ls_analyzed;
    GONIO_BUF[gw * 2 + 1] = Rs_analyzed;
  );
  gw += 1;
  gw >= GONIO_SIZE ? gw = 0;
  gonio_write[0] = gw;

  // --- 5.1 SURROUND GONIOMETER BUFFER (from analyzed channels) ---
  sw = surr_write[0];
  SURR_BUF[sw * 5]     = L_analyzed;
  SURR_BUF[sw * 5 + 1] = R_analyzed;
  SURR_BUF[sw * 5 + 2] = C_analyzed;
  SURR_BUF[sw * 5 + 3] = Ls_analyzed;
  SURR_BUF[sw * 5 + 4] = Rs_analyzed;
  sw += 1;
  sw >= SURR_SIZE ? sw = 0;
  surr_write[0] = sw;

  // --- PERIODIC RMS + PHASE COMPUTATION ---
  rms_counter[0] += 1;
  rms_counter[0] >= RMS_WINDOW ? (
    inv_n = 1.0 / RMS_WINDOW;
    s = 0;
    loop(NUM_SPEAKERS,
      rms_level[s] = sqrt(rms_acc[s] * inv_n);
      rms_disp[s] = rms_disp[s] * 0.7 + rms_level[s] * 0.3;
      rms_acc[s] = 0;
      s += 1;
    );
    lfe_rms[0] = sqrt(lfe_rms_acc[0] * inv_n);
    lfe_rms_acc[0] = 0;

    p = 0;
    loop(NUM_PHASE_PAIRS,
      denom = sqrt(phase_sum_a2[p] * phase_sum_b2[p]);
      denom > 0.00001 ? (
        phase_corr[p] = phase_sum_ab[p] / denom;
      ) : (
        phase_corr[p] = 0;
      );
      phase_smooth[p] = phase_smooth[p] * 0.7 + phase_corr[p] * 0.3;
      phase_sum_ab[p] = 0;
      phase_sum_a2[p] = 0;
      phase_sum_b2[p] = 0;
      p += 1;
    );
    rms_counter[0] = 0;
  );

  // === STEP 4: OUTPUT (binary panorama enable from slider2) ===
  // slider2=0 (Original): pass through original audio unchanged
  // slider2=1 (Panorama Active): use rotated audio
  // slider3: chooses panning mode (0=VBAP clean, 1=Amplitude bleed)
  // Binary selection to avoid phase cancellation from mixing
  panorama_enable == 1 ? (
    spl0 = L_rotated;
    spl1 = R_rotated;
    spl2 = C_rotated;
    spl3 = in_LFE;  // LFE not rotated
    spl4 = Ls_rotated;
    spl5 = Rs_rotated;
  ) : (
    spl0 = in_L;
    spl1 = in_R;
    spl2 = in_C;
    spl3 = in_LFE;
    spl4 = in_Ls;
    spl5 = in_Rs;
  );

// ======================================================================
// @gfx — Drawing
// ======================================================================
@gfx 640 520

  // --- COLOR PALETTE ---
  bg_r = 0.10; bg_g = 0.10; bg_b = 0.12;
  pnl_r = 0.07; pnl_g = 0.07; pnl_b = 0.08;
  brd_r = 0.149; brd_g = 0.149; brd_b = 0.173;
  acc_r = 0.20; acc_g = 0.80; acc_b = 0.40;
  mtr_r = 0.15; mtr_g = 0.65; mtr_b = 0.35;
  txt_r = 0.80; txt_g = 0.80; txt_b = 0.80;

  // --- BUFFER RESIZE ---
  (gfx_w != last_w || gfx_h != last_h) ? (
    last_w = gfx_w;
    last_h = gfx_h;
    gfx_setimgdim(HEAT_BUFFER, GRID_W, GRID_H);
    gfx_dest = HEAT_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, GRID_W, GRID_H);
    gfx_dest = -1;

    gfx_setimgdim(GONIO_BUFFER, 256, 256);
    gfx_dest = GONIO_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, 256, 256);
    gfx_dest = -1;

    gfx_setimgdim(SURR_BUFFER, GRID_W, GRID_H);
    gfx_dest = SURR_BUFFER;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, GRID_W, GRID_H);
    gfx_dest = -1;
  );

  // --- FONT SETUP ---
  sc = min(gfx_w / 640, gfx_h / 520);
  sc < 0.5 ? sc = 0.5;
  sc > 2.0 ? sc = 2.0;
  font_sm  = max(10, (11 * sc)|0);
  font_md  = max(11, (13 * sc)|0);
  font_lg  = max(13, (16 * sc)|0);
  gfx_setfont(1, "Arial", font_lg, 'b');
  gfx_setfont(2, "Arial", font_md);
  gfx_setfont(3, "Arial", font_sm);

  // Synchronize listener rotation for display
  listener_rotation = slider1 * ($pi / 180.0);

  // COMPACT mode: force hide all sliders
  ui_mode == 1 ? (
    sliders_showing = 0;
    slider_show(UI_SLIDERS_MASK, 0);
  );

  // --- LAYOUT ---
  title_h = max(26, (30 * sc)|0);
  phase_h = max(44, (55 * sc)|0);
  lfe_h   = max(24, (30 * sc)|0);
  pad     = max(8,  (12 * sc)|0);

  field_top  = title_h + pad;
  field_bot  = gfx_h - phase_h - lfe_h - pad * 2;
  field_left = pad;
  field_right = gfx_w - pad;
  field_w = field_right - field_left;
  field_h = field_bot - field_top;

  legend_w = max(18, (26 * sc)|0);
  legend_gap = max(6, (10 * sc)|0);
  meter_panel_w = max(100, (130 * sc)|0);
  meter_panel_gap = max(6, (10 * sc)|0);

  main_w = field_w - legend_w - legend_gap - meter_panel_gap - meter_panel_w;
  main_w < 100 ? main_w = 100;
  field_size = min(main_w, field_h);
  field_size < 100 ? field_size = 100;
  
  field_x0 = field_left + legend_w + legend_gap + (main_w - field_size) * 0.5;
  field_y0 = field_top + (field_h - field_size) * 0.5;
  
  // Goniometer with proper sizing and positioning to avoid overlap
  display_mode == 1 ? (
    // Goniometer same size and position as heat map (centered)
    gon_size = field_size;
  ) : (
    // Heat map: center normally with padding
    field_x0 = max(field_x0, field_left + pad);
    field_y0 = max(field_y0, field_top + pad);
  );

  phase_top = gfx_h - phase_h - lfe_h - pad;
  lfe_top   = gfx_h - lfe_h - (pad * 0.5);

  // =====================================================
  // BACKGROUND
  // =====================================================
  gfx_set(bg_r, bg_g, bg_b, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);

  // --- TITLE BAR ---
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(0, 0, gfx_w, title_h);
  gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_line(0, title_h, gfx_w, title_h);

  gfx_setfont(1);
  gfx_set(acc_r, acc_g, acc_b, 1);
  gfx_x = pad; gfx_y = (title_h - font_lg) * 0.5;
  gfx_drawstr("SBP SURROUND SCOPE 5.1");

  // Mode buttons after title
  title_end_x = gfx_x;
  btn_gap = max(10, (12 * sc)|0);
  btn_h = max(18, (20 * sc)|0);
  btn_y = (title_h -btn_h) * 0.5;
  gfx_setfont(4);
  
  // Sound Field button
  #btn1_text = "SOUND FIELD";
  gfx_measurestr(#btn1_text, btn1_w, btn1_h);
  btn1_w += max(8, (12 * sc)|0);
  btn1_x = title_end_x + btn_gap;
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h);
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h, 0);
  display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn1_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn1_h) * 0.5;
  gfx_drawstr(#btn1_text);
  
  // Goniometer button
  #btn2_text = "GONIOMETER";
  gfx_measurestr(#btn2_text, btn2_w, btn2_h);
  btn2_w += max(8, (12 * sc)|0);
  btn2_x = btn1_x + btn1_w + max(4, (6 * sc)|0);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h, 0);
  display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn2_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn2_h) * 0.5;
  gfx_drawstr(#btn2_text);
  
  // Compact View button on the right
  #btn3_text = ui_mode == 0 ? "COMPACT" : "FULL UI";
  gfx_measurestr(#btn3_text, btn3_w, btn3_h);
  btn3_w += max(8, (12 * sc)|0);
  btn3_x = gfx_w - pad - btn3_w;
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h, 0);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn3_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn3_h) * 0.5;
  gfx_drawstr(#btn3_text);
  
  // Show goniometer pair label in compact mode
  display_mode == 1 && ui_mode == 1 ? (
    gfx_set(txt_r, txt_g, txt_b, 0.4);
    gonio_pair == 0 ? #pair_str = "L-R" :
    gonio_pair == 1 ? #pair_str = "L-C" :
    gonio_pair == 2 ? #pair_str = "L-Ls" :
    gonio_pair == 3 ? #pair_str = "L-Rs" :
    gonio_pair == 4 ? #pair_str = "R-C" :
    gonio_pair == 5 ? #pair_str = "R-Ls" :
    gonio_pair == 6 ? #pair_str = "R-Rs" :
    gonio_pair == 7 ? #pair_str = "C-Ls" :
    gonio_pair == 8 ? #pair_str = "C-Rs" :
                      #pair_str = "Ls-Rs";
    sprintf(#mode_str, "[%s]", #pair_str);
    gfx_measurestr(#mode_str, mw, mh);
    gfx_x = btn3_x - btn_gap - mw;
    gfx_y = (title_h - mh) * 0.5;
    gfx_drawstr(#mode_str);
  );
  
  // =====================================================
  // MOUSE INTERACTION - Title Bar Buttons
  // =====================================================
  mouse_clicked_ui = 0;  // Reset each frame
  
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    // Sound Field button
    mouse_x >= btn1_x && mouse_x <= btn1_x + btn1_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider4 = 0;
      display_mode = 0;
      sliderchange(slider4);
      mouse_clicked_ui = 1;
    ) : 
    // Goniometer button
    mouse_x >= btn2_x && mouse_x <= btn2_x + btn2_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider4 = 1;
      display_mode = 1;
      sliderchange(slider4);
      mouse_clicked_ui = 1;
    ) : 
    // Compact/Full UI button - toggle slider visibility
    mouse_x >= btn3_x && mouse_x <= btn3_x + btn3_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider6 = 1 - slider6;
      ui_mode = slider6;
      sliders_showing = slider_show(UI_SLIDERS_MASK, slider6 ? 0 : 1) > 0;
      sliderchange(slider6);
      mouse_clicked_ui = 1;
    );
  );

  // =====================================================
  // HEAT MAP (Display Mode 0 or 2)
  // =====================================================
  display_mode == 0 ? (

    // Reset current peak and min for this frame
    heatmap_peak[0] = 0;
    heatmap_min[0] = 1.0;

    // Determine heat map field size and reserve space for legend + meters
    hm_size = field_size;
    hm_x0 = field_x0;
    hm_y0 = field_y0;
    legend_x0 = field_x0 - legend_gap - legend_w;
    legend_y0 = field_y0;
    legend_h = hm_size;

    // --- DECAY HEAT MAP BUFFER ---
    gfx_dest = HEAT_BUFFER;
    gfx_muladdrect(0, 0, GRID_W, GRID_H,
      decay_factor, decay_factor, decay_factor, 1.0,
      0, 0, 0, 0
    );

    // --- UPDATE HEAT MAP ---
    gfx_mode = 1; // additive blending
    
    // Heat map uses ORIGINAL speaker positions (not rotated visualization)
    // The rotated AUDIO will naturally show up in different places on the static visualization
    
    // Reset phantom center accumulators
    phantom_x = 0;
    phantom_y = 0;
    total_weight = 0;
    
    cell = 0;
    gy = 0;
    loop(GRID_H,
      gx = 0;
      loop(GRID_W,
        cx = (gx + 0.5) / GRID_W;
        cy = (gy + 0.5) / GRID_H;
        
        val = 0;
        total_w = 0;
        s = 0;
        loop(NUM_SPEAKERS,
          // Use ORIGINAL speaker positions (visualization does NOT rotate)
          dx = cx - spk_x[s];
          dy = cy - spk_y[s];
          dist_sq = dx * dx + dy * dy + 0.0001;
          
          // Weight using rotated positions
          w = exp(-dist_sq * 8.0);  // decay_coeff = 8.0
          val += heatmap_energy[s] * w;
          total_w += w;
          s += 1;
        );
        
        // Normalize weights
        total_w > 0.0001 ? (
          val /= total_w;
        );
        val *= sensitivity * 10.0;

        // Optional dB scaling with locked floor
        heatmap_lock_floor > 0.5 ? (
          floor_db = -60.0;
          val_db = 20.0 * log(max(val, 0.000001)) / log(10);
          val = (val_db - floor_db) / (0.0 - floor_db);
        );

        val = max(0.0, min(val, 1.0));
        
        // Softer contrast curve - less aggressive power curve
        // Old: val = val * val produces too much contrast
        // New: more linear in low range, slight curve in high range
        val < 0.5 ? (
          val = val * 0.8;  // Soften low values: 0..0.5 -> 0..0.4
        ) : (
          val = 0.4 + (val - 0.5) * 1.2;  // Slight boost in high range
        );

        val > 0.0015 ? (  // Lower threshold to show more detail
          // Track peak and minimum (only in active range above 5%)
          val > heatmap_peak[0] ? heatmap_peak[0] = val;
          val > 0.05 && val < heatmap_min[0] ? heatmap_min[0] = val;  // Min only for audible content
          
          // Accumulate phantom center (while val is fresh)
          val > 0.05 ? (
            nx = gx / (GRID_W - 1);
            ny = gy / (GRID_H - 1);
            weight = val * val;
            phantom_x += nx * weight;
            phantom_y += ny * weight;
            total_weight += weight;
          );
          
          // Apply color scheme
          get_color(val, color_scheme, cr, cg, cb);
          
          // Apply brightness - simple linear scaling
          cr = min(1.0, cr * heatmap_brightness);
          cg = min(1.0, cg * heatmap_brightness);
          cb = min(1.0, cb * heatmap_brightness);

          gfx_x = gx;
          gfx_y = gy;
          gfx_setpixel(cr, cg, cb);
        );

        cell += 1;
        gx += 1;
      );
      gy += 1;
    );
    gfx_mode = 0;
    gfx_dest = -1;

    // --- FINALIZE PHANTOM CENTER ---
    total_weight > 0.001 ? (
      phantom_x /= total_weight;
      phantom_y /= total_weight;
      
      // Smooth phantom center movement (controllable via slider)
      phantom_center_x[0] = phantom_center_x[0] * phantom_smoothing + phantom_x * (1.0 - phantom_smoothing);
      phantom_center_y[0] = phantom_center_y[0] * phantom_smoothing + phantom_y * (1.0 - phantom_smoothing);
    ) : (
      // Default to listener position if no energy
      slow_return = min(0.95, phantom_smoothing + 0.1);
      phantom_center_x[0] = phantom_center_x[0] * slow_return + listen_x * (1.0 - slow_return);
      phantom_center_y[0] = phantom_center_y[0] * slow_return + listen_y * (1.0 - slow_return);
    );
    
    // Output phantom center coordinates to sliders for automation
    slider18 = phantom_center_x[0];
    slider19 = phantom_center_y[0];
    sliderchange(slider18 | slider19);

    // Update peak hold and min hold with decay (speed depends on meter mode)
    // Peak: fast, RMS: medium, LUFS: slow
    decay_speed = meter_mode == 0 ? 0.99 : meter_mode == 1 ? 0.995 : 0.998;
    
    heatmap_peak[0] > heatmap_peak_hold[0] ? heatmap_peak_hold[0] = heatmap_peak[0];
    heatmap_peak_hold[0] *= decay_speed;
    
    heatmap_min[0] < heatmap_min_hold[0] ? heatmap_min_hold[0] = heatmap_min[0];
    heatmap_min_hold[0] = heatmap_min_hold[0] * decay_speed + heatmap_min[0] * (1.0 - decay_speed);

    // --- FIELD BACKGROUND ---
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(hm_x0, hm_y0, hm_size, hm_size);

    // --- BLIT HEAT MAP ---
    gfx_blit(HEAT_BUFFER, 1, 0,
      0, 0, GRID_W, GRID_H,
      hm_x0, hm_y0, hm_size, hm_size
    );

    // --- PHANTOM CENTER MARKER ---
    // Use smoothed position for stable visualization
    pcx = hm_x0 + phantom_center_x[0] * hm_size;
    pcy = hm_y0 + phantom_center_y[0] * hm_size;
    
    // Draw circle with cross marker (doubled size)
    marker_r = max(12, (16 * sc)|0);
    
    // Outer circle (dark outline)
    gfx_set(0.0, 0.0, 0.0, 0.8);
    gfx_circle(pcx, pcy, marker_r + 1, 0, 1);
    
    // Inner circle (bright accent)
    gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 0.9);
    gfx_circle(pcx, pcy, marker_r, 0, 1);
    
    // Cross lines
    gfx_set(1.0, 1.0, 1.0, 0.9);
    cross_len = marker_r * 0.6;
    gfx_line(pcx - cross_len, pcy, pcx + cross_len, pcy);
    gfx_line(pcx, pcy - cross_len, pcx, pcy + cross_len);
    
    // Center dot
    gfx_circle(pcx, pcy, 1.5, 1, 1);

    // --- SPEAKER ICONS + LABELS + EXPANDING WAVE RINGS ---
    // (Drawn before outside mask so wave rings are properly clipped)
    s = 0;
    loop(NUM_SPEAKERS,
      sx = hm_x0 + spk_x[s] * hm_size;
      sy = hm_y0 + spk_y[s] * hm_size;

      e = energy[s] * sensitivity * 4.0;
      e = min(e, 1.0);
      
      // Expanding wave rings with decay animation (clipped to heat map bounds)
      wave_rings_vis > 0.01 ? (
        // Draw 4 expanding wave rings from energy history with bigger size and brighter
        ring = 0;
        loop(4,
          // Base ring radius - increased for better visibility
          base_r = 12 + (e * 35);  // Was: 6 + (e * 22)
          ring_r = base_r + ring * 10;  // Each ring is spaced 10 pixels apart (was 6)
          
          // Opacity - brighter for better visibility
          opacity_ring = e * wave_rings_vis * pow(0.7, ring) * 1.5;  // Added 1.5x multiplier
          opacity_ring = min(opacity_ring, 0.9);  // Cap at 0.9
          opacity_ring > 0.01 ? (
            // Draw circle segments that stay within heat map bounds
            // Draw full circle only if center + radius is inside bounds
            (sx >= hm_x0 + ring_r && sx <= hm_x0 + hm_size - ring_r &&
             sy >= hm_y0 + ring_r && sy <= hm_y0 + hm_size - ring_r) ? (
              gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, opacity_ring);  // Brighter color
              gfx_circle(sx, sy, ring_r, 0);  // Draw outline only
            );
          );
          
          ring += 1;
        );
      );

      s += 1;
    );

    // --- DARKEN AREA OUTSIDE THEATER ---
    // Darken area outside theater (controlled by slider)
    outside_mask > 0.5 ? (
      gfx_mode = 0;  // Normal blending
      gfx_set(0.02, 0.02, 0.03, 1.0);
      
      // Cinema trapezoid: darken all outside areas
      trap_top_w = hm_size * 0.6;
      trap_bot_w = hm_size * 0.9;
      trap_h_val = hm_size * 0.7;
      trap_cx = hm_x0 + hm_size * 0.5;
      trap_top_y = hm_y0 + hm_size * 0.15;
      trap_bot_y = trap_top_y + trap_h_val;
      
      trap_tl_x = trap_cx - trap_top_w * 0.5;  // Top-left X
      trap_tr_x = trap_cx + trap_top_w * 0.5;  // Top-right X
      trap_bl_x = trap_cx - trap_bot_w * 0.5;  // Bottom-left X
      trap_br_x = trap_cx + trap_bot_w * 0.5;  // Bottom-right X
      
      // Darken top rectangle
      gfx_rect(hm_x0, hm_y0, hm_size, trap_top_y - hm_y0);
      // Darken bottom rectangle
      gfx_rect(hm_x0, trap_bot_y, hm_size, hm_y0 + hm_size - trap_bot_y);
      
      // Left side area (slanted)
      gfx_triangle(hm_x0, trap_top_y, trap_tl_x, trap_top_y, hm_x0, trap_bot_y);
      gfx_triangle(trap_tl_x, trap_top_y, trap_bl_x, trap_bot_y, hm_x0, trap_bot_y);
      
      // Right side area (slanted)
      gfx_triangle(trap_tr_x, trap_top_y, hm_x0 + hm_size, trap_top_y, hm_x0 + hm_size, trap_bot_y);
      gfx_triangle(trap_tr_x, trap_top_y, hm_x0 + hm_size, trap_bot_y, trap_br_x, trap_bot_y);
    );

    // --- WAVE RINGS FOR REAR SPEAKERS (drawn after mask to prevent dimming) ---
    wave_rings_vis > 0.01 ? (
      // Draw rear speaker wave rings (Ls=3, Rs=4)
      rear_spks = 0;
      loop(2,
        spk_idx = rear_spks == 0 ? 3 : 4;  // Ls or Rs
        sx = hm_x0 + spk_x[spk_idx] * hm_size;
        sy = hm_y0 + spk_y[spk_idx] * hm_size;
        e = energy[spk_idx] * sensitivity;
        e = min(e, 1.0);
        
        ring = 0;
        loop(4,
          base_r = 12 + (e * 35);
          ring_r = base_r + ring * 10;
          opacity_ring = e * wave_rings_vis * pow(0.7, ring) * 1.5;
          opacity_ring = min(opacity_ring, 0.9);
          opacity_ring > 0.01 ? (
            gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, opacity_ring);
            gfx_circle(sx, sy, ring_r, 0);
          );
          ring += 1;
        );
        rear_spks += 1;
      );
    );

    // --- SPEAKER ICONS AND LABELS (drawn AFTER mask) ---
    s = 0;
    loop(NUM_SPEAKERS,
      sx = hm_x0 + spk_x[s] * hm_size;
      sy = hm_y0 + spk_y[s] * hm_size;

      // Speaker dot (20% bigger)
      gfx_set(0.85, 0.85, 0.85, 0.9);
      gfx_circle(sx, sy, 4.8 * sc, 1);
      // Dot border
      gfx_set(acc_r, acc_g, acc_b, 0.7);
      gfx_circle(sx, sy, 4.8 * sc, 0);

      // Label
      gfx_setfont(2);
      gfx_set(1.0, 1.0, 1.0, 0.85);
      s == 0 ? ( gfx_x = sx - 18 * sc; gfx_y = sy - 18 * sc; gfx_drawstr("L"); );
      s == 1 ? ( gfx_x = sx + 10 * sc;  gfx_y = sy - 18 * sc; gfx_drawstr("R"); );
      s == 2 ? ( gfx_x = sx - 3 * sc;  gfx_y = sy - 18 * sc; gfx_drawstr("C"); );
      s == 3 ? ( gfx_x = sx - 20 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("Ls"); );
      s == 4 ? ( gfx_x = sx + 8 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("Rs"); );

      s += 1;
    );

    // --- ROOM OUTLINE ---
    gfx_set(brd_r, brd_g, brd_b, 0.6);

    // Cinema trapezoid
    trap_top_w = hm_size * 0.6;
    trap_bot_w = hm_size * 0.9;
    trap_h_val = hm_size * 0.7;
    trap_cx = hm_x0 + hm_size * 0.5;
    trap_top_y = hm_y0 + hm_size * 0.15;
    trap_bot_y = trap_top_y + trap_h_val;
    gfx_line(trap_cx - trap_top_w * 0.5, trap_top_y, trap_cx + trap_top_w * 0.5, trap_top_y);
    gfx_line(trap_cx + trap_top_w * 0.5, trap_top_y, trap_cx + trap_bot_w * 0.5, trap_bot_y);
    gfx_line(trap_cx + trap_bot_w * 0.5, trap_bot_y, trap_cx - trap_bot_w * 0.5, trap_bot_y);
    gfx_line(trap_cx - trap_bot_w * 0.5, trap_bot_y, trap_cx - trap_top_w * 0.5, trap_top_y);

    // --- GRID ---
    show_grid ? (
      lx = hm_x0 + listen_x * hm_size;
      ly = hm_y0 + listen_y * hm_size;
      gfx_set(brd_r, brd_g, brd_b, 0.15);
      gfx_line(lx, hm_y0, lx, hm_y0 + hm_size);
      gfx_line(hm_x0, ly, hm_x0 + hm_size, ly);
      gfx_set(brd_r, brd_g, brd_b, 0.10);
      gfx_circle(lx, ly, hm_size * 0.15, 0);
      gfx_circle(lx, ly, hm_size * 0.30, 0);
    );

    // --- HEAT MAP LEGEND (LEFT) ---
    legend_pad = max(4, (6 * sc)|0);
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(legend_x0, legend_y0, legend_w, legend_h);
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    gfx_line(legend_x0, legend_y0, legend_x0 + legend_w, legend_y0);
    gfx_line(legend_x0, legend_y0 + legend_h, legend_x0 + legend_w, legend_y0 + legend_h);
    gfx_line(legend_x0, legend_y0, legend_x0, legend_y0 + legend_h);
    gfx_line(legend_x0 + legend_w, legend_y0, legend_x0 + legend_w, legend_y0 + legend_h);

    steps = 48;
    j = 0;
    loop(steps,
      v = j / (steps - 1);
      get_color(v, color_scheme, cr, cg, cb);
      // Legend shows full saturation colors (independent of brightness slider)
      gfx_set(cr, cg, cb, 1.0);
      ly = legend_y0 + (1.0 - v) * legend_h;
      gfx_rect(legend_x0 + legend_pad, ly, legend_w - legend_pad * 2, (legend_h / steps) + 1);
      j += 1;
    );

    // --- LRA RANGE INDICATOR ON LEGEND ---
    heatmap_peak_hold[0] > 0.001 && heatmap_min_hold[0] < 0.999 ? (
      peak_y = legend_y0 + (1.0 - heatmap_peak_hold[0]) * legend_h;
      min_y = legend_y0 + (1.0 - heatmap_min_hold[0]) * legend_h;
      range_h = min_y - peak_y;
      
      // Draw semi-transparent filled rectangle for LRA range (very light, barely visible)
      gfx_set(1.0, 1.0, 1.0, 0.08);
      gfx_rect(legend_x0, peak_y, legend_w, range_h);
      
      // Draw border lines
      gfx_set(1.0, 1.0, 1.0, 0.8);
      gfx_line(legend_x0, peak_y, legend_x0 + legend_w, peak_y);
      gfx_line(legend_x0, min_y, legend_x0 + legend_w, min_y);
      
      // Draw small triangular markers on right edge
      gfx_triangle(legend_x0 + legend_w, peak_y,
                   legend_x0 + legend_w + 4, peak_y - 3,
                   legend_x0 + legend_w + 4, peak_y + 3);
      gfx_triangle(legend_x0 + legend_w, min_y,
                   legend_x0 + legend_w + 4, min_y - 3,
                   legend_x0 + legend_w + 4, min_y + 3);
      
      // Display LRA value (range in percentage)
      lra_val = (heatmap_peak_hold[0] - heatmap_min_hold[0]) * 100;
      sprintf(#lra_str, "%.0f%%", lra_val);
      gfx_setfont(3);
      gfx_set(1.0, 1.0, 1.0, 0.9);
      gfx_measurestr(#lra_str, lw, lh);
      gfx_x = legend_x0 + legend_w + 8;
      gfx_y = peak_y + (range_h - lh) * 0.5;
      gfx_drawstr(#lra_str);
    );

    // Legend scale labels (dynamic for scale mode)
    gfx_setfont(3);
    floor_db = heatmap_lock_floor > 0.5 ? -60.0 : -120.0;
    step_db = floor_db / 4.0;
    k = 0;
    loop(5,
      label_db = k * step_db;
      k == 0 ? (
        #label_str = "0";
      ) : (
        sprintf(#label_str, "%d", label_db | 0);
      );
      label_y = legend_y0 + (k / 4.0) * legend_h;
      gfx_measurestr(#label_str, lw, lh);
      label_x = legend_x0 + (legend_w - lw) * 0.5;
      // Dark shadow for better contrast on bright colors
      gfx_set(0.1, 0.1, 0.1, 0.9);
      gfx_x = label_x + 1; gfx_y = label_y - lh * 0.5 + 1;
      gfx_drawstr(#label_str);
      // Main text (light)
      gfx_set(txt_r, txt_g, txt_b, 1.0);
      gfx_x = label_x; gfx_y = label_y - lh * 0.5;
      gfx_drawstr(#label_str);
      k += 1;
    );
    
    // Note: LEVELS panel moved to universal section (always visible)
    // Legend complete

    // Listener position
    lx = hm_x0 + listen_x * hm_size;
    ly = hm_y0 + listen_y * hm_size;
    
    // Listener circle (grey dot)
    gfx_set(0.5, 0.5, 0.5, 0.35);
    gfx_circle(lx, ly, 3 * sc, 1);
    gfx_set(0.5, 0.5, 0.5, 0.2);
    gfx_circle(lx, ly, 3 * sc, 0);
    
    // Dragging interaction area (hint circle - shows when hovering)
    mouse_dx = mouse_x - lx;
    mouse_dy = mouse_y - ly;
    mouse_dist = sqrt(mouse_dx * mouse_dx + mouse_dy * mouse_dy);
    drag_radius = max(25, (30 * sc)|0);
    
    mouse_dist < drag_radius ? (
      gfx_set(0.8, 0.6, 0.2, 0.15);
      gfx_circle(lx, ly, drag_radius, 1);
      gfx_set(0.8, 0.6, 0.2, 0.3);
      gfx_circle(lx, ly, drag_radius, 0);
    );
    
    // Listener rotation arrow (pointing to center channel direction)
    // LARGER DRAGGABLE ARROW for better visibility and interaction
    // Range -180° to +180° (0° = up to center, +90° = right, -90° = left)
    // Drag with LMB or RMB to reset to 0°
    arrow_len = max(20, (24 * sc)|0);  // Larger arrow for better visibility
    arrow_angle = -listener_rotation + $pi * 0.5;  // +90° offset so 0° points up (INVERTED)
    arrow_x = lx + arrow_len * cos(arrow_angle);
    arrow_y = ly - arrow_len * sin(arrow_angle);  // Y inverted for screen coords
    
    // Arrow color - brighter when dragging
    dragging_listener ? (
      gfx_set(1.0, 0.8, 0.3, 1.0);
    ) : (
      gfx_set(0.8, 0.6, 0.2, 0.85);
    );
    gfx_line(lx, ly, arrow_x, arrow_y);
    
    // Arrow head (two small lines) 
    arrow_head_len = max(6, (8 * sc)|0);  // Larger arrow head
    arrow_back_angle1 = arrow_angle + 2.88;  // ~165 degrees
    arrow_back_angle2 = arrow_angle - 2.88;  // ~-165 degrees
    gfx_line(arrow_x, arrow_y, 
             arrow_x + arrow_head_len * cos(arrow_back_angle1), 
             arrow_y - arrow_head_len * sin(arrow_back_angle1));
    gfx_line(arrow_x, arrow_y, 
             arrow_x + arrow_head_len * cos(arrow_back_angle2), 
             arrow_y - arrow_head_len * sin(arrow_back_angle2));
    
    // Draggable listener rotation control
    // Start dragging on mouse down (only if UI buttons not clicked)
    !mouse_clicked_ui ? (
      // RIGHT CLICK - Reset rotation to 0 degrees
      mouse_cap & 2 && !(last_mouse_cap & 2) ? (
        slider1 = 0;
        listener_rotation = 0;
        sliderchange(slider1);
      );
      
      // LEFT CLICK - Drag to rotate
      mouse_cap & 1 ? (
        !dragging_listener && mouse_dist < drag_radius ? (
          dragging_listener = 1;
        );
        
        // Update rotation while dragging (INSIDE mouse_cap block!)
        dragging_listener ? (
          // Calculate angle from listener center to mouse
          mouse_angle = atan2(-(mouse_y - ly), mouse_x - lx);  // Y inverted, atan2(y, x)
          // Remove the +90° offset to get actual rotation (INVERTED)
          actual_rotation = -(mouse_angle - $pi * 0.5);
          // Convert to degrees (-180 to +180)
          slider1 = actual_rotation * (180.0 / $pi);
          // Normalize to -180 to +180 range
          slider1 > 180 ? slider1 -= 360;
          slider1 < -180 ? slider1 += 360;
          // Update listener_rotation directly (same as @slider)
          listener_rotation = slider1 * ($pi / 180.0);
          sliderchange(slider1);
        );
      ) : (
        // Stop dragging on mouse up
        dragging_listener = 0;
      );
    );
  );

  // =====================================================
  // GONIOMETER (Display Mode 1 or 2)
  // =====================================================
  display_mode == 1 ? (

    // Center goniometer with a left correlation column (same width as heat map legend)
    corr_w = legend_w;
    corr_gap = legend_gap;
    available_w = field_w - meter_panel_gap - meter_panel_w - corr_w - corr_gap;
    available_h = field_h;
    gon_size = min(available_w, available_h);
    gon_size = max(100, gon_size);
    // Center horizontally and vertically in the space left of the panel
    gon_x0 = field_left + corr_w + corr_gap + (available_w - gon_size) * 0.5;
    gon_y0 = field_top + (available_h - gon_size) * 0.5;

    // Decay goniometer buffer
    gfx_dest = GONIO_BUFFER;
    gon_dec = decay_factor * 0.98; // slightly faster decay for gonio
    gfx_muladdrect(0, 0, 256, 256,
      gon_dec, gon_dec, gon_dec, 1.0,
      0, 0, 0, 0
    );

    // Draw new samples
    gfx_mode = 1; // additive
    gw_cur = gonio_write[0];
    // Draw last N samples (skip some for performance)
    draw_count = min(GONIO_SIZE, (srate / 30)|0); // ~1 frame worth of samples
    idx = gw_cur - draw_count;
    idx < 0 ? idx += GONIO_SIZE;

    i = 0;
    loop(draw_count,
      gl = GONIO_BUF[idx * 2];
      gr = GONIO_BUF[idx * 2 + 1];

      // Mid/Side transform rotated 45 degrees
      gm = (gl + gr) * 0.707;
      gs = (gl - gr) * 0.707;

      // Map to buffer coordinates (center = 128, 128)
      // Separate goniometer sensitivity (decoupled from heat map sensitivity)
      gonio_sensitivity = gonio_sensitivity_user * 2.0;  // base scale
      gs_scaled = (gs * gonio_sensitivity) / (1.0 + abs(gs * gonio_sensitivity));
      gm_scaled = (gm * gonio_sensitivity) / (1.0 + abs(gm * gonio_sensitivity));
      gon_px = 128 + gs_scaled * 127.0;
      gon_py = 128 - gm_scaled * 127.0;
      gon_px = max(0, min(255, gon_px));
      gon_py = max(0, min(255, gon_py));

      // Draw dot
      gfx_x = gon_px;
      gfx_y = gon_py;
      amp = max(abs(gl), abs(gr)) * gonio_sensitivity_user;
      amp = min(amp, 1.0);
      gfx_setpixel(acc_r * amp * 0.8, acc_g * amp * 0.8, acc_b * amp * 0.4);

      idx += 1;
      idx >= GONIO_SIZE ? idx = 0;
      i += 1;
    );

    gfx_mode = 0;
    gfx_dest = -1;

    // Background
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(gon_x0, gon_y0, gon_size, gon_size);

    // Blit
    gfx_blit(GONIO_BUFFER, 1, 0,
      0, 0, 256, 256,
      gon_x0, gon_y0, gon_size, gon_size
    );

    // Reference lines: +45 and -45 degrees (L and R axes)
    gon_cx = gon_x0 + gon_size * 0.5;
    gon_cy = gon_y0 + gon_size * 0.5;
    gfx_set(1.0, 1.0, 1.0, 0.12);
    // Diagonal L axis
    gfx_line(gon_x0, gon_y0, gon_x0 + gon_size, gon_y0 + gon_size);
    // Diagonal R axis
    gfx_line(gon_x0 + gon_size, gon_y0, gon_x0, gon_y0 + gon_size);
    // Crosshair
    gfx_set(1.0, 1.0, 1.0, 0.08);
    gfx_line(gon_cx, gon_y0, gon_cx, gon_y0 + gon_size);
    gfx_line(gon_x0, gon_cy, gon_x0 + gon_size, gon_cy);

    // Labels - dynamic based on selected pair
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.5);
    
    // Get channel names for current pair
    gonio_pair == 0 ? (#ch1_name = "L"; #ch2_name = "R";) :     // L-R
    gonio_pair == 1 ? (#ch1_name = "L"; #ch2_name = "C";) :     // L-C
    gonio_pair == 2 ? (#ch1_name = "L"; #ch2_name = "Ls";) :    // L-Ls
    gonio_pair == 3 ? (#ch1_name = "L"; #ch2_name = "Rs";) :    // L-Rs
    gonio_pair == 4 ? (#ch1_name = "R"; #ch2_name = "C";) :     // R-C
    gonio_pair == 5 ? (#ch1_name = "R"; #ch2_name = "Ls";) :    // R-Ls
    gonio_pair == 6 ? (#ch1_name = "R"; #ch2_name = "Rs";) :    // R-Rs
    gonio_pair == 7 ? (#ch1_name = "C"; #ch2_name = "Ls";) :    // C-Ls
    gonio_pair == 8 ? (#ch1_name = "C"; #ch2_name = "Rs";) :    // C-Rs
                      (#ch1_name = "Ls"; #ch2_name = "Rs";);    // Ls-Rs
    
    gfx_x = gon_x0 + 2; gfx_y = gon_y0 + 2;
    gfx_drawstr(#ch1_name);
    gfx_measurestr(#ch2_name, lw, lh);
    gfx_x = gon_x0 + gon_size - lw - 2; gfx_y = gon_y0 + 2;
    gfx_drawstr(#ch2_name);
    gfx_x = gon_cx - 3; gfx_y = gon_y0 + 2;
    gfx_drawstr("M");
    gfx_x = gon_cx - 3; gfx_y = gon_y0 + gon_size - 14;
    gfx_drawstr("S");
    
    // Show phase correlation for selected pair
    corr_val = phase_smooth[gonio_pair];
    gfx_setfont(2);
    corr_val >= 0 ? gfx_set(0.3, 0.9, 0.4, 0.9) : gfx_set(0.9, 0.3, 0.2, 0.9);
    sprintf(#corr_str, "φ %.2f", corr_val);
    gfx_measurestr(#corr_str, cw, ch);
    gfx_x = gon_x0 + gon_size - cw - 4;
    gfx_y = gon_y0 + gon_size - ch - 4;
    gfx_drawstr(#corr_str);

    // Left vertical correlation column (aligns with heat map legend width)
    corr_x0 = field_left;
    corr_y0 = gon_y0;
    corr_h = gon_size;
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(corr_x0, corr_y0, corr_w, corr_h);
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    gfx_line(corr_x0, corr_y0, corr_x0 + corr_w, corr_y0);
    gfx_line(corr_x0, corr_y0 + corr_h, corr_x0 + corr_w, corr_y0 + corr_h);
    gfx_line(corr_x0, corr_y0, corr_x0, corr_y0 + corr_h);
    gfx_line(corr_x0 + corr_w, corr_y0, corr_x0 + corr_w, corr_y0 + corr_h);

    // Center line
    corr_cy = corr_y0 + corr_h * 0.5;
    gfx_set(0.35, 0.35, 0.35, 0.5);
    gfx_line(corr_x0 + 2, corr_cy, corr_x0 + corr_w - 2, corr_cy);

    // Correlation fill
    corr_val > 0 ? (
      corr_fill_h = corr_val * corr_h * 0.5;
      gfx_set(0.14, 0.62, 0.32, 0.85);
      gfx_rect(corr_x0 + 2, corr_cy - corr_fill_h, corr_w - 4, corr_fill_h);
    ) : (
      corr_fill_h = abs(corr_val) * corr_h * 0.5;
      gfx_set(0.90, 0.15, 0.10, 0.85);
      gfx_rect(corr_x0 + 2, corr_cy, corr_w - 4, corr_fill_h);
    );

    // Labels
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.6);
    gfx_measurestr("+1", lw, lh);
    gfx_x = corr_x0 + (corr_w - lw) * 0.5;
    gfx_y = corr_y0 - lh * 0.5;
    gfx_drawstr("+1");
    gfx_measurestr("-1", lw, lh);
    gfx_x = corr_x0 + (corr_w - lw) * 0.5;
    gfx_y = corr_y0 + corr_h - lh * 0.5;
    gfx_drawstr("-1");

  );

  // =====================================================
  // 5.1 SURROUND GONIOMETER (Display Mode 3)
  // =====================================================
  (display_mode == 3) ? (

    surr_size = field_size;
    surr_x0 = field_x0;
    surr_y0 = field_y0;

    // Background
    gfx_set(pnl_r, pnl_g, pnl_b, 1);
    gfx_rect(surr_x0, surr_y0, surr_size, surr_size);

    // Room outline
    gfx_set(brd_r, brd_g, brd_b, 0.6);
    // Cinema trapezoid outline
    trap_top_w = surr_size * 0.6;
    trap_bot_w = surr_size * 0.9;
    trap_h_val = surr_size * 0.7;
    trap_cx = surr_x0 + surr_size * 0.5;
    trap_top_y = surr_y0 + surr_size * 0.15;
    trap_bot_y = trap_top_y + trap_h_val;
    gfx_line(trap_cx - trap_top_w * 0.5, trap_top_y, trap_cx + trap_top_w * 0.5, trap_top_y);
    gfx_line(trap_cx + trap_top_w * 0.5, trap_top_y, trap_cx + trap_bot_w * 0.5, trap_bot_y);
    gfx_line(trap_cx + trap_bot_w * 0.5, trap_bot_y, trap_cx - trap_bot_w * 0.5, trap_bot_y);
    gfx_line(trap_cx - trap_bot_w * 0.5, trap_bot_y, trap_cx - trap_top_w * 0.5, trap_top_y);

    // Draw large energy blobs for each channel at speaker positions
    s = 0;
    loop(NUM_SPEAKERS,
      sx = surr_x0 + spk_x[s] * surr_size;
      sy = surr_y0 + spk_y[s] * surr_size;

      // Channel-specific colors
      s == 0 ? (cr = 0.8; cg = 0.3; cb = 0.3;);  // L: red
      s == 1 ? (cr = 0.3; cg = 0.3; cb = 0.8;);  // R: blue
      s == 2 ? (cr = 0.3; cg = 0.8; cb = 0.3;);  // C: green
      s == 3 ? (cr = 0.9; cg = 0.6; cb = 0.2;);  // Ls: orange
      s == 4 ? (cr = 0.6; cg = 0.2; cb = 0.8;);  // Rs: purple

      // Use smoothed energy per speaker (same as heat map mode)
      e = energy[s] * sensitivity * 5.0;
      e = min(e, 1.0);
      
      // Proportional blob size (4..48px radius)
      blob_r = 4 + e * 44;

      // Outer glow (very soft, low opacity)
      gfx_set(cr * e, cg * e, cb * e, e * 0.25);
      gfx_circle(sx, sy, blob_r * 1.8, 1);
      
      // Mid glow (brighter)
      gfx_set(cr * e, cg * e, cb * e, e * 0.55);
      gfx_circle(sx, sy, blob_r, 1);
      
      // Inner core (brightest)
      gfx_set(cr, cg, cb, e * 0.85);
      gfx_circle(sx, sy, blob_r * 0.5, 1);

      // Speaker dot (always visible, 20% bigger)
      gfx_set(0.95, 0.95, 0.95, 0.95);
      gfx_circle(sx, sy, 6 * sc, 1);
      gfx_set(cr, cg, cb, 0.8);
      gfx_circle(sx, sy, 6 * sc, 0);

      // Label
      gfx_setfont(2);
      gfx_set(1.0, 1.0, 1.0, 0.9);
      s == 0 ? ( gfx_x = sx - 18 * sc; gfx_y = sy + 10 * sc; gfx_drawstr("L"); );
      s == 1 ? ( gfx_x = sx + 10 * sc;  gfx_y = sy + 10 * sc; gfx_drawstr("R"); );
      s == 2 ? ( gfx_x = sx - 4 * sc;   gfx_y = sy + 12 * sc; gfx_drawstr("C"); );
      s == 3 ? ( gfx_x = sx + 12 * sc;  gfx_y = sy - 8 * sc; gfx_drawstr("Ls"); );
      s == 4 ? ( gfx_x = sx - 24 * sc;  gfx_y = sy - 8 * sc; gfx_drawstr("Rs"); );

      s += 1;
    );

  );


  // =====================================================
  // LEVELS METER PANEL (Always visible in all display modes)
  // =====================================================
  // Position meters at right side for all modes
  panel_w = meter_panel_w;
  panel_h = phase_top - field_top - pad;
  panel_x0 = gfx_w - pad - panel_w;
  panel_y0 = field_top + pad;

  panel_pad = max(4, (6 * sc)|0);
  bar_gap = max(4, (6 * sc)|0);
  scale_w = max(20, (24 * sc)|0);

  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(panel_x0, panel_y0, panel_w, panel_h);
  gfx_set(brd_r, brd_g, brd_b, 0.6);
  gfx_line(panel_x0, panel_y0, panel_x0 + panel_w, panel_y0);
  gfx_line(panel_x0, panel_y0 + panel_h, panel_x0 + panel_w, panel_y0 + panel_h);
  gfx_line(panel_x0, panel_y0, panel_x0, panel_y0 + panel_h);
  gfx_line(panel_x0 + panel_w, panel_y0, panel_x0 + panel_w, panel_y0 + panel_h);

  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = panel_x0 + panel_pad;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr("LEVELS");
  meter_mode == 0 ? #mode_lbl = "PEAK" : #mode_lbl = "RMS";
  gfx_measurestr(#mode_lbl, mw, mh);
  gfx_x = panel_x0 + panel_w - panel_pad - mw;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr(#mode_lbl);

  left_scale_w = max(10, (12 * sc)|0);
  meter_area_w = panel_w - panel_pad * 2 - scale_w - left_scale_w;
  bar_w = (meter_area_w - bar_gap * 4) / 5;
  bar_w < 4 ? bar_w = 4;
  label_y = panel_y0 + panel_pad + font_sm + 20 * sc;
  value_y = label_y + font_sm + 4 * sc;
  bar_top = value_y + font_sm + 6 * sc;
  
  // Calculate LUFS block size early
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_calc = panel_y0 + panel_h - panel_pad - lufs_block_h;
  
  bar_h = lufs_y0_calc - bar_top - panel_pad;
  bar_h < 40 ? bar_h = 40;
  scale_span = 60.0;
  center_y = bar_top + bar_h * 0.5;
  meter_x0 = panel_x0 + panel_pad + left_scale_w;

  // Target reference line centered (meters only)
  gfx_set(0.70, 0.90, 0.25, 0.55);
  gfx_line(meter_x0, center_y, meter_x0 + meter_area_w, center_y);

  // Left-side reference and 0 dB markers
  zero_y = center_y - (0 - target_level) / scale_span * bar_h;
  zero_y = min(bar_top + bar_h, max(bar_top, zero_y));
  gfx_set(0.55, 0.55, 0.55, 0.6);
  gfx_line(panel_x0 + panel_pad, zero_y, meter_x0 - 2, zero_y);
  sprintf(#zero_str, "%d", 0);
  gfx_setfont(3);
  gfx_measurestr(#zero_str, zw, zh);
  gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
  gfx_rect(panel_x0 + 1, zero_y - zh * 0.5, zw + 2, zh + 2);
  gfx_set(txt_r, txt_g, txt_b, 0.8);
  gfx_x = panel_x0 + 2;
  gfx_y = zero_y - zh * 0.5;
  gfx_drawstr(#zero_str);

  gfx_set(0.30, 0.90, 0.30, 0.85);
  gfx_line(panel_x0 + panel_pad, center_y, meter_x0 - 2, center_y);
  sprintf(#ref_str, "%d", target_level);
  gfx_setfont(2);
  gfx_measurestr(#ref_str, rw, rh);
  gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
  gfx_rect(panel_x0 + 1, center_y - rh * 0.5, rw + 2, rh + 2);
  gfx_set(0.30, 0.90, 0.30, 0.9);
  gfx_x = panel_x0 + 2;
  gfx_y = center_y - rh * 0.5;
  gfx_drawstr(#ref_str);
  gfx_setfont(3);

  i = 0;
  loop(5,
    sp_idx = i == 0 ? 3 : i == 1 ? 0 : i == 2 ? 2 : i == 3 ? 1 : 4;
    i == 0 ? #lbl = "Ls" : i == 1 ? #lbl = "L" : i == 2 ? #lbl = "C" : i == 3 ? #lbl = "R" : #lbl = "Rs";
    bx = meter_x0 + i * (bar_w + bar_gap);

    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.7);
    gfx_measurestr(#lbl, lw, lh);
    gfx_x = bx + (bar_w - lw) * 0.5;
    gfx_y = label_y - lh - 2 * sc;
    gfx_drawstr(#lbl);

    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx, bar_top, bar_w, bar_h);

    meter_mode == 0 ? (
      lvl = peak_level[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    ) : (
      lvl = rms_disp[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    );

    lvl_y = center_y - (lvl_db - target_level) / scale_span * bar_h;
    lvl_y = min(bar_top + bar_h, max(bar_top, lvl_y));

    lvl_db > -6 ? (
      gfx_set(0.90, 0.20, 0.15, 0.9);
    ) : lvl_db > -18 ? (
      gfx_set(0.90, 0.80, 0.10, 0.9);
    ) : (
      gfx_set(mtr_r, mtr_g, mtr_b, 0.9);
    );

    gfx_rect(bx, lvl_y, bar_w, (bar_top + bar_h) - lvl_y);

    gfx_set(txt_r, txt_g, txt_b, 0.6);
    gfx_setfont(3);
    lvl_db > -99 ? (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawnumber(lvl_db, 1);
    ) : (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawstr("-inf");
    );

    // Peak hold for current meter mode
    cur_pk = meter_mode == 0 ? peak_level[sp_idx] : rms_level[sp_idx];
    cur_pk > peak_hold[sp_idx] ? (
      peak_hold[sp_idx] = cur_pk;
      peak_hold_tm[sp_idx] = PEAK_HOLD_FRAMES;
    ) : (
      peak_hold_tm[sp_idx] > 0 ? (
        peak_hold_tm[sp_idx] -= 1;
      ) : (
        peak_hold[sp_idx] *= PEAK_DECAY;
      );
    );
    hold_db = peak_hold[sp_idx] > 0.00001 ? 20.0 * log10(peak_hold[sp_idx]) : -120.0;
    hold_y = center_y - (hold_db - target_level) / scale_span * bar_h;
    hold_y = min(bar_top + bar_h, max(bar_top, hold_y));
    gfx_set(1.0, 1.0, 1.0, 0.6);
    gfx_line(bx, hold_y, bx + bar_w, hold_y);

    i += 1;
  );

  // dB scale on the right side of the meter panel (relative to target level)
  scale_x = panel_x0 + panel_w - panel_pad - scale_w;
  gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_line(scale_x, bar_top, scale_x + scale_w, bar_top);
  gfx_line(scale_x, bar_top + bar_h, scale_x + scale_w, bar_top + bar_h);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_setfont(3);
  db_step = 6;
  db_span = 30;
  db_mark = 0;
  loop(11,
    offset_db = db_span - db_mark * db_step;
    ref_db = target_level + offset_db;
    db_y = center_y - (offset_db / scale_span) * bar_h;
    db_y >= bar_top && db_y <= (bar_top + bar_h) ? (
      gfx_set(brd_r, brd_g, brd_b, 0.3);
      gfx_line(meter_x0, db_y, scale_x - 2, db_y);
      sprintf(#step_str, "%d", ref_db);
      gfx_setfont(3);
      gfx_measurestr(#step_str, sw, sh);
      gfx_set(pnl_r, pnl_g, pnl_b, 0.85);
      gfx_rect(scale_x + 1, db_y - sh * 0.5, sw + 2, sh + 2);
      gfx_set(txt_r, txt_g, txt_b, 0.6);
      gfx_x = scale_x + 2;
      gfx_y = db_y - sh * 0.5;
      gfx_drawstr(#step_str);
    );
    db_mark += 1;
  );

  // LUFS block - more prominent display
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_new = panel_y0 + panel_h - panel_pad - lufs_block_h;
  
  gfx_set(0.08, 0.08, 0.10, 0.95);
  gfx_rect(panel_x0 + panel_pad, lufs_y0_new, panel_w - panel_pad * 2, lufs_block_h);
  gfx_set(acc_r, acc_g, acc_b, 0.6);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new, panel_x0 + panel_w - panel_pad, lufs_y0_new);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new + lufs_block_h, panel_x0 + panel_w - panel_pad, lufs_y0_new + lufs_block_h);
  
  gfx_setfont(2);
  lufs_row_h_new = lufs_block_h / 3;
  lufs_label_x_new = panel_x0 + panel_pad + 6;
  lufs_val_x_new = panel_x0 + panel_w - panel_pad - 6;

  // LUFS-I (Integrated) - most important, at top
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 0 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  gfx_drawstr("LUFS-I");
  gfx_measurestr(lufs_int_disp > -99 ? sprintf(#tmp, "%.1f", lufs_int_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  lufs_int_disp > -99 ? gfx_drawnumber(lufs_int_disp, 1) : gfx_drawstr("-inf");

  // LUFS-S (Short-term) - middle
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 1 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.90, 0.90, 0.20, 0.95);
  gfx_drawstr("LUFS-S");
  gfx_measurestr(lufs_short_disp > -99 ? sprintf(#tmp, "%.1f", lufs_short_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.95, 0.95, 0.95, 1.0);
  lufs_short_disp > -99 ? gfx_drawnumber(lufs_short_disp, 1) : gfx_drawstr("-inf");

  // LUFS-M (Momentary) - bottom, fastest
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 2 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.70, 0.70, 0.70, 0.90);
  gfx_drawstr("LUFS-M");
  gfx_measurestr(lufs_mom_disp > -99 ? sprintf(#tmp, "%.1f", lufs_mom_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.85, 0.85, 0.85, 0.95);
  lufs_mom_disp > -99 ? gfx_drawnumber(lufs_mom_disp, 1) : gfx_drawstr("-inf");
  
  // Mouse click detection for LUFS reset
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    mouse_x >= panel_x0 + panel_pad && mouse_x <= panel_x0 + panel_w - panel_pad &&
    mouse_y >= lufs_y0_new && mouse_y <= lufs_y0_new + lufs_block_h ? (
      // Reset LUFS Integrated
      lufs_int = -120;
      lufs_int_disp = -120;
      lufs_m_db = -100;
      lufs_s_db = -100;
      lufs_i_db = -100;
      lufs_win_pos = 0;
      lufs_win_cnt = 0;
      lufs_win_acc = 0;
      lufs_cur_buf = 0;
      lufs_cur_buf2 = 0;
      lufs_m_sum = 0;
      lufs_s_sum = 0;
      lufs_a_sum = 0;
      lufs_a_sum_cnt = 0;
      lufs_i_sum = 0;
      lufs_i_cnt = 0;
      i = 0;
      loop(lufs_m_win_cnt,
        lufs_buf[i] = 0;
        i += 1;
      );
      i = 0;
      loop(lufs_s_win_cnt,
        lufs_buf2[i] = 0;
        i += 1;
      );
      i = 0;
      loop(NUM_BINS * 2,
        lufs_a_hist[i] = 0;
        i += 1;
      );
    );
  );

  // =====================================================
  // PHASE CORRELATION BARS
  // =====================================================
  // Panel background
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(pad, phase_top, gfx_w - pad * 2, phase_h);
  gfx_set(brd_r, brd_g, brd_b, 0.8);
  gfx_line(pad, phase_top, gfx_w - pad, phase_top);

  // Section label
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.4);
  label_x = pad + 4;
  label_y = phase_top + 3;
  gfx_x = label_x; gfx_y = label_y;
  gfx_drawstr("PHASE");
  
  // Hint for mouse interaction in goniometer mode
  display_mode == 1 ? (
    gfx_set(txt_r, txt_g, txt_b, 0.3);
    gfx_x = label_x; gfx_y = label_y + font_sm + 2;
    gfx_drawstr("(click to switch)");
  );

  // 10 correlation bars (all speaker pair combinations)
  bar_area_left = pad + 50 * sc;
  bar_area_right = gfx_w - pad - 4;
  bar_area_w = bar_area_right - bar_area_left;
  bar_w_each = bar_area_w / NUM_PHASE_PAIRS;
  bar_inner_h = phase_h - 20 * sc;
  bar_top = phase_top + 8 * sc;

  p = 0;
  loop(NUM_PHASE_PAIRS,
    bx = bar_area_left + p * bar_w_each;
    bar_inner_w = bar_w_each - 4 * sc;
    center_y = bar_top + bar_inner_h * 0.5;

    // Highlight selected pair (used in goniometer)
    p == gonio_pair && display_mode == 1 ? (
      gfx_set(acc_r, acc_g, acc_b, 0.3);
      gfx_rect(bx, bar_top - 2, bar_w_each, bar_inner_h + 4);
    );

    // Bar background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx + 2, bar_top, bar_inner_w, bar_inner_h);

    // Center line (zero)
    gfx_set(0.35, 0.35, 0.35, 0.5);
    gfx_line(bx + 2, center_y, bx + 2 + bar_inner_w, center_y);

    // +1 and -1 ticks
    gfx_set(0.25, 0.25, 0.25, 0.3);
    gfx_line(bx + 2, bar_top + 1, bx + 2 + bar_inner_w, bar_top + 1);
    gfx_line(bx + 2, bar_top + bar_inner_h - 1, bx + 2 + bar_inner_w, bar_top + bar_inner_h - 1);

    // Correlation value
    corr = phase_smooth[p];

    // Color: green (+1) -> yellow (0) -> red (-1)
    corr > 0.3 ? (
      pr = 0.14; pg = 0.62; pb = 0.32;
    ) : corr > 0 ? (
      t = corr / 0.3;
      pr = 0.90 * (1.0 - t) + 0.14 * t;
      pg = 0.75 * (1.0 - t) + 0.62 * t;
      pb = 0.10 * (1.0 - t) + 0.32 * t;
    ) : corr > -0.3 ? (
      t = (corr + 0.3) / 0.3;
      pr = 0.90;
      pg = 0.30 * t + 0.20 * (1.0 - t);
      pb = 0.10;
    ) : (
      pr = 0.90; pg = 0.15; pb = 0.10;
    );

    gfx_set(pr, pg, pb, 1.0);

    corr > 0 ? (
      bar_px = corr * bar_inner_h * 0.5;
      gfx_rect(bx + 4, center_y - bar_px, bar_inner_w - 4, bar_px);
    ) : (
      bar_px = abs(corr) * bar_inner_h * 0.5;
      gfx_rect(bx + 4, center_y, bar_inner_w - 4, bar_px);
    );

    // Correlation value text (numeric) - brighter with better contrast
    gfx_setfont(3);
    sprintf(#corr_val, "%.2f", corr);
    // Boost brightness: use max(color * 1.8, 1.0) for saturation
    pr_bright = min(1.0, pr * 1.8);
    pg_bright = min(1.0, pg * 1.8);
    pb_bright = min(1.0, pb * 1.8);
    // Increase alpha for better text visibility
    gfx_set(pr_bright, pg_bright, pb_bright, 1.0);
    gfx_measurestr(#corr_val, cw, ch);
    gfx_x = bx + (bar_w_each - cw) * 0.5;
    gfx_y = center_y - ch * 0.5;
    gfx_drawstr(#corr_val);
    
    // Pair label below
    gfx_setfont(3);
    gfx_set(txt_r, txt_g, txt_b, 0.5);
    // Pair label below
    p == 0 ? ( #lbl = "L-R";   );
    p == 1 ? ( #lbl = "L-C";   );
    p == 2 ? ( #lbl = "L-Ls";  );
    p == 3 ? ( #lbl = "L-Rs";  );
    p == 4 ? ( #lbl = "R-C";   );
    p == 5 ? ( #lbl = "R-Ls";  );
    p == 6 ? ( #lbl = "R-Rs";  );
    p == 7 ? ( #lbl = "C-Ls";  );
    p == 8 ? ( #lbl = "C-Rs";  );
    p == 9 ? ( #lbl = "Ls-Rs"; );
    gfx_measurestr(#lbl, lw, lh);
    gfx_x = bx + (bar_w_each - lw) * 0.5;
    gfx_y = bar_top + bar_inner_h + 2;
    gfx_drawstr(#lbl);
    
    // Mouse click detection for switching goniometer pair
    mouse_cap == 1 && last_mouse_cap == 0 ? (
      mouse_x >= bx && mouse_x <= bx + bar_w_each &&
      mouse_y >= bar_top && mouse_y <= bar_top + bar_inner_h + lh + 4 ? (
        slider14 = p;
        gonio_pair = p;
        sliderchange(slider14);
      );
    );

    p += 1;
  );

  // =====================================================
  // LFE METER
  // =====================================================
  gfx_set(pnl_r, pnl_g, pnl_b, 1);
  gfx_rect(pad, lfe_top, gfx_w - pad * 2, lfe_h);
  gfx_set(brd_r, brd_g, brd_b, 0.8);
  gfx_line(pad, lfe_top, gfx_w - pad, lfe_top);

  gfx_setfont(3);
  gfx_set(0.55, 0.40, 0.75, 0.8);
  gfx_x = pad + 4; gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  gfx_drawstr("LFE");

  lfe_bar_x = pad + 36 * sc;
  lfe_bar_w = gfx_w - pad * 2 - 90 * sc;
  lfe_bar_h = max(8, lfe_h - 10 * sc);
  lfe_bar_y = lfe_top + (lfe_h - lfe_bar_h) * 0.5;

  // Background
  gfx_set(0.12, 0.12, 0.14, 0.7);
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_bar_w, lfe_bar_h);

  // Value
  meter_mode == 0 ? (
    lfe_val = lfe_peak[0];
  ) : (
    lfe_val = lfe_rms[0];
  );
  lfe_db = lfe_val > 0.00001 ? 20.0 * log10(lfe_val) : -60.0;
  lfe_norm = max(0.0, (lfe_db + 60.0) / 60.0);

  // LFE color: purple gradient
  lfe_norm < 0.6 ? (
    gfx_set(0.30, 0.20, 0.60, 0.85);
  ) : lfe_norm < 0.85 ? (
    gfx_set(0.50, 0.30, 0.70, 0.85);
  ) : (
    gfx_set(0.90, 0.20, 0.15, 0.85);
  );
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_norm * lfe_bar_w, lfe_bar_h);

  // LFE peak hold
  lfe_cur_pk = meter_mode == 0 ? lfe_peak[0] : lfe_rms[0];
  lfe_cur_pk > lfe_hold[0] ? (
    lfe_hold[0] = lfe_cur_pk;
    lfe_hold_tm[0] = PEAK_HOLD_FRAMES;
  ) : (
    lfe_hold_tm[0] > 0 ? (
      lfe_hold_tm[0] -= 1;
    ) : (
      lfe_hold[0] *= PEAK_DECAY;
    );
  );
  lfe_hld_db = lfe_hold[0] > 0.00001 ? 20.0 * log10(lfe_hold[0]) : -60.0;
  lfe_hld_norm = max(0.0, (lfe_hld_db + 60.0) / 60.0);
  lfe_hld_x = lfe_bar_x + lfe_hld_norm * lfe_bar_w;
  gfx_set(1.0, 1.0, 1.0, 0.5);
  gfx_line(lfe_hld_x, lfe_bar_y, lfe_hld_x, lfe_bar_y + lfe_bar_h);

  // dB readout
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = lfe_bar_x + lfe_bar_w + 6;
  gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  lfe_db > -59.0 ? (
    gfx_drawnumber(lfe_db, 1);
    gfx_drawstr(" dB");
  ) : (
    gfx_drawstr("-inf dB");
  );

  // Update mouse state for click detection  
  last_mouse_cap = mouse_cap;

  // =====================================================
  // VERSION WATERMARK
  // =====================================================
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.15);
  #wm = "v1.0";
  gfx_measurestr(#wm, wmw, wmh);
  gfx_x = gfx_w - wmw - 4;
  gfx_y = gfx_h - wmh - 2;
  gfx_drawstr(#wm);
