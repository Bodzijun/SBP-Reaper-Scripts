desc:SBP Phantom Follower - 5.1 Position Follower with Pseudo-Acoustics
// @author Sergey Bondarev (SBP)
// @version 2.2.4
// @about 5.1 Follower that pans audio to follow Phantom Center position from SBP Surround Scope.
//        Includes coordinate transformation (offset, scale, invert) and pseudo-acoustic filtering
//        based on angle difference. Link slider1/2 to SurroundScope slider24/25 via Parameter Modulation.

// @changelog v2.2.4 - Fixed manual position mode: direct 6-channel passthrough now works correctly without creating mono sum. Updated info panel values to match new slider indices.
// @changelog v2.2.3 - Fixed slider renumbering regressions: restored correct Send Mode mapping (Param/Opening/Amount/Fade), divergence controls, and mute mask linkage after moving Rotation Multiplier. Updated info panel values to match new slider indices.
// @changelog v2.2.2 - Changed Filter Pac-Man to follow Phantom Center instead of Source (matching Pitch and Send behavior). Filter mode 1 now tracks phantom position from SurroundScope for consistent multi-effect coordination.
// @changelog v2.2.1 - Added Rotation Multiplier (slider6, x1-x10) to extend Manual Angle and Source Rotation range up to ±1800 degrees (10 full turns) for unrestricted automation. Fixed Pac-Man visualization glitches - implemented circular angle interpolation to prevent jumps at ±180° boundary (Rs-Ls transition). Fixed Compact UI mode to preserve slider visibility state after transport stop.
// @changelog v2.2.0 - Added per-channel Mute (click channel labels in meter panel to toggle L/R/C/LFE/Ls/Rs) and Divergence (drag cyan bars below meters to spread signal to adjacent ITU-R speakers). Mute applies post-metering so meters still show activity. Divergence uses ITU-R BS.775 adjacency (L↔C, L↔Ls, R↔C, R↔Rs, Ls↔Rs). All parameters stored in hidden sliders (23, 31-35) for automation. Right-click divergence to reset.
// @changelog v2.0.2 - CRITICAL FIX: Bypass mode now properly passes input channels to output. Previously, bypass mode set position to center but did not copy audio samples to output channels (spl0-spl5), resulting in complete silence. All input channels (L/R/C/Ls/Rs/LFE) now pass through unchanged in bypass mode, with send outputs (spl6-11) muted.
// @changelog v2.0.1 - Fix: Speaker icons now drawn above all Pac-Man visualizations (Filter/Pitch/Send), preventing overlay occlusion. Made speakers brighter (0.9 RGB) and slightly larger (7px) for better visibility. Speaker labels moved higher for clearer separation.
// @changelog v2.0 - BREAKING: Migrated from cinema trapezoid to ITU-R BS.775 standard geometry to match Surround Scope v2.0. Speaker positions now follow proper ITU angles (L=-30°, R=+30°, C=0°, Ls=-110°, Rs=+110°) at equal radius 0.35. Visualization updated from trapezoid to circle. Ensures accurate spatial panning and maintains perfect coordination with Surround Scope's phantom center tracking.
// @changelog v1.2.3 - Removed Range Limit and Deadzone parameters; simplified angle control.
// @changelog v1.2.2 - Added filter visualization and radius guides; lightened room visualization.
// @changelog v1.2.1 - Matched LEVELS/LUFS meter panel layout and styling to SurroundScope.
// @changelog v1.2 - Complete meter panel UI on right sidebar with Peak bars (L/R/C/Ls/Rs), 
//                   color scaling (green/-18dB, yellow/-6dB, red/0dB), dB values, and LUFS block
//                   (I/S/M). Added full K-weighted LUFS metering (ITU-R BS.1770-4). Fixed output 
//                   level drop by normalizing mono sum by active channel count (-50% → -0dB).
//                   Updated UI palette and accents to match SurroundScope dark charcoal + green.
// @changelog v1.1 - Synced VBAP Clean algorithm with SurroundScope: use adjacent speaker pairs only
//                   (Ls-L, L-C, C-R, R-Rs, Rs-Ls) with linear pair interpolation for smooth panning.
// @changelog v1.0 - Initial release. Follow Phantom Center coordinates with VBAP/Amplitude panning,
//                   coordinate transforms, deadzone filtering, and frequency-based pseudo-acoustics.

// === INPUT SLIDERS (link from SurroundScope) ===
slider1:0.5<0,1,0.001>Phantom Center X
slider2:0.5<0,1,0.001>Phantom Center Y

// === FOLLOWER CONTROLS ===
slider3:1<0,3,1{Bypass,Follow Phantom,Follow Phantom Inverted,Manual Position}>Follower Mode
slider4:0<0,1,1{VBAP Clean,Amplitude Bleed}>Panning Mode
slider5:0<-180,180,1>Manual Angle (degrees)
slider6:1<1,10,1>Rotation Multiplier

// === TRANSFORM CONTROLS ===
slider7:0<-180,180,1>Offset Angle (deg)
slider8:0.85<0,0.99,0.01>Smoothing
slider9:1.0<0.1,2.0,0.01>Scale
slider10:0<-180,180,1>Source Rotation (deg)

// === PSEUDO-ACOUSTICS FILTER (Shadow/Pac-Man Mode) ===
slider11:0<0,2,1{Off,Follow Phantom,Independent}>Filter Mode
slider12:0<-180,180,1>Filter Param (Offset/Rotation)
slider13:180<0,360,1>Filter Opening Angle (deg)
slider14:2000<50,20000,10>Filter Target Frequency (Hz)

// === FILTER RESONANCE ===
slider15:1.0<0.5,10.0,0.1>Filter Resonance (Q)

// === PAC-MAN DISPLAY ===
slider16:4<0,4,1{None,Filter Only,Pitch Only,Send Only,All}>Pac-Man Display

// === PITCH PAC-MAN ===
slider17:0<0,2,1{Off,Follow Phantom,Independent}>Pitch Mode
slider18:0<-180,180,1>Pitch Param (Offset/Rotation)
slider22:180<0,360,1>Pitch Opening Angle (deg)
slider23:5<-12,12,0.1>Pitch Target (semitones)
slider25:1<0,3,1{2048,4096,8192,16384}>Pitch Grain Size

// === SEND PAC-MAN (Multichannel Send 7-12) ===
slider27:0<0,2,1{Off,Follow Phantom,Independent}>Send Mode
slider28:0<-180,180,1>Send Param (Offset/Rotation)
slider29:180<0,360,1>Send Opening Angle (deg)
slider30:1.0<0,2.0,0.01>Send Amount
slider31:0.25<0,1.0,0.01>Send Fade Zone

// === UI CONTROLS ===
slider26:0<0,1,1{Show All,Compact View}>-UI Mode

// === AUTOMATION OUTPUTS ===
slider19:0<-180,180,0.1>-Source Angle Out
slider20:0.5<0,1,0.001>-Source X Out
slider21:0.5<0,1,0.001>-Source Y Out

// === CHANNEL MUTE & DIVERGENCE (hidden) ===
slider24:0<0,63,1>-Channel Mute Mask
slider32:0<0,1,0.01>-L Divergence
slider33:0<0,1,0.01>-R Divergence
slider34:0<0,1,0.01>-C Divergence
slider35:0<0,1,0.01>-Ls Divergence
slider36:0<0,1,0.01>-Rs Divergence


@init
  // === CONSTANTS ===
  NUM_SPEAKERS = 5;
  PEAK_HOLD_FRAMES = 60;
  PEAK_DECAY = 0.995;
  RMS_WINDOW = 1024;
  TWO_PI = 6.283185307179586;
  
  // === PITCH SHIFTER CONSTANTS ===
  PITCH_BUFFER_SIZE = 65536;  // 64K samples for delay buffer
  PITCH_GRAIN_SIZE = 4096;     // Default grain size
  pitch_buffer = 20000;        // Memory location for pitch buffer
  pitch_write_pos = 0;
  pitch_read_phase = 0;        // Phase accumulator for correct pitch shifting
  
  // Initialize pitch buffer with zeros (avoid reading garbage at startup)
  pitch_init_idx = 0;
  loop(PITCH_BUFFER_SIZE * 5,
    pitch_buffer[pitch_init_idx] = 0;
    pitch_init_idx += 1;
  );
  
  // UI constants for slider visibility control
  // Sliders to toggle in compact mode: 1-18, 22-23, 25, 27-31 (skip 19-21=outputs, 24=Mute, 26=UI Mode, 32-36=divergence)
  UI_SLIDERS_MASK = ((1 << 18) - 1) | (3 << 21) | (1 << 24) | (31 << 26);  // bits 0-17, 21-22, 24, 26-30
  sliders_showing = 0;
  slider_show(UI_SLIDERS_MASK, slider26 ? 0 : 1);  // Show/hide based on current UI Mode
  
  // Fixed meter settings (SurroundScope defaults)
  meter_mode = 0;     // 0=Peak, 1=RMS
  target_level = -23; // LUFS reference
  
  // === SPEAKER POSITIONS (ITU-R BS.775 standard - same as SurroundScope) ===
  // All speakers equidistant from listener at radius 0.35:
  //   L  (Front Left):    -30° at radius 0.35
  //   R  (Front Right):   +30° at radius 0.35
  //   C  (Center):          0° at radius 0.35
  //   Ls (Left Surround): -110° at radius 0.35
  //   Rs (Right Surround): +110° at radius 0.35
  //   Listener at (0.5, 0.5)
  // Array indices: 0=L, 1=R, 2=C, 3=Ls, 4=Rs
  spk_x = 1000;
  spk_y = 2000;

  // Center Front (0°, straight ahead)
  spk_x[2] = 0.500; spk_y[2] = 0.150;
  // Left Front (-30°)
  spk_x[0] = 0.325; spk_y[0] = 0.197;
  // Right Front (+30°)
  spk_x[1] = 0.675; spk_y[1] = 0.197;
  // Left Surround (-110°, rear left)
  spk_x[3] = 0.171; spk_y[3] = 0.620;
  // Right Surround (+110°, rear right)
  spk_x[4] = 0.829; spk_y[4] = 0.620;
  
  // Listener position (center of room)
  listen_x = 0.5;
  listen_y = 0.5;
  
  // === ANGLE CONSTANTS ===
  ang_C = 0;  // Center: 0° (straight ahead)
  
  // === FILTER STATE (4-pole cascade) ===
  flt_L.z1 = 0; flt_L.z2 = 0; flt_L.z3 = 0; flt_L.z4 = 0;
  flt_R.z1 = 0; flt_R.z2 = 0; flt_R.z3 = 0; flt_R.z4 = 0;
  flt_C.z1 = 0; flt_C.z2 = 0; flt_C.z3 = 0; flt_C.z4 = 0;
  flt_Ls.z1 = 0; flt_Ls.z2 = 0; flt_Ls.z3 = 0; flt_Ls.z4 = 0;
  flt_Rs.z1 = 0; flt_Rs.z2 = 0; flt_Rs.z3 = 0; flt_Rs.z4 = 0;
  
  // === PREVIOUS VALUES FOR SMOOTHING ===
  prev_source_angle = 0;
  source_angle_smooth = 0;
  source_x = 0.5;
  source_y = 0.5;
  
  // === PHANTOM CENTER ANGLE SMOOTHING (for PAC-MAN display only) ===
  phantom_angle_smooth = 0;  // Smoothed phantom center angle (degrees)

  // === METER MEMORY LAYOUT ===
  peak_level   = 10000;  // [10000..10004]
  rms_acc      = 10010;  // [10010..10014]
  rms_level    = 10020;  // [10020..10024]
  rms_disp     = 10030;  // [10030..10034]
  peak_hold    = 10040;  // [10040..10044]
  peak_hold_tm = 10050;  // [10050..10054]
  rms_counter  = 10060;  // [10060]

  // LFE metering
  lfe_peak     = 10070;  // [10070]
  lfe_rms_acc  = 10071;  // [10071]
  lfe_rms      = 10072;  // [10072]
  lfe_hold     = 10073;  // [10073]
  lfe_hold_tm  = 10074;  // [10074]

  // K-weighting filter state (ITU-R BS.1770-4)
  kw_z1 = 10100;  // [10100..10119]
  kw_z2 = 10120;  // [10120..10139]

  // --- LUFS STATE ---
  lufs_short = -120;
  lufs_mom = -120;
  lufs_int = -120;
  lufs_short_disp = -120;
  lufs_mom_disp = -120;
  lufs_int_disp = -120;
  lufs_short_acc = 0;
  lufs_short_cnt = 0;
  lufs_mom_acc = 0;
  lufs_mom_cnt = 0;
  lufs_int_acc = 0;
  lufs_int_cnt = 0;
  lufs_m_db = -100;
  lufs_s_db = -100;
  lufs_i_db = -100;
  lufs_win_pos = 0;
  lufs_win_cnt = 0;
  lufs_win_acc = 0;
  lufs_cur_buf = 0;
  lufs_cur_buf2 = 0;
  lufs_m_sum = 0;
  lufs_s_sum = 0;
  lufs_a_sum = 0;
  lufs_a_sum_cnt = 0;
  lufs_i_sum = 0;
  lufs_i_cnt = 0;

  // LUFS windowing (Cockos/REAPER)
  LOUD_METER_UPDATE = 0.10; // 100ms
  lufs_m_win_cnt = max(1, (0.4 / LOUD_METER_UPDATE) | 0);
  lufs_s_win_cnt = max(1, (3.0 / LOUD_METER_UPDATE) | 0);
  lufs_win_len = max(1, (LOUD_METER_UPDATE * srate) | 0);
  lufs_i_win_len = 1.0 / (lufs_m_win_cnt * lufs_win_len);
  lufs_i_win_len2 = 1.0 / (lufs_s_win_cnt * lufs_win_len);
  NUM_BINS = 1024;
  BINS_PER_DB = 10;
  DB_PER_BIN = 1.0 / BINS_PER_DB;

  // LUFS buffers and histograms
  lufs_buf = 11000;     // [11000..11000+lufs_m_win_cnt-1]
  lufs_buf2 = 11010;    // [11010..11010+lufs_s_win_cnt-1]
  lufs_a_hist = 11100;  // [11100..11100+NUM_BINS*2-1]

  // Clear meter arrays
  i = 0;
  loop(NUM_SPEAKERS,
    peak_level[i] = 0;
    rms_acc[i] = 0;
    rms_level[i] = 0;
    rms_disp[i] = 0;
    peak_hold[i] = 0;
    peak_hold_tm[i] = 0;
    i += 1;
  );
  rms_counter[0] = 0;
  lfe_peak[0] = 0; lfe_rms_acc[0] = 0; lfe_rms[0] = 0;
  lfe_hold[0] = 0; lfe_hold_tm[0] = 0;

  // Clear LUFS buffers
  i = 0;
  loop(lufs_m_win_cnt,
    lufs_buf[i] = 0;
    i += 1;
  );
  i = 0;
  loop(lufs_s_win_cnt,
    lufs_buf2[i] = 0;
    i += 1;
  );
  i = 0;
  loop(NUM_BINS * 2,
    lufs_a_hist[i] = 0;
    i += 1;
  );

  // --- K-WEIGHTING FILTER COEFFICIENTS (ITU-R BS.1770-4) ---
  // Stage 1: High-pass filter (2nd order Butterworth @ 38 Hz)
  f0_hp = 38.13547087613982;
  Q_hp = 0.5003270373253953;
  K_hp = tan($pi * f0_hp / srate);
  norm_hp = 1.0 / (1.0 + K_hp / Q_hp + K_hp * K_hp);
  kw_b0_hp = norm_hp;
  kw_b1_hp = -2.0 * norm_hp;
  kw_b2_hp = norm_hp;
  kw_a1_hp = 2.0 * (K_hp * K_hp - 1.0) * norm_hp;
  kw_a2_hp = (1.0 - K_hp / Q_hp + K_hp * K_hp) * norm_hp;

  // Stage 2: High-shelf filter (+3.999 dB @ 1681.97 Hz)
  f0_hs = 1681.9744509555319;
  Q_hs = 0.7071752369554196;
  gain_hs_db = 3.999843853973347;
  A_hs = pow(10.0, gain_hs_db / 40.0);
  K_hs = tan($pi * f0_hs / srate);
  norm_hs = 1.0 / (1.0 + K_hs / Q_hs + K_hs * K_hs);
  kw_b0_hs = (1.0 + sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_b1_hs = 2.0 * (A_hs * K_hs * K_hs - 1.0) * norm_hs;
  kw_b2_hs = (1.0 - sqrt(A_hs) * K_hs / Q_hs + A_hs * K_hs * K_hs) * norm_hs;
  kw_a1_hs = 2.0 * (K_hs * K_hs - 1.0) * norm_hs;
  kw_a2_hs = (1.0 - K_hs / Q_hs + K_hs * K_hs) * norm_hs;

  // Clear filter states
  memset(kw_z1, 0, 20);
  memset(kw_z2, 0, 20);

  // Mouse state tracking for LUFS reset
  last_mouse_cap = 0;

  // === VBAP PANNING FUNCTION ===
  // Distributes signal to adjacent speaker pair only (clean, no crosstalk)
  // angle: input angle in radians
  // input_level: signal amplitude to distribute
  // L_out, R_out, C_out, Ls_out, Rs_out: output accumulators (passed by reference via memory)
  function distribute_vbap(angle, input_level, L_out, R_out, C_out, Ls_out, Rs_out)
    local(ang_L, ang_R, ang_Ls, ang_Rs, ang_normalized,
          ang1, ang2, ang_span, ang_in_span, idx1, idx2, g1, g2)
  (
    // Calculate speaker angles from listener position
    ang_L  = atan2(spk_x[0] - listen_x, listen_y - spk_y[0]);
    ang_R  = atan2(spk_x[1] - listen_x, listen_y - spk_y[1]);
    ang_Ls = atan2(spk_x[3] - listen_x, listen_y - spk_y[3]);
    ang_Rs = atan2(spk_x[4] - listen_x, listen_y - spk_y[4]);

    // Normalize angle to -pi..pi
    ang_normalized = angle;
    ang_normalized > $pi ? ang_normalized -= TWO_PI;
    ang_normalized < -$pi ? ang_normalized += TWO_PI;

    // Adjacent pair selection (clockwise): Ls -> L -> C -> R -> Rs -> Ls
    ang_normalized >= ang_Ls && ang_normalized < ang_L ? (
      idx1 = 3; idx2 = 0;  // Ls -> L
      ang1 = ang_Ls; ang2 = ang_L;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_L && ang_normalized < ang_C ? (
      idx1 = 0; idx2 = 2;  // L -> C
      ang1 = ang_L; ang2 = ang_C;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_C && ang_normalized < ang_R ? (
      idx1 = 2; idx2 = 1;  // C -> R
      ang1 = ang_C; ang2 = ang_R;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : ang_normalized >= ang_R && ang_normalized < ang_Rs ? (
      idx1 = 1; idx2 = 4;  // R -> Rs
      ang1 = ang_R; ang2 = ang_Rs;
      ang_span = ang2 - ang1;
      ang_in_span = ang_normalized - ang1;
    ) : (
      // Rs -> Ls wrap (rear wall)
      idx1 = 4; idx2 = 3;  // Rs -> Ls
      ang1 = ang_Rs; ang2 = ang_Ls;
      ang_span = TWO_PI - (ang1 - ang2);
      ang_in_span = ang_normalized - ang1;
      ang_in_span < 0 ? ang_in_span += TWO_PI;
    );

    // Linear interpolation within pair (g1 + g2 = 1)
    g2 = ang_in_span / ang_span;
    g2 < 0 ? g2 = 0 : g2 > 1 ? g2 = 1;
    g1 = 1.0 - g2;

    // Distribute to pair
    idx1 == 0 ? (this[L_out] += input_level * g1) :
    idx1 == 1 ? (this[R_out] += input_level * g1) :
    idx1 == 2 ? (this[C_out] += input_level * g1) :
    idx1 == 3 ? (this[Ls_out] += input_level * g1) :
                (this[Rs_out] += input_level * g1);

    idx2 == 0 ? (this[L_out] += input_level * g2) :
    idx2 == 1 ? (this[R_out] += input_level * g2) :
    idx2 == 2 ? (this[C_out] += input_level * g2) :
    idx2 == 3 ? (this[Ls_out] += input_level * g2) :
                (this[Rs_out] += input_level * g2);
  );

  // === AMPLITUDE PANNING FUNCTION ===
  // Distributes signal to all 5 speakers based on angular distance (allows crosstalk)
  function distribute_amplitude(angle, input_level, L_out, R_out, C_out, Ls_out, Rs_out)
    local(ang_L, ang_R, ang_Ls, ang_Rs, w_L, w_R, w_C, w_Ls, w_Rs, total)
  (
    // Calculate speaker angles
    ang_L  = atan2(spk_x[0] - listen_x, listen_y - spk_y[0]);
    ang_R  = atan2(spk_x[1] - listen_x, listen_y - spk_y[1]);
    ang_Ls = atan2(spk_x[3] - listen_x, listen_y - spk_y[3]);
    ang_Rs = atan2(spk_x[4] - listen_x, listen_y - spk_y[4]);
    
    // Calculate weights using cosine similarity
    w_L  = max(0, cos(angle - ang_L));
    w_R  = max(0, cos(angle - ang_R));
    w_C  = max(0, cos(angle - ang_C));
    w_Ls = max(0, cos(angle - ang_Ls));
    w_Rs = max(0, cos(angle - ang_Rs));
    
    // Normalize
    total = w_L + w_R + w_C + w_Ls + w_Rs;
    total > 0.001 ? (
      this[L_out]  += input_level * (w_L / total);
      this[R_out]  += input_level * (w_R / total);
      this[C_out]  += input_level * (w_C / total);
      this[Ls_out] += input_level * (w_Ls / total);
      this[Rs_out] += input_level * (w_Rs / total);
    );
  );

  // === FILTER CUTOFF CALCULATION ===
  // Interpolates cutoff frequency based on angle difference
  // 0° = same direction → cutoff_0deg (full spectrum)
  // 180° = opposite direction → cutoff_180deg (muffled)
  function calc_filter_cutoff(angle_diff, cutoff_0deg, cutoff_180deg)
    local(abs_diff, t, cutoff)
  (
    abs_diff = abs(angle_diff);
    abs_diff > 180 ? abs_diff = 360 - abs_diff;  // normalize to 0..180
    
    t = abs_diff / 180.0;  // 0..1 (0=same direction, 1=opposite)
    
    // Linear interpolation
    cutoff = cutoff_0deg * (1.0 - t) + cutoff_180deg * t;
    
    cutoff;
  );

  // === ONE-POLE LOW-PASS FILTER ===
  // Simple IIR filter: y[n] = alpha * x[n] + (1-alpha) * y[n-1]
  function lowpass_process(sample, cutoff_hz, samplerate)
    local(omega, alpha)
  (
    omega = 2.0 * $pi * cutoff_hz / samplerate;
    alpha = omega / (omega + 1.0);  // simple coefficient
    
    this.z = alpha * sample + (1.0 - alpha) * this.z;
    this.z;
  );

@slider
  // Update grain size from slider
  grain_size_idx = slider25;
  grain_size_idx == 0 ? PITCH_GRAIN_SIZE = 2048 :
  grain_size_idx == 1 ? PITCH_GRAIN_SIZE = 4096 :
  grain_size_idx == 2 ? PITCH_GRAIN_SIZE = 8192 :
                         PITCH_GRAIN_SIZE = 16384;
  
  ui_mode = slider26;

@sample
  follower_mode = slider3;
  
  follower_mode == 0 ? (
    // === BYPASS MODE ===
    source_x = 0.5;
    source_y = 0.5;
    source_angle_smooth = 0;

    // Pass through all input channels unchanged
    spl0 = spl0;  // L
    spl1 = spl1;  // R
    spl2 = spl2;  // C
    spl3 = spl3;  // LFE
    spl4 = spl4;  // Ls
    spl5 = spl5;  // Rs
    spl6 = 0;     // Send outputs
    spl7 = 0;
    spl8 = 0;
    spl9 = 0;
    spl10 = 0;
    spl11 = 0;

  ) : (
    // === ACTIVE MODES (Follow Phantom or Manual) ===
    
    follower_mode == 1 || follower_mode == 2 ? (
      // === FOLLOW PHANTOM MODE (normal or inverted) ===
      phantom_x = slider1;
      phantom_y = slider2;
      
      // Center normalize and convert to polar
      dx = phantom_x - 0.5;
      dy = phantom_y - 0.5;
      base_r = sqrt(dx * dx + dy * dy);
      base_ang = atan2(dx, -dy);  // 0 deg = up

      // Apply inversion if mode == 2
      follower_mode == 2 ? base_ang += $pi;  // 180° inversion
      
      // Offset along circular path + scale radius
      base_ang += slider7 * $pi / 180.0;
      base_r *= slider9;

      // Back to cartesian and clamp
      source_x = max(0, min(1, 0.5 + sin(base_ang) * base_r));
      source_y = max(0, min(1, 0.5 - cos(base_ang) * base_r));
      
    ) : (
      // === MANUAL POSITION MODE ===
      manual_angle = slider5 * slider6 * $pi / 180.0;
      
      // Convert angle to X/Y coordinates
      // Use moderate radius to stay within ITU-R BS.775 circle
      radius = 0.3;
      source_x = 0.5 + sin(manual_angle) * radius;
      source_y = 0.5 - cos(manual_angle) * radius;
      source_x = max(0, min(1, source_x));
      source_y = max(0, min(1, source_y));
    );
    
    // === ANGLE CALCULATION ===
    // Convert source position to angle (relative to listener)
    dx = source_x - listen_x;
    dy = source_y - listen_y;
    source_angle_rad = atan2(dx, -dy);
    source_angle_deg = source_angle_rad * 180.0 / $pi;
    
    // === SOURCE ROTATION (rotate around own axis - affects angle only) ===
    source_rotation = slider10 * slider6 * $pi / 180.0;
    source_angle_rad += source_rotation;
    source_angle_deg = source_angle_rad * 180.0 / $pi;
    
    // === SMOOTHING (circular angle interpolation to prevent glitches at boundaries) ===
    smoothing = slider8;
    // Normalize angle difference to shortest path (-180 to +180)
    angle_diff = source_angle_deg - source_angle_smooth;
    angle_diff > 180 ? angle_diff -= 360;
    angle_diff < -180 ? angle_diff += 360;
    // Apply smoothing using normalized difference
    source_angle_smooth += angle_diff * (1.0 - smoothing);
    // Keep smooth angle in range -180 to +180
    source_angle_smooth > 180 ? source_angle_smooth -= 360;
    source_angle_smooth < -180 ? source_angle_smooth += 360;
    source_angle_rad = source_angle_smooth * $pi / 180.0;
    
    // === READ INPUT CHANNELS ===
    in_L = spl0;
    in_R = spl1;
    in_C = spl2;
    in_LFE = spl3;
    in_Ls = spl4;
    in_Rs = spl5;
    
    // === RESET OUTPUT ACCUMULATORS ===
    out_L = 6000;
    out_R = 6001;
    out_C = 6002;
    out_Ls = 6003;
    out_Rs = 6004;
    this[out_L] = 0;
    this[out_R] = 0;
    this[out_C] = 0;
    this[out_Ls] = 0;
    this[out_Rs] = 0;
    
    // === APPLY PANNING ===
    panning_mode = slider4;
    
    follower_mode == 3 ? (
      // === MANUAL POSITION MODE: Direct 6-channel passthrough (no mono sum) ===
      this[out_L]  = in_L;
      this[out_R]  = in_R;
      this[out_C]  = in_C;
      this[out_Ls] = in_Ls;
      this[out_Rs] = in_Rs;
    ) : (
      // === FOLLOW PHANTOM MODES: Create mono sum and pan it ===
      // Normalize by active channel count to avoid volume inflation
      active_cnt = (abs(in_L) > 0.000001) + (abs(in_R) > 0.000001) + (abs(in_C) > 0.000001) +
                   (abs(in_Ls) > 0.000001) + (abs(in_Rs) > 0.000001);
      active_cnt < 1 ? active_cnt = 1;
      mono_sum = (in_L + in_R + in_C + in_Ls + in_Rs) / active_cnt;
      
      panning_mode == 0 ? (
        // VBAP Clean mode
        distribute_vbap(source_angle_rad, mono_sum, out_L, out_R, out_C, out_Ls, out_Rs);
      ) : (
        // Amplitude Bleed mode
        distribute_amplitude(source_angle_rad, mono_sum, out_L, out_R, out_C, out_Ls, out_Rs);
      );
    );

    // === DIVERGENCE (cross-feed to adjacent speakers) ===
    div_L  = slider32;
    div_R  = slider33;
    div_C  = slider34;
    div_Ls = slider35;
    div_Rs = slider36;

    (div_L > 0.005 || div_R > 0.005 || div_C > 0.005 || div_Ls > 0.005 || div_Rs > 0.005) ? (
      // Save pre-divergence levels
      pre_L  = this[out_L];
      pre_R  = this[out_R];
      pre_C  = this[out_C];
      pre_Ls = this[out_Ls];
      pre_Rs = this[out_Rs];

      // Apply divergence: channel keeps (1-div), neighbors each get div*0.5
      // Adjacency: L↔C, L↔Ls, R↔C, R↔Rs, Ls↔Rs (rear wrap)
      this[out_L]  = pre_L*(1-div_L)  + pre_C*div_C*0.5  + pre_Ls*div_Ls*0.5;
      this[out_R]  = pre_R*(1-div_R)  + pre_C*div_C*0.5  + pre_Rs*div_Rs*0.5;
      this[out_C]  = pre_C*(1-div_C)  + pre_L*div_L*0.5   + pre_R*div_R*0.5;
      this[out_Ls] = pre_Ls*(1-div_Ls)+ pre_L*div_L*0.5   + pre_Rs*div_Rs*0.5;
      this[out_Rs] = pre_Rs*(1-div_Rs)+ pre_R*div_R*0.5   + pre_Ls*div_Ls*0.5;
    );

    // === PSEUDO-ACOUSTICS FILTER (Shadow/Pac-Man) ===
    filter_mode = slider11;  // 0=Off, 1=Follow Phantom, 2=Independent
    filter_opening_angle = slider13 * $pi / 180.0;  // Convert to radians
    filter_target_freq = slider14;  // Target frequency when source outside
    filter_resonance = slider15;    // Q factor
    
    filter_mode > 0 ? (
      // Pre-calculate phantom angle for filter center
      phantom_dx = slider1 - listen_x;
      phantom_dy = slider2 - listen_y;
      phantom_angle_rad = atan2(phantom_dx, -phantom_dy);
      
      // Calculate filter center angle
      filter_mode == 1 ? (
        // Follow Phantom mode: filter center = phantom angle + offset
        filter_center = phantom_angle_rad + slider12 * $pi / 180.0;
      ) : (
        // Independent mode: filter center = manual rotation
        filter_center = slider12 * $pi / 180.0;
      );
      
      // Pac-Man logic: calculate angular distance from filter center to source
      angle_to_source = source_angle_rad - filter_center;
      
      // Normalize to -pi..pi
      angle_to_source > $pi ? angle_to_source -= TWO_PI;
      angle_to_source < -$pi ? angle_to_source += TWO_PI;
      
      // Abs distance
      abs_angle_dist = abs(angle_to_source);
      
      // Check if in opening zone (Pac-Man mouth)
      half_opening = filter_opening_angle * 0.5;
      distance_from_edge = abs_angle_dist - half_opening;
      
      distance_from_edge < 0 ? (
        // Inside mouth - FULL spectrum (20kHz)
        cutoff_freq = 20000;
      ) : (
        // Outside mouth - interpolate to target_freq
        // Opposite side (180° from center) = full target_freq
        max_distance = $pi - half_opening;  // Distance to opposite side
        t = min(1.0, distance_from_edge / max_distance);
        // Smoothstep curve: ease-in near mouth edge, ease-out near target
        t = t * t * (3.0 - 2.0 * t);
        cutoff_freq = 20000 * (1 - t) + filter_target_freq * t;
      );
    ) : (
      cutoff_freq = 20000;  // Off - full spectrum
    );
    
    // === PITCH BUFFER WRITE (before any effects) ===
    out_L = 6000; out_R = 6001; out_C = 6002; out_Ls = 6003; out_Rs = 6004;
    pitch_buffer[pitch_write_pos * 5 + 0] = this[out_L];
    pitch_buffer[pitch_write_pos * 5 + 1] = this[out_R];
    pitch_buffer[pitch_write_pos * 5 + 2] = this[out_C];
    pitch_buffer[pitch_write_pos * 5 + 3] = this[out_Ls];
    pitch_buffer[pitch_write_pos * 5 + 4] = this[out_Rs];
    
    // === PITCH SHIFTER (First effect - Pac-Man Pitch) ===
    pitch_mode = slider17;
    pitch_opening_angle = slider22 * $pi / 180.0;
    pitch_semitones = slider23;
    
    // Pre-calculate phantom angle (always needed for Pitch and Send modes)
    phantom_dx = slider1 - listen_x;
    phantom_dy = slider2 - listen_y;
    phantom_angle_rad = atan2(phantom_dx, -phantom_dy);
    
    pitch_mode > 0 ? (
      // Calculate pitch center angle
      pitch_mode == 1 ? (
        pitch_center = phantom_angle_rad + slider18 * $pi / 180.0;
      ) : (
        pitch_center = slider18 * $pi / 180.0;
      );
      
      // Angular distance from pitch center to source
      angle_to_source_pitch = source_angle_rad - pitch_center;
      angle_to_source_pitch > $pi ? angle_to_source_pitch -= TWO_PI;
      angle_to_source_pitch < -$pi ? angle_to_source_pitch += TWO_PI;
      abs_angle_dist_pitch = abs(angle_to_source_pitch);
      
      // Modulate pitch based on distance (like filter)
      half_opening_pitch = pitch_opening_angle * 0.5;
      distance_from_edge_pitch = abs_angle_dist_pitch - half_opening_pitch;
      
      distance_from_edge_pitch < 0 ? (
        // Inside mouth - NO pitch shift (0 semitones)
        modulated_semitones = 0;
      ) : (
        // Outside mouth - interpolate from 0 to target semitones
        // Opposite side (180°) = full target pitch
        max_distance_pitch = $pi - half_opening_pitch;
        t_pitch = min(1.0, distance_from_edge_pitch / max_distance_pitch);
        modulated_semitones = pitch_semitones * t_pitch;
      );
      
      // Calculate Pitch Ratio
      // Rule: 2^(semitones/12). 
      // If +12st -> Ratio 2.0. If -12st -> Ratio 0.5.
      pitch_ratio = 2 ^ (modulated_semitones / 12.0);
      pitch_ratio = max(0.25, min(4.0, pitch_ratio));
      
      // Calculate Pitch Phase Increment (Relative to Write Speed)
      // Inc = Ratio - 1.0. 
      // Ratio 1.0 -> Inc 0.0 (Read follows Write at fixed distance).
      // Ratio 2.0 -> Inc 1.0 (Read catches up to Write).
      // Ratio 0.5 -> Inc -0.5 (Read falls behind Write).
      phase_inc = pitch_ratio - 1.0;
      
      // Accumulate phase
      pitch_read_phase += phase_inc;
      
      // Wrap phase continuously - USING SAFE SYNTAX
      while (pitch_read_phase >= PITCH_GRAIN_SIZE) ( pitch_read_phase -= PITCH_GRAIN_SIZE; );
      while (pitch_read_phase < 0) ( pitch_read_phase += PITCH_GRAIN_SIZE; );
      
      // Calculate read position
      // Base delay is PITCH_GRAIN_SIZE. Phase makes delay smaller (catches up).
      read_pos = pitch_write_pos - PITCH_GRAIN_SIZE + pitch_read_phase;
      
      // Buffer wrapping - USING SAFE SYNTAX
      while (read_pos < 0) ( read_pos += PITCH_BUFFER_SIZE; );
      while (read_pos >= PITCH_BUFFER_SIZE) ( read_pos -= PITCH_BUFFER_SIZE; );
      
      read_int = floor(read_pos);
      read_frac = read_pos - read_int;
      read_next = (read_int + 1) % PITCH_BUFFER_SIZE;
      
      // Linear interpolation
      pitched_L = pitch_buffer[read_int * 5 + 0] * (1 - read_frac) + pitch_buffer[read_next * 5 + 0] * read_frac;
      pitched_R = pitch_buffer[read_int * 5 + 1] * (1 - read_frac) + pitch_buffer[read_next * 5 + 1] * read_frac;
      pitched_C = pitch_buffer[read_int * 5 + 2] * (1 - read_frac) + pitch_buffer[read_next * 5 + 2] * read_frac;
      pitched_Ls = pitch_buffer[read_int * 5 + 3] * (1 - read_frac) + pitch_buffer[read_next * 5 + 3] * read_frac;
      pitched_Rs = pitch_buffer[read_int * 5 + 4] * (1 - read_frac) + pitch_buffer[read_next * 5 + 4] * read_frac;
      
      // Output with gain compensation
      // Standardize gain: 1.0 when no shift, slight boost when shifting to compensate interpolation
      gain_comp = 1.0 + 0.5 * min(1.0, abs(modulated_semitones) / 12.0);
      
      this[out_L] = pitched_L * gain_comp;
      this[out_R] = pitched_R * gain_comp;
      this[out_C] = pitched_C * gain_comp;
      this[out_Ls] = pitched_Ls * gain_comp;
      this[out_Rs] = pitched_Rs * gain_comp;
    );
    
    pitch_write_pos = (pitch_write_pos + 1) % PITCH_BUFFER_SIZE;
    
    // === APPLY LOW-PASS FILTER (after pitch) ===
    out_L = 6000; out_R = 6001; out_C = 6002; out_Ls = 6003; out_Rs = 6004;
    
    filter_mode > 0 ? (
      // Calculate filter coefficient from cutoff frequency
      // 4-pole cascade for steeper rolloff (24dB/octave)
      omega = TWO_PI * cutoff_freq / srate;
      decay = exp(-omega);
      coeff = 1 - decay;
      
      // Channel L - 4 cascaded poles
      flt_L.z1 = flt_L.z1 * decay + this[out_L] * coeff;
      flt_L.z2 = flt_L.z2 * decay + flt_L.z1 * coeff;
      flt_L.z3 = flt_L.z3 * decay + flt_L.z2 * coeff;
      flt_L.z4 = flt_L.z4 * decay + flt_L.z3 * coeff;
      
      // Channel R
      flt_R.z1 = flt_R.z1 * decay + this[out_R] * coeff;
      flt_R.z2 = flt_R.z2 * decay + flt_R.z1 * coeff;
      flt_R.z3 = flt_R.z3 * decay + flt_R.z2 * coeff;
      flt_R.z4 = flt_R.z4 * decay + flt_R.z3 * coeff;
      
      // Channel C
      flt_C.z1 = flt_C.z1 * decay + this[out_C] * coeff;
      flt_C.z2 = flt_C.z2 * decay + flt_C.z1 * coeff;
      flt_C.z3 = flt_C.z3 * decay + flt_C.z2 * coeff;
      flt_C.z4 = flt_C.z4 * decay + flt_C.z3 * coeff;
      
      // Channel Ls
      flt_Ls.z1 = flt_Ls.z1 * decay + this[out_Ls] * coeff;
      flt_Ls.z2 = flt_Ls.z2 * decay + flt_Ls.z1 * coeff;
      flt_Ls.z3 = flt_Ls.z3 * decay + flt_Ls.z2 * coeff;
      flt_Ls.z4 = flt_Ls.z4 * decay + flt_Ls.z3 * coeff;
      
      // Channel Rs
      flt_Rs.z1 = flt_Rs.z1 * decay + this[out_Rs] * coeff;
      flt_Rs.z2 = flt_Rs.z2 * decay + flt_Rs.z1 * coeff;
      flt_Rs.z3 = flt_Rs.z3 * decay + flt_Rs.z2 * coeff;
      flt_Rs.z4 = flt_Rs.z4 * decay + flt_Rs.z3 * coeff;
      
      // Apply resonance (feedback from output) - ADAPTIVE
      // Lower frequencies need less resonance to stay stable
      freq_factor = cutoff_freq / 20000.0;  // 0..1
      freq_factor = max(0.1, freq_factor);   // Minimum 0.1
      
      resonance_gain = (filter_resonance - 0.5) * 0.05 * freq_factor;  // Scaled by frequency
      resonance_gain = max(0, min(0.08, resonance_gain));  // Hard limit 0.08
      
      resonance_gain > 0.001 ? (
        flt_L.z1 += flt_L.z4 * resonance_gain;
        flt_R.z1 += flt_R.z4 * resonance_gain;
        flt_C.z1 += flt_C.z4 * resonance_gain;
        flt_Ls.z1 += flt_Ls.z4 * resonance_gain;
        flt_Rs.z1 += flt_Rs.z4 * resonance_gain;
      );
      
      // Output from 4th pole with hard clipping (±1.0)
      this[out_L] = max(-1.0, min(1.0, flt_L.z4));
      this[out_R] = max(-1.0, min(1.0, flt_R.z4));
      this[out_C] = max(-1.0, min(1.0, flt_C.z4));
      this[out_Ls] = max(-1.0, min(1.0, flt_Ls.z4));
      this[out_Rs] = max(-1.0, min(1.0, flt_Rs.z4));
    );
    
    // === SEND PAC-MAN (Output to channels 7-12) ===
    send_mode = slider27;
    
    send_mode > 0 ? (
      send_opening_angle = slider29 * $pi / 180.0;
      send_amount = slider30;
      
      // Calculate send center angle
      send_mode == 1 ? (
        send_center = phantom_angle_rad + slider28 * $pi / 180.0;
      ) : (
        send_center = slider28 * $pi / 180.0;
      );
      
      // Normalize send center
      send_center > $pi ? send_center -= TWO_PI;
      send_center < -$pi ? send_center += TWO_PI;
      
      // Calculate angle to source from send center
      angle_to_source_send = source_angle_rad - send_center;
      angle_to_source_send > $pi ? angle_to_source_send -= TWO_PI;
      angle_to_source_send < -$pi ? angle_to_source_send += TWO_PI;
      abs_angle_dist_send = abs(angle_to_source_send);
      
      // Send zone with fade
      half_opening_send = send_opening_angle * 0.5;
      fade_zone_send = half_opening_send * slider31;
      distance_from_edge_send = abs_angle_dist_send - half_opening_send;
      
      distance_from_edge_send < 0 ? (
        send_strength = 0;  // Inside mouth - no send
      ) : distance_from_edge_send < fade_zone_send ? (
        t_send = distance_from_edge_send / fade_zone_send;
        send_strength = t_send;  // Fade zone
      ) : (
        send_strength = 1.0;  // Outside - full send
      );
      
      // Apply send amount
      send_gain = send_strength * send_amount;
    ) : (
      send_gain = 0;
    );
    
    // === OUTPUT CHANNELS ===
    spl0 = this[out_L];
    spl1 = this[out_R];
    spl2 = this[out_C];
    spl3 = in_LFE;  // LFE passthrough (no panning)
    spl4 = this[out_Ls];
    spl5 = this[out_Rs];
    
    // Send outputs (7-12) - всі канали з send gain
    spl6 = this[out_L] * send_gain;
    spl7 = this[out_R] * send_gain;
    spl8 = this[out_C] * send_gain;
    spl9 = this[out_Ls] * send_gain;
    spl10 = this[out_Rs] * send_gain;
    spl11 = 0;  // Reserved
  );

  // === METERS (always active, post-output) ===
  meter_L = spl0;
  meter_R = spl1;
  meter_C = spl2;
  meter_Ls = spl4;
  meter_Rs = spl5;

  abs_L = abs(meter_L);
  abs_R = abs(meter_R);
  abs_C = abs(meter_C);
  abs_Ls = abs(meter_Ls);
  abs_Rs = abs(meter_Rs);

  m_dec = 0.9998;
  peak_level[0] = max(peak_level[0] * m_dec, abs_L);
  peak_level[1] = max(peak_level[1] * m_dec, abs_R);
  peak_level[2] = max(peak_level[2] * m_dec, abs_C);
  peak_level[3] = max(peak_level[3] * m_dec, abs_Ls);
  peak_level[4] = max(peak_level[4] * m_dec, abs_Rs);

  rms_acc[0] += meter_L * meter_L;
  rms_acc[1] += meter_R * meter_R;
  rms_acc[2] += meter_C * meter_C;
  rms_acc[3] += meter_Ls * meter_Ls;
  rms_acc[4] += meter_Rs * meter_Rs;

  // LFE metering
  meter_LFE = spl3;
  abs_LFE = abs(meter_LFE);
  lfe_peak[0] = max(lfe_peak[0] * m_dec, abs_LFE);
  lfe_rms_acc[0] += meter_LFE * meter_LFE;

  // --- LUFS (K-weighted from post-output channels) ---
  // Channel 0: L
  kw_in = meter_L;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[0] + kw_b2_hp * kw_z2[0] - kw_a1_hp * kw_z1[1] - kw_a2_hp * kw_z2[1];
  kw_z2[0] = kw_z1[0]; kw_z1[0] = kw_in;
  kw_z2[1] = kw_z1[1]; kw_z1[1] = kw_out;
  kw_in = kw_out;
  kw_L = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[2] + kw_b2_hs * kw_z2[2] - kw_a1_hs * kw_z1[3] - kw_a2_hs * kw_z2[3];
  kw_z2[2] = kw_z1[2]; kw_z1[2] = kw_in;
  kw_z2[3] = kw_z1[3]; kw_z1[3] = kw_L;

  // Channel 1: R
  kw_in = meter_R;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[4] + kw_b2_hp * kw_z2[4] - kw_a1_hp * kw_z1[5] - kw_a2_hp * kw_z2[5];
  kw_z2[4] = kw_z1[4]; kw_z1[4] = kw_in;
  kw_z2[5] = kw_z1[5]; kw_z1[5] = kw_out;
  kw_in = kw_out;
  kw_R = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[6] + kw_b2_hs * kw_z2[6] - kw_a1_hs * kw_z1[7] - kw_a2_hs * kw_z2[7];
  kw_z2[6] = kw_z1[6]; kw_z1[6] = kw_in;
  kw_z2[7] = kw_z1[7]; kw_z1[7] = kw_R;

  // Channel 2: C
  kw_in = meter_C;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[8] + kw_b2_hp * kw_z2[8] - kw_a1_hp * kw_z1[9] - kw_a2_hp * kw_z2[9];
  kw_z2[8] = kw_z1[8]; kw_z1[8] = kw_in;
  kw_z2[9] = kw_z1[9]; kw_z1[9] = kw_out;
  kw_in = kw_out;
  kw_C = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[10] + kw_b2_hs * kw_z2[10] - kw_a1_hs * kw_z1[11] - kw_a2_hs * kw_z2[11];
  kw_z2[10] = kw_z1[10]; kw_z1[10] = kw_in;
  kw_z2[11] = kw_z1[11]; kw_z1[11] = kw_C;

  // Channel 3: Ls
  kw_in = meter_Ls;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[12] + kw_b2_hp * kw_z2[12] - kw_a1_hp * kw_z1[13] - kw_a2_hp * kw_z2[13];
  kw_z2[12] = kw_z1[12]; kw_z1[12] = kw_in;
  kw_z2[13] = kw_z1[13]; kw_z1[13] = kw_out;
  kw_in = kw_out;
  kw_Ls = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[14] + kw_b2_hs * kw_z2[14] - kw_a1_hs * kw_z1[15] - kw_a2_hs * kw_z2[15];
  kw_z2[14] = kw_z1[14]; kw_z1[14] = kw_in;
  kw_z2[15] = kw_z1[15]; kw_z1[15] = kw_Ls;

  // Channel 4: Rs
  kw_in = meter_Rs;
  kw_out = kw_b0_hp * kw_in + kw_b1_hp * kw_z1[16] + kw_b2_hp * kw_z2[16] - kw_a1_hp * kw_z1[17] - kw_a2_hp * kw_z2[17];
  kw_z2[16] = kw_z1[16]; kw_z1[16] = kw_in;
  kw_z2[17] = kw_z1[17]; kw_z1[17] = kw_out;
  kw_in = kw_out;
  kw_Rs = kw_b0_hs * kw_in + kw_b1_hs * kw_z1[18] + kw_b2_hs * kw_z2[18] - kw_a1_hs * kw_z1[19] - kw_a2_hs * kw_z2[19];
  kw_z2[18] = kw_z1[18]; kw_z1[18] = kw_in;
  kw_z2[19] = kw_z1[19]; kw_z1[19] = kw_Rs;

  // Weighted mean square (L, R, C = 1.0; Ls/Rs = 1.7)
  lufs_ms = kw_L*kw_L + kw_R*kw_R + kw_C*kw_C + 1.7*kw_Ls*kw_Ls + 1.7*kw_Rs*kw_Rs;

  lufs_win_acc += lufs_ms;
  (lufs_win_pos += 1) >= lufs_win_len ? (
    lufs_win_pos = 0;
    lufs_win_cnt += 1;
    lval = lufs_win_acc;
    lufs_win_acc = 0;

    prev_lval = lufs_buf[lufs_cur_buf];
    lufs_buf[lufs_cur_buf] = lval;
    lufs_cur_buf += 1;
    lufs_cur_buf >= lufs_m_win_cnt ? lufs_cur_buf = 0;

    prev_lval2 = lufs_buf2[lufs_cur_buf2];
    lufs_buf2[lufs_cur_buf2] = lval;
    lufs_cur_buf2 += 1;
    lufs_cur_buf2 >= lufs_s_win_cnt ? lufs_cur_buf2 = 0;

    lufs_m_sum += (lval - prev_lval) * lufs_i_win_len;
    lufs_s_sum += (lval - prev_lval2) * lufs_i_win_len2;

    lufs_m_sum > 0 && lufs_win_cnt >= lufs_m_win_cnt ? (
      lufs_m_db = 0.8 + log(lufs_m_sum) * 10 / log(10);

      a = ((lufs_m_db + 70) * BINS_PER_DB) | 0;
      a >= 0 ? (
        a >= NUM_BINS ? a = NUM_BINS - 1;
        lufs_a_sum += lufs_m_sum;
        lufs_a_sum_cnt += 1;
        lufs_a_hist[2 * a] += 1;
        lufs_a_hist[2 * a + 1] += lufs_m_sum;

        lufs_a_db = 0.8 + log(lufs_a_sum / lufs_a_sum_cnt) * 10 / log(10);
        lufs_a_gate = ((lufs_a_db - 10 + 70) * BINS_PER_DB) | 0;

        lufs_i_sum = 0;
        lufs_i_cnt = 0;
        bin = max(lufs_a_gate, 0);
        loop(NUM_BINS - bin,
          lufs_i_cnt += lufs_a_hist[2 * bin];
          lufs_i_sum += lufs_a_hist[2 * bin + 1];
          bin += 1;
        );
        lufs_i_db = lufs_i_sum > 0 ? 0.8 + log(lufs_i_sum / lufs_i_cnt) * 10 / log(10) : -100;
      );
    );

    lufs_s_sum > 0 && lufs_win_cnt >= lufs_s_win_cnt ? (
      lufs_s_db = 0.8 + log(lufs_s_sum) * 10 / log(10);
    );

    lufs_mom = lufs_m_db;
    lufs_short = lufs_s_db;
    lufs_int = lufs_i_db;
  );

  // Smooth LUFS display
  lufs_mom_disp = lufs_mom_disp * 0.95 + lufs_mom * 0.05;
  lufs_short_disp = lufs_short_disp * 0.98 + lufs_short * 0.02;
  lufs_int_disp = lufs_int_disp * 0.995 + lufs_int * 0.005;

  // Periodic RMS computation
  rms_counter[0] += 1;
  rms_counter[0] >= RMS_WINDOW ? (
    inv_n = 1.0 / RMS_WINDOW;
    i = 0;
    loop(NUM_SPEAKERS,
      rms_level[i] = sqrt(rms_acc[i] * inv_n);
      rms_disp[i] = rms_disp[i] * 0.7 + rms_level[i] * 0.3;
      rms_acc[i] = 0;
      i += 1;
    );
    lfe_rms[0] = sqrt(lfe_rms_acc[0] * inv_n);
    lfe_rms_acc[0] = 0;
    rms_counter[0] = 0;
  );

  // === AUTOMATION OUTPUTS ===
  slider19 = current_source_angle_deg;
  slider20 = source_x;
  slider21 = source_y;
  sliderchange(slider19 | slider20 | slider21);

  // === CHANNEL MUTE (post-metering, affects output only) ===
  mute_mask = slider24;
  mute_mask > 0 ? (
    (mute_mask & 1)  ? (spl0 = 0; spl6 = 0);    // L + send L
    (mute_mask & 2)  ? (spl1 = 0; spl7 = 0);    // R + send R
    (mute_mask & 4)  ? (spl2 = 0; spl8 = 0);    // C + send C
    (mute_mask & 8)  ? spl3 = 0;                 // LFE (no send)
    (mute_mask & 16) ? (spl4 = 0; spl9 = 0);    // Ls + send Ls
    (mute_mask & 32) ? (spl5 = 0; spl10 = 0);   // Rs + send Rs
  );

@gfx 640 520
  // === COLOR PALETTE ===
  bg_r = 0.10; bg_g = 0.10; bg_b = 0.12;
  panel_r = 0.07; panel_g = 0.07; panel_b = 0.08;
  brd_r = 0.149; brd_g = 0.149; brd_b = 0.173;
  acc_r = 0.20; acc_g = 0.80; acc_b = 0.40;
  mtr_r = 0.15; mtr_g = 0.65; mtr_b = 0.35;
  txt_r = 0.80; txt_g = 0.80; txt_b = 0.80;
  
  // === SCALING ===
  sc = min(gfx_w / 640, gfx_h / 520);
  sc < 0.5 ? sc = 0.5;
  sc > 2.0 ? sc = 2.0;
  font_sm = max(10, (11 * sc)|0);
  font_md = max(11, (13 * sc)|0);
  font_lg = max(13, (16 * sc)|0);
  gfx_setfont(1, "Arial", font_lg, 'b');
  gfx_setfont(2, "Arial", font_md);
  gfx_setfont(3, "Arial", font_sm);
  
  // === BACKGROUND ===
  gfx_set(bg_r, bg_g, bg_b, 1.0);
  gfx_rect(0, 0, gfx_w, gfx_h);
  
  // === TITLE BAR WITH BUTTONS ===
  title_h = max(26, (30 * sc)|0);
  pad = max(8, (12 * sc)|0);
  btn_gap = max(10, (12 * sc)|0);
  btn_h = max(18, (20 * sc)|0);
  
  gfx_set(panel_r, panel_g, panel_b, 1.0);
  gfx_rect(0, 0, gfx_w, title_h);
  gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_line(0, title_h, gfx_w, title_h);

  // Title text (matching SurroundScope style)
  gfx_setfont(1);
  gfx_set(acc_r, acc_g, acc_b, 1);
  gfx_x = pad; gfx_y = (title_h - font_lg) * 0.5;
  gfx_drawstr("SBP PHANTOM FOLLOWER");
  title_end_x = gfx_x;

  // Pac-Man Display mode buttons
  gfx_setfont(3);
  btn_y = (title_h - btn_h) * 0.5;

  #btn1_text = "NONE";
  gfx_measurestr(#btn1_text, btn1_w, btn1_h);
  btn1_w += max(8, (12 * sc)|0);
  btn1_x = title_end_x + btn_gap;
  pac_display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h);
  pac_display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn1_x, btn_y, btn1_w, btn_h, 0);
  pac_display_mode == 0 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn1_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn1_h) * 0.5;
  gfx_drawstr(#btn1_text);
  
  #btn2_text = "FILTER";
  gfx_measurestr(#btn2_text, btn2_w, btn2_h);
  btn2_w += max(8, (12 * sc)|0);
  btn2_x = btn1_x + btn1_w + max(4, (6 * sc)|0);
  pac_display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h);
  pac_display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn2_x, btn_y, btn2_w, btn_h, 0);
  pac_display_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn2_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn2_h) * 0.5;
  gfx_drawstr(#btn2_text);
  
  #btn3_text = "PITCH";
  gfx_measurestr(#btn3_text, btn3_w, btn3_h);
  btn3_w += max(8, (12 * sc)|0);
  btn3_x = btn2_x + btn2_w + max(4, (6 * sc)|0);
  pac_display_mode == 2 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h);
  pac_display_mode == 2 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn3_x, btn_y, btn3_w, btn_h, 0);
  pac_display_mode == 2 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn3_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn3_h) * 0.5;
  gfx_drawstr(#btn3_text);
  
  #btn4_text = "SEND";
  gfx_measurestr(#btn4_text, btn4_w, btn4_h);
  btn4_w += max(8, (12 * sc)|0);
  btn4_x = btn3_x + btn3_w + max(4, (6 * sc)|0);
  pac_display_mode == 3 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn4_x, btn_y, btn4_w, btn_h);
  pac_display_mode == 3 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn4_x, btn_y, btn4_w, btn_h, 0);
  pac_display_mode == 3 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn4_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn4_h) * 0.5;
  gfx_drawstr(#btn4_text);
  
  #btn_all_text = "ALL";
  gfx_measurestr(#btn_all_text, btn_all_w, btn_all_h);
  btn_all_w += max(8, (12 * sc)|0);
  btn_all_x = btn4_x + btn4_w + max(4, (6 * sc)|0);
  pac_display_mode == 4 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn_all_x, btn_y, btn_all_w, btn_h);
  pac_display_mode == 4 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn_all_x, btn_y, btn_all_w, btn_h, 0);
  pac_display_mode == 4 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn_all_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn_all_h) * 0.5;
  gfx_drawstr(#btn_all_text);
  
  // Compact View button on the right
  #btn5_text = ui_mode == 0 ? "COMPACT" : "FULL UI";
  gfx_measurestr(#btn5_text, btn5_w, btn5_h);
  btn5_w += max(8, (12 * sc)|0);
  btn5_x = gfx_w - pad - btn5_w;
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 0.3) : gfx_set(brd_r, brd_g, brd_b, 1);
  gfx_rect(btn5_x, btn_y, btn5_w, btn_h);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_rect(btn5_x, btn_y, btn5_w, btn_h, 0);
  ui_mode == 1 ? gfx_set(acc_r, acc_g, acc_b, 1) : gfx_set(txt_r, txt_g, txt_b, 0.5);
  gfx_x = btn5_x + max(4, (6 * sc)|0);
  gfx_y = btn_y + (btn_h - btn5_h) * 0.5;
  gfx_drawstr(#btn5_text);
  
  // === MOUSE INTERACTION - Title Bar Buttons ===
  mouse_clicked_ui = 0;
  
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    // None button
    mouse_x >= btn1_x && mouse_x <= btn1_x + btn1_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider16 = 0;
      pac_display_mode = 0;
      sliderchange(slider16);
      mouse_clicked_ui = 1;
    ) : 
    // Filter button
    mouse_x >= btn2_x && mouse_x <= btn2_x + btn2_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider16 = 1;
      pac_display_mode = 1;
      sliderchange(slider16);
      mouse_clicked_ui = 1;
    ) : 
    // Pitch button
    mouse_x >= btn3_x && mouse_x <= btn3_x + btn3_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider16 = 2;
      pac_display_mode = 2;
      sliderchange(slider16);
      mouse_clicked_ui = 1;
    ) : 
    // Send button
    mouse_x >= btn4_x && mouse_x <= btn4_x + btn4_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider16 = 3;
      pac_display_mode = 3;
      sliderchange(slider16);
      mouse_clicked_ui = 1;
    ) : 
    // All button
    mouse_x >= btn_all_x && mouse_x <= btn_all_x + btn_all_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider16 = 4;
      pac_display_mode = 4;
      sliderchange(slider16);
      mouse_clicked_ui = 1;
    ) : 
    // Compact/Full UI button
    mouse_x >= btn5_x && mouse_x <= btn5_x + btn5_w &&
    mouse_y >= btn_y && mouse_y <= btn_y + btn_h ? (
      slider26 = 1 - slider26;
      ui_mode = slider26;
      slider_show(UI_SLIDERS_MASK, slider26 ? 0 : 1);
      sliderchange(slider26);
      mouse_clicked_ui = 1;
    );
  );

  // === ITU-R BS.775 ROOM PANEL ===
  lfe_h = max(24, (30 * sc)|0);
  panel_x0 = 20 * sc;
  panel_y0 = title_h + 10 * sc;  // Below title bar
  panel_w = 600 * sc;
  panel_h = gfx_h - panel_y0 - lfe_h - pad * 0.5 - 10 * sc;
  panel_h < 200 ? panel_h = 200;
  panel_pad = 10 * sc;
  meter_panel_w = max(100, (130 * sc)|0);
  meter_panel_gap = max(6, (8 * sc)|0);
  lfe_top = gfx_h - lfe_h - (pad * 0.5);
  
  // Panel background
  gfx_set(panel_r, panel_g, panel_b, 1.0);
  gfx_rect(panel_x0, panel_y0, panel_w, panel_h);
  
  // Meter panel geometry (right side)
  meter_panel_x0 = panel_x0 + panel_w - panel_pad - meter_panel_w;
  meter_panel_y0 = panel_y0 + panel_pad;
  meter_panel_h = panel_h - panel_pad * 2;

  // === ITU-R BS.775 CIRCLE (listening zone) ===
  // ITU-R BS.775 standard geometry (matches SurroundScope)
  room_x0 = panel_x0 + panel_pad;
  room_y0 = panel_y0 + panel_pad;
  room_w = panel_w - 2 * panel_pad - meter_panel_w - meter_panel_gap;
  room_h = panel_h - 2 * panel_pad;

  // Circle center and radius (0.35 from center)
  circle_cx = room_x0 + room_w * 0.5;
  circle_cy = room_y0 + room_h * 0.5;
  circle_r = min(room_w, room_h) * 0.35;

  // Circle fill (lighter)
  gfx_set(0.12, 0.12, 0.14, 0.35);
  gfx_circle(circle_cx, circle_cy, circle_r, 1);

  // Circle outline (lighter)
  gfx_set(0.30, 0.30, 0.35, 0.9);
  gfx_circle(circle_cx, circle_cy, circle_r, 0);

  // === PAC-MAN VISUALIZATIONS (Filter + Pitch + Send) ===
  // Drawing order: Filter first (bottom), then Pitch (middle), then Send, then Speakers, then Listener (top)
  pac_display_mode = slider16;  // 0=None, 1=Filter only, 2=Pitch only, 3=Send only, 4=All
  room_size = min(room_w, room_h);

  // Calculate listener position (needed for Pac-Man drawing)
  listener_x = room_x0 + listen_x * room_w;
  listener_y = room_y0 + listen_y * room_h;
  
  // === SMOOTH PHANTOM CENTER ANGLE (for PAC-MAN display, prevents glitches) ===
  phantom_dx = slider1 - listen_x;
  phantom_dy = slider2 - listen_y;
  phantom_angle_current = atan2(phantom_dx, -phantom_dy) * 180.0 / $pi;
  
  // Circular smoothing (handle -180/+180 wrap correctly)
  phantom_diff = phantom_angle_current - phantom_angle_smooth;
  phantom_diff > 180 ? phantom_diff -= 360;
  phantom_diff < -180 ? phantom_diff += 360;
  phantom_angle_smooth += phantom_diff * 0.20;  // Smooth for display
  phantom_angle_smooth > 180 ? phantom_angle_smooth -= 360;
  phantom_angle_smooth < -180 ? phantom_angle_smooth += 360;
  phantom_angle_rad_smooth = phantom_angle_smooth * $pi / 180.0;
  listener_x = room_x0 + listen_x * room_w;
  listener_y = room_y0 + listen_y * room_h;
  
  // === FILTER PAC-MAN (Yellow) - Draw First (Bottom Layer) ===
  (pac_display_mode == 1 || pac_display_mode == 4) && slider11 > 0 ? (
    filter_mode = slider11;
    filter_opening_angle = slider13 * $pi / 180.0;
    filter_target_freq = slider14;

    // Calculate filter center angle (use smoothed phantom angle to prevent glitches)
    filter_mode == 1 ? (
      // Follow Phantom mode
      filter_center = phantom_angle_rad_smooth + slider12 * $pi / 180.0;
    ) : (
      filter_center = slider12 * $pi / 180.0;
    );
    
    // Size: if All mode, make slightly larger; otherwise normal
    pakman_r_filter = pac_display_mode == 4 ? room_size * 0.38 : room_size * 0.35;
    
    // Calculate opening zone (mouth)
    half_opening = filter_opening_angle * 0.5;
    mouth_left = filter_center - half_opening;
    mouth_right = filter_center + half_opening;
    
    // Normalize mouth angles
    mouth_left > $pi ? mouth_left -= TWO_PI;
    mouth_left < -$pi ? mouth_left += TWO_PI;
    mouth_right > $pi ? mouth_right -= TWO_PI;
    mouth_right < -$pi ? mouth_right += TWO_PI;
    
    // Draw filled yellow circle - intensity based on cutoff frequency
    // Normalize: 20kHz=min opacity, target freq=max opacity
    filter_visual_strength = (20000 - filter_target_freq) / 19950.0;  // 0..1
    pac_alpha = 0.15 + 0.325 * filter_visual_strength;
    gfx_set(1.0, 1.0, 0.0, pac_alpha);
    gfx_circle(listener_x, listener_y, pakman_r_filter, 1);
    
    // Erase mouth with circle fill color
    gfx_set(0.12, 0.12, 0.14, 1.0);
    angle_step = $pi / 180.0;
    current_angle = mouth_left;
    angle_diff = mouth_right - mouth_left;
    angle_diff < 0 ? angle_diff += TWO_PI;
    steps_needed = (angle_diff / angle_step) | 0;
    steps_needed = min(360, max(1, steps_needed));
    
    i = 0;
    loop(steps_needed,
      next_angle = mouth_left + i * angle_step;
      x1 = listener_x + sin(next_angle) * pakman_r_filter * 1.008;
      y1 = listener_y - cos(next_angle) * pakman_r_filter * 1.008;
      x2 = listener_x + sin(next_angle + angle_step) * pakman_r_filter * 1.008;
      y2 = listener_y - cos(next_angle + angle_step) * pakman_r_filter * 1.008;
      gfx_triangle(listener_x, listener_y, x1, y1, x2, y2);
      i += 1;
    );
    
    // Mouth edges (yellow lines)
    pac_mouth_alpha = 0.4 + 0.5 * filter_visual_strength;
    gfx_set(1.0, 1.0, 0.0, pac_mouth_alpha);
    mouth_right_x = listener_x + sin(mouth_right) * pakman_r_filter;
    mouth_right_y = listener_y - cos(mouth_right) * pakman_r_filter;
    mouth_left_x = listener_x + sin(mouth_left) * pakman_r_filter;
    mouth_left_y = listener_y - cos(mouth_left) * pakman_r_filter;
    gfx_line(listener_x, listener_y, mouth_right_x, mouth_right_y);
    gfx_line(listener_x, listener_y, mouth_left_x, mouth_left_y);
  );
  
  // === PITCH PAC-MAN (Cyan/Blue) ===
  (pac_display_mode == 2 || pac_display_mode == 4) && slider17 > 0 ? (
    pitch_mode = slider17;
    pitch_opening_angle = slider22 * $pi / 180.0;
    pitch_amount = abs(slider23);
    
    // Calculate pitch center angle (use smoothed phantom angle to prevent glitches)
    pitch_mode == 1 ? (
      pitch_center = phantom_angle_rad_smooth + slider18 * $pi / 180.0;
    ) : (
      pitch_center = slider18 * $pi / 180.0;
    );
    
    // Size: if All mode, make smaller; otherwise normal
    pakman_r_pitch = pac_display_mode == 4 ? room_size * 0.32 : room_size * 0.35;
    
    // Calculate opening zone
    half_opening_pitch = pitch_opening_angle * 0.5;
    mouth_left_pitch = pitch_center - half_opening_pitch;
    mouth_right_pitch = pitch_center + half_opening_pitch;
    
    // Normalize
    mouth_left_pitch > $pi ? mouth_left_pitch -= TWO_PI;
    mouth_left_pitch < -$pi ? mouth_left_pitch += TWO_PI;
    mouth_right_pitch > $pi ? mouth_right_pitch -= TWO_PI;
    mouth_right_pitch < -$pi ? mouth_right_pitch += TWO_PI;
    
    // Draw filled cyan circle
    pitch_alpha = 0.15 + 0.325 * (pitch_amount / 12.0);  // Normalize to 0-1
    gfx_set(0.0, 0.9, 1.0, pitch_alpha);  // Cyan color
    gfx_circle(listener_x, listener_y, pakman_r_pitch, 1);
    
    // Erase mouth
    gfx_set(0.12, 0.12, 0.14, 1.0);
    angle_step = $pi / 180.0;
    current_angle = mouth_left_pitch;
    angle_diff = mouth_right_pitch - mouth_left_pitch;
    angle_diff < 0 ? angle_diff += TWO_PI;
    steps_needed = (angle_diff / angle_step) | 0;
    steps_needed = min(360, max(1, steps_needed));
    
    i = 0;
    loop(steps_needed,
      next_angle = mouth_left_pitch + i * angle_step;
      x1 = listener_x + sin(next_angle) * pakman_r_pitch * 1.008;
      y1 = listener_y - cos(next_angle) * pakman_r_pitch * 1.008;
      x2 = listener_x + sin(next_angle + angle_step) * pakman_r_pitch * 1.008;
      y2 = listener_y - cos(next_angle + angle_step) * pakman_r_pitch * 1.008;
      gfx_triangle(listener_x, listener_y, x1, y1, x2, y2);
      i += 1;
    );
    
    // Mouth edges (cyan lines)
    pitch_mouth_alpha = 0.4 + 0.5 * (pitch_amount / 12.0);
    gfx_set(0.0, 0.9, 1.0, pitch_mouth_alpha);
    mouth_right_x_p = listener_x + sin(mouth_right_pitch) * pakman_r_pitch;
    mouth_right_y_p = listener_y - cos(mouth_right_pitch) * pakman_r_pitch;
    mouth_left_x_p = listener_x + sin(mouth_left_pitch) * pakman_r_pitch;
    mouth_left_y_p = listener_y - cos(mouth_left_pitch) * pakman_r_pitch;
    gfx_line(listener_x, listener_y, mouth_right_x_p, mouth_right_y_p);
    gfx_line(listener_x, listener_y, mouth_left_x_p, mouth_left_y_p);
  );
  
  // === SEND PAC-MAN (Orange) ===
  (pac_display_mode == 3 || pac_display_mode == 4) && slider27 > 0 ? (
    send_mode = slider27;
    send_opening_angle = slider29 * $pi / 180.0;
    send_amount = slider30;
    
    // Calculate send center angle (use smoothed phantom angle to prevent glitches)
    send_mode == 1 ? (
      send_center = phantom_angle_rad_smooth + slider28 * $pi / 180.0;
    ) : (
      send_center = slider28 * $pi / 180.0;
    );
    
    // Size: if All mode, make smallest; otherwise normal
    pakman_r_send = pac_display_mode == 4 ? room_size * 0.26 : room_size * 0.35;
    
    // Calculate opening zone
    half_opening_send = send_opening_angle * 0.5;
    mouth_left_send = send_center - half_opening_send;
    mouth_right_send = send_center + half_opening_send;
    
    // Normalize
    mouth_left_send > $pi ? mouth_left_send -= TWO_PI;
    mouth_left_send < -$pi ? mouth_left_send += TWO_PI;
    mouth_right_send > $pi ? mouth_right_send -= TWO_PI;
    mouth_right_send < -$pi ? mouth_right_send += TWO_PI;
    
    // Draw filled orange circle
    send_alpha = 0.15 + 0.325 * (send_amount / 2.0);  // Normalize to 0-1
    gfx_set(1.0, 0.6, 0.0, send_alpha);  // Orange color (RGB: 1.0, 0.6, 0.0)
    gfx_circle(listener_x, listener_y, pakman_r_send, 1);
    
    // Erase mouth
    gfx_set(0.12, 0.12, 0.14, 1.0);
    angle_step = $pi / 180.0;
    angle_diff_send = mouth_right_send - mouth_left_send;
    angle_diff_send < 0 ? angle_diff_send += TWO_PI;
    steps_needed_send = (angle_diff_send / angle_step) | 0;
    steps_needed_send = min(360, max(1, steps_needed_send));
    
    i = 0;
    loop(steps_needed_send,
      next_angle_send = mouth_left_send + i * angle_step;
      x1_s = listener_x + sin(next_angle_send) * pakman_r_send * 1.008;
      y1_s = listener_y - cos(next_angle_send) * pakman_r_send * 1.008;
      x2_s = listener_x + sin(next_angle_send + angle_step) * pakman_r_send * 1.008;
      y2_s = listener_y - cos(next_angle_send + angle_step) * pakman_r_send * 1.008;
      gfx_triangle(listener_x, listener_y, x1_s, y1_s, x2_s, y2_s);
      i += 1;
    );
    
    // Mouth edges (orange lines)
    send_mouth_alpha = 0.4 + 0.5 * (send_amount / 2.0);
    gfx_set(1.0, 0.6, 0.0, send_mouth_alpha);
    mouth_right_x_s = listener_x + sin(mouth_right_send) * pakman_r_send;
    mouth_right_y_s = listener_y - cos(mouth_right_send) * pakman_r_send;
    mouth_left_x_s = listener_x + sin(mouth_left_send) * pakman_r_send;
    mouth_left_y_s = listener_y - cos(mouth_left_send) * pakman_r_send;
    gfx_line(listener_x, listener_y, mouth_right_x_s, mouth_right_y_s);
    gfx_line(listener_x, listener_y, mouth_left_x_s, mouth_left_y_s);
  );

  // === SPEAKER POSITIONS (drawn above all Pac-Man visualizations) ===
  gfx_setfont(2);

  i = 0;
  loop(NUM_SPEAKERS,
    sx = room_x0 + spk_x[i] * room_w;
    sy = room_y0 + spk_y[i] * room_h;

    // Speaker icon (small circle, brighter to stand out above pac-man)
    gfx_set(0.7, 0.7, 0.8, 1.0);
    gfx_circle(sx, sy, 7 * sc, 1);  // filled, slightly larger
    gfx_set(0.9, 0.9, 1.0, 1.0);
    gfx_circle(sx, sy, 7 * sc, 0);  // outline, brighter

    // Speaker labels
    i == 0 ? #spk_lbl = "L";
    i == 1 ? #spk_lbl = "R";
    i == 2 ? #spk_lbl = "C";
    i == 3 ? #spk_lbl = "Ls";
    i == 4 ? #spk_lbl = "Rs";

    gfx_set(txt_r, txt_g, txt_b, 1.0);  // Brighter text
    gfx_measurestr(#spk_lbl, lbl_w, lbl_h);
    gfx_x = sx - lbl_w * 0.5;
    gfx_y = sy - lbl_h - 10 * sc;  // Slightly higher
    gfx_drawstr(#spk_lbl);

    i += 1;
  );

  // === LISTENER POSITION (Top Layer - drawn last to be on top) ===
  gfx_set(0.5, 0.5, 0.6, 0.7);
  gfx_circle(listener_x, listener_y, 8 * sc, 1);  // filled
  gfx_set(0.7, 0.7, 0.8, 1.0);
  gfx_circle(listener_x, listener_y, 8 * sc, 0);  // outline
  
  // Label
  gfx_set(txt_r, txt_g, txt_b, 0.7);
  #listener_lbl = "LISTENER";
  gfx_measurestr(#listener_lbl, lbl_w, lbl_h);
  gfx_x = listener_x - lbl_w * 0.5;
  gfx_y = listener_y + 12 * sc;
  gfx_drawstr(#listener_lbl);
  
  // === PHANTOM CENTER MARKER (from input sliders) ===
  phantom_visual_x = room_x0 + slider1 * room_w;
  phantom_visual_y = room_y0 + slider2 * room_h;

  // === RADIUS CIRCLES (from listener to phantom/source) ===
  ph_dx_px = phantom_visual_x - listener_x;
  ph_dy_px = phantom_visual_y - listener_y;
  phantom_r_px = sqrt(ph_dx_px * ph_dx_px + ph_dy_px * ph_dy_px);
  gfx_set(0.50, 0.90, 1.00, 0.35);
  gfx_circle(listener_x, listener_y, phantom_r_px, 0);
  
  // Phantom marker (cyan/blue)
  gfx_set(0.3, 0.7, 0.9, 0.6);
  gfx_circle(phantom_visual_x, phantom_visual_y, 10 * sc, 1);  // filled
  gfx_set(0.5, 0.9, 1.0, 0.9);
  gfx_circle(phantom_visual_x, phantom_visual_y, 10 * sc, 0);  // outline
  
  // Crosshair
  gfx_line(phantom_visual_x - 6 * sc, phantom_visual_y, phantom_visual_x + 6 * sc, phantom_visual_y);
  gfx_line(phantom_visual_x, phantom_visual_y - 6 * sc, phantom_visual_x, phantom_visual_y + 6 * sc);
  
  // Label
  gfx_set(0.5, 0.9, 1.0, 1.0);
  #phantom_lbl = "PHANTOM";
  gfx_measurestr(#phantom_lbl, lbl_w, lbl_h);
  gfx_x = phantom_visual_x - lbl_w * 0.5;
  gfx_y = phantom_visual_y - lbl_h - 14 * sc;
  gfx_drawstr(#phantom_lbl);
  
  // === SOURCE MARKER (our panned position) ===
  source_visual_x = room_x0 + source_x * room_w;
  source_visual_y = room_y0 + source_y * room_h;

  src_dx_px = source_visual_x - listener_x;
  src_dy_px = source_visual_y - listener_y;
  source_r_px = sqrt(src_dx_px * src_dx_px + src_dy_px * src_dy_px);
  gfx_set(1.00, 0.60, 0.30, 0.35);
  gfx_circle(listener_x, listener_y, source_r_px, 0);
  
  // Source marker (orange/red - larger and more prominent)
  gfx_set(0.9, 0.3, 0.2, 0.7);
  gfx_circle(source_visual_x, source_visual_y, 12 * sc, 1);  // filled
  gfx_set(1.0, 0.6, 0.3, 1.0);
  gfx_circle(source_visual_x, source_visual_y, 12 * sc, 0);  // outline
  
  // Direction arrow (pointing outward from listener)
  arrow_angle = source_angle_smooth * $pi / 180.0;
  arrow_len = 18 * sc;
  arrow_x1 = source_visual_x + sin(arrow_angle) * arrow_len;
  arrow_y1 = source_visual_y - cos(arrow_angle) * arrow_len;
  gfx_set(1.0, 0.6, 0.3, 0.9);
  gfx_line(source_visual_x, source_visual_y, arrow_x1, arrow_y1);
  
  // Label
  gfx_set(1.0, 0.6, 0.3, 1.0);
  #source_lbl = "SOURCE";
  gfx_measurestr(#source_lbl, lbl_w, lbl_h);
  gfx_x = source_visual_x - lbl_w * 0.5;
  gfx_y = source_visual_y + 16 * sc;
  gfx_drawstr(#source_lbl);
  
  // === CONNECTION LINE (show relationship) ===
  gfx_set(0.6, 0.6, 0.8, 0.3);
  gfx_line(phantom_visual_x, phantom_visual_y, source_visual_x, source_visual_y);
  
  // === INFO OVERLAY ===
  gfx_setfont(2);
  info_x = panel_x0 + panel_pad;
  info_y = panel_y0 + panel_h - 60 * sc;
  
  // Mode display
  gfx_set(txt_r, txt_g, txt_b, 0.9);
  follower_mode == 0 ? #mode_str = "Mode: BYPASS";
  follower_mode == 1 ? #mode_str = "Mode: FOLLOW PHANTOM";
  follower_mode == 2 ? #mode_str = "Mode: FOLLOW PHANTOM INVERTED";
  follower_mode == 3 ? #mode_str = "Mode: MANUAL POSITION";
  gfx_x = info_x;
  gfx_y = info_y;
  gfx_drawstr(#mode_str);
  
  // Angle display
  info_y += 18 * sc;
  sprintf(#angle_str, "Source Angle: %.1f°", source_angle_smooth);
  gfx_x = info_x;
  gfx_y = info_y;
  gfx_drawstr(#angle_str);
  
  // Angle difference (if following phantom mode 1 or 2)
  follower_mode == 1 || follower_mode == 2 ? (
    info_y += 18 * sc;
    phantom_dx = slider1 - listen_x;
    phantom_dy = slider2 - listen_y;
    phantom_angle_rad = atan2(phantom_dx, -phantom_dy);
    phantom_angle_deg = phantom_angle_rad * 180.0 / $pi;
    angle_diff = source_angle_smooth - phantom_angle_deg;
    
    sprintf(#diff_str, "Angle Δ: %.1f°", angle_diff);
    gfx_x = info_x;
    gfx_y = info_y;
    gfx_drawstr(#diff_str);
  );
  
  // Filter info (if enabled)
  slider11 > 0 ? (
    info_x_left = panel_x0 + panel_pad;
    info_y_left = panel_y0 + panel_pad;

    gfx_set(0.9, 0.7, 0.3, 0.9);
    filter_mode == 1 ? #filter_mode_str = "Follow" : #filter_mode_str = "Independent";
    sprintf(#filter_str, "Filter: %s, Open: %.0f°", #filter_mode_str, slider13);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#filter_str);

    info_y_left += 18 * sc;
    sprintf(#amt_str, "Target: %.0f Hz", slider14);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#amt_str);
    
    info_y_left += 18 * sc;
    sprintf(#fade_str, "Res: %.2f", slider15);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#fade_str);
  );
  
  // Pitch info (if enabled)
  slider17 > 0 ? (
    info_x_left = panel_x0 + panel_pad;
    info_y_left = panel_y0 + panel_pad + 70 * sc;
    
    gfx_set(0.0, 0.9, 1.0, 0.9);  // Cyan for pitch
    pitch_mode_val = slider17;
    pitch_mode_val == 1 ? #pitch_mode_str = "Follow" : #pitch_mode_str = "Independent";
    sprintf(#pitch_str, "Pitch: %s, Open: %.0f°", #pitch_mode_str, slider22);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#pitch_str);
    
    info_y_left += 18 * sc;
    sprintf(#pitch_amt_str, "Semitones: %+.1f", slider23);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#pitch_amt_str);
    
    info_y_left += 18 * sc;
    sprintf(#pitch_grain_str, "Grain: %d", PITCH_GRAIN_SIZE);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#pitch_grain_str);
  );

  // Send info (if enabled)
  slider27 > 0 ? (
    info_x_left = panel_x0 + panel_pad;
    info_y_left = panel_y0 + panel_pad + 140 * sc;
    
    gfx_set(1.0, 0.6, 0.0, 0.9);  // Orange for send
    send_mode_val = slider27;
    send_mode_val == 1 ? #send_mode_str = "Follow" : #send_mode_str = "Independent";
    sprintf(#send_str, "Send: %s, Open: %.0f°", #send_mode_str, slider29);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#send_str);
    
    info_y_left += 18 * sc;
    sprintf(#send_amt_str, "Amount: %.0f%%", slider30 * 100);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#send_amt_str);
    
    info_y_left += 18 * sc;
    sprintf(#send_fade_str, "Fade: %.0f%%", slider31 * 100);
    gfx_x = info_x_left;
    gfx_y = info_y_left;
    gfx_drawstr(#send_fade_str);
  );

  // === RIGHT SIDE METER PANEL ===
  panel_w = meter_panel_w;
  panel_h = meter_panel_h;
  panel_x0 = meter_panel_x0;
  panel_y0 = meter_panel_y0;

  panel_pad = max(4, (6 * sc)|0);
  bar_gap = max(4, (6 * sc)|0);
  scale_w = max(20, (24 * sc)|0);

  gfx_set(panel_r, panel_g, panel_b, 1);
  gfx_rect(panel_x0, panel_y0, panel_w, panel_h);
  gfx_set(brd_r, brd_g, brd_b, 0.6);
  gfx_line(panel_x0, panel_y0, panel_x0 + panel_w, panel_y0);
  gfx_line(panel_x0, panel_y0 + panel_h, panel_x0 + panel_w, panel_y0 + panel_h);
  gfx_line(panel_x0, panel_y0, panel_x0, panel_y0 + panel_h);
  gfx_line(panel_x0 + panel_w, panel_y0, panel_x0 + panel_w, panel_y0 + panel_h);

  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = panel_x0 + panel_pad;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr("LEVELS");
  meter_mode == 0 ? #mode_lbl = "PEAK" : #mode_lbl = "RMS";
  gfx_measurestr(#mode_lbl, mw, mh);
  gfx_x = panel_x0 + panel_w - panel_pad - mw;
  gfx_y = panel_y0 + panel_pad;
  gfx_drawstr(#mode_lbl);

  left_scale_w = max(10, (12 * sc)|0);
  meter_area_w = panel_w - panel_pad * 2 - scale_w - left_scale_w;
  bar_w = (meter_area_w - bar_gap * 4) / 5;
  bar_w < 4 ? bar_w = 4;
  label_y = panel_y0 + panel_pad + font_sm + 20 * sc;
  value_y = label_y + font_sm + 4 * sc;
  bar_top = value_y + font_sm + 6 * sc;

  // Calculate LUFS block size early
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_calc = panel_y0 + panel_h - panel_pad - lufs_block_h;

  // Vertical divergence sliders + mute squares
  div_v_h = max(30, (40 * sc)|0);
  div_gap = max(2, (3 * sc)|0);
  mute_sq_size = max(14, (18 * sc)|0);
  mute_gap = max(2, (3 * sc)|0);

  bar_h = lufs_y0_calc - bar_top - panel_pad - div_v_h - div_gap - mute_sq_size - mute_gap;
  bar_h < 30 ? bar_h = 30;
  scale_span = 60.0;
  center_y = bar_top + bar_h * 0.5;
  meter_x0 = panel_x0 + panel_pad + left_scale_w;

  // Target reference line centered (meters only)
  gfx_set(0.70, 0.90, 0.25, 0.55);
  gfx_line(meter_x0, center_y, meter_x0 + meter_area_w, center_y);

  // Left-side reference and 0 dB markers
  zero_y = center_y - (0 - target_level) / scale_span * bar_h;
  zero_y = min(bar_top + bar_h, max(bar_top, zero_y));
  gfx_set(0.55, 0.55, 0.55, 0.6);
  gfx_line(panel_x0 + panel_pad, zero_y, meter_x0 - 2, zero_y);
  sprintf(#zero_str, "%d", 0);
  gfx_setfont(3);
  gfx_measurestr(#zero_str, zw, zh);
  gfx_set(panel_r, panel_g, panel_b, 0.85);
  gfx_rect(panel_x0 + 1, zero_y - zh * 0.5, zw + 2, zh + 2);
  gfx_set(txt_r, txt_g, txt_b, 0.8);
  gfx_x = panel_x0 + 2;
  gfx_y = zero_y - zh * 0.5;
  gfx_drawstr(#zero_str);

  gfx_set(0.30, 0.90, 0.30, 0.85);
  gfx_line(panel_x0 + panel_pad, center_y, meter_x0 - 2, center_y);
  sprintf(#ref_str, "%d", target_level);
  gfx_setfont(2);
  gfx_measurestr(#ref_str, rw, rh);
  gfx_set(panel_r, panel_g, panel_b, 0.85);
  gfx_rect(panel_x0 + 1, center_y - rh * 0.5, rw + 2, rh + 2);
  gfx_set(0.30, 0.90, 0.30, 0.9);
  gfx_x = panel_x0 + 2;
  gfx_y = center_y - rh * 0.5;
  gfx_drawstr(#ref_str);
  gfx_setfont(3);

  // Read mute mask for visual feedback
  mute_mask = slider24;

  // Divergence slider geometry (vertical, below each meter bar)
  div_y = bar_top + bar_h + div_gap;
  div_bar_h = div_v_h;

  // Mute square geometry (below divergence sliders)
  mute_y = div_y + div_v_h + mute_gap;

  i = 0;
  loop(5,
    sp_idx = i == 0 ? 3 : i == 1 ? 0 : i == 2 ? 2 : i == 3 ? 1 : 4;
    i == 0 ? #lbl = "Ls" : i == 1 ? #lbl = "L" : i == 2 ? #lbl = "C" : i == 3 ? #lbl = "R" : #lbl = "Rs";
    bx = meter_x0 + i * (bar_w + bar_gap);

    // Determine mute state for this channel
    i == 0 ? mute_bit = 16 :    // Ls
    i == 1 ? mute_bit = 1 :     // L
    i == 2 ? mute_bit = 4 :     // C
    i == 3 ? mute_bit = 2 :     // R
             mute_bit = 32;     // Rs
    is_muted = (mute_mask & mute_bit) > 0;

    // Channel label (always normal color - mute shown by square below)
    gfx_setfont(3);
    gfx_measurestr(#lbl, lw, lh);
    gfx_set(txt_r, txt_g, txt_b, 0.7);
    gfx_x = bx + (bar_w - lw) * 0.5;
    gfx_y = label_y - lh - 2 * sc;
    gfx_drawstr(#lbl);

    // Bar background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx, bar_top, bar_w, bar_h);

    // Meter level
    meter_mode == 0 ? (
      lvl = peak_level[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    ) : (
      lvl = rms_disp[sp_idx];
      lvl_db = lvl > 0.00001 ? 20.0 * log10(lvl) : -120.0;
    );

    lvl_y = center_y - (lvl_db - target_level) / scale_span * bar_h;
    lvl_y = min(bar_top + bar_h, max(bar_top, lvl_y));

    is_muted ? (
      // Muted: dim gray bar
      gfx_set(0.3, 0.3, 0.35, 0.3);
      gfx_rect(bx, lvl_y, bar_w, (bar_top + bar_h) - lvl_y);
    ) : (
      // Normal: colored bar
      lvl_db > -6 ? (
        gfx_set(0.90, 0.20, 0.15, 0.9);
      ) : lvl_db > -18 ? (
        gfx_set(0.90, 0.80, 0.10, 0.9);
      ) : (
        gfx_set(mtr_r, mtr_g, mtr_b, 0.9);
      );
      gfx_rect(bx, lvl_y, bar_w, (bar_top + bar_h) - lvl_y);
    );

    // dB value display
    gfx_set(txt_r, txt_g, txt_b, 0.6);
    gfx_setfont(3);
    lvl_db > -99 ? (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawnumber(lvl_db, 1);
    ) : (
      gfx_x = bx + 1;
      gfx_y = value_y;
      gfx_drawstr("-inf");
    );

    // Peak hold (skip visual for muted channels)
    cur_pk = meter_mode == 0 ? peak_level[sp_idx] : rms_level[sp_idx];
    cur_pk > peak_hold[sp_idx] ? (
      peak_hold[sp_idx] = cur_pk;
      peak_hold_tm[sp_idx] = PEAK_HOLD_FRAMES;
    ) : (
      peak_hold_tm[sp_idx] > 0 ? (
        peak_hold_tm[sp_idx] -= 1;
      ) : (
        peak_hold[sp_idx] *= PEAK_DECAY;
      );
    );
    !is_muted ? (
      hold_db = peak_hold[sp_idx] > 0.00001 ? 20.0 * log10(peak_hold[sp_idx]) : -120.0;
      hold_y = center_y - (hold_db - target_level) / scale_span * bar_h;
      hold_y = min(bar_top + bar_h, max(bar_top, hold_y));
      gfx_set(1.0, 1.0, 1.0, 0.6);
      gfx_line(bx, hold_y, bx + bar_w, hold_y);
    );

    // === VERTICAL DIVERGENCE SLIDER (below meter bar) ===
    i == 0 ? div_val = slider35 :  // Ls
    i == 1 ? div_val = slider32 :  // L
    i == 2 ? div_val = slider34 :  // C
    i == 3 ? div_val = slider33 :  // R
         div_val = slider36;   // Rs

    // Background
    gfx_set(0.12, 0.12, 0.14, 0.7);
    gfx_rect(bx, div_y, bar_w, div_bar_h);

    // Cyan fill from bottom upward (proportional to divergence)
    div_val > 0.005 ? (
      fill_h = div_bar_h * div_val;
      gfx_set(0.0, 0.7, 0.9, 0.8);
      gfx_rect(bx, div_y + div_bar_h - fill_h, bar_w, fill_h);
    );

    // Percentage text (centered in slider)
    div_val > 0.01 ? (
      gfx_setfont(3);
      sprintf(#div_str, "%.0f", div_val * 100);
      gfx_set(txt_r, txt_g, txt_b, 0.6);
      gfx_measurestr(#div_str, dw, dh);
      gfx_x = bx + (bar_w - dw) * 0.5;
      gfx_y = div_y + (div_bar_h - dh) * 0.5;
      gfx_drawstr(#div_str);
    );

    // === MUTE TOGGLE SQUARE (below divergence slider) ===
    mute_sq_x = bx + (bar_w - mute_sq_size) * 0.5;

    is_muted ? (
      // Filled red square
      gfx_set(0.9, 0.25, 0.2, 0.9);
      gfx_rect(mute_sq_x, mute_y, mute_sq_size, mute_sq_size);
      // White "M" text
      gfx_set(1, 1, 1, 1);
    ) : (
      // Outlined dim square
      gfx_set(0.4, 0.4, 0.45, 0.5);
      gfx_rect(mute_sq_x, mute_y, mute_sq_size, mute_sq_size);
      gfx_set(0.15, 0.15, 0.17, 1);
      gfx_rect(mute_sq_x + 1, mute_y + 1, mute_sq_size - 2, mute_sq_size - 2);
      // Dim "M" text
      gfx_set(0.5, 0.5, 0.5, 0.4);
    );
    gfx_setfont(3);
    gfx_measurestr("M", mw_m, mh_m);
    gfx_x = mute_sq_x + (mute_sq_size - mw_m) * 0.5;
    gfx_y = mute_y + (mute_sq_size - mh_m) * 0.5;
    gfx_drawstr("M");

    // === MOUSE INTERACTION ===
    // Mute toggle (click on square)
    mouse_cap == 1 && last_mouse_cap == 0 && !mouse_clicked_ui ? (
      mouse_x >= mute_sq_x && mouse_x <= mute_sq_x + mute_sq_size &&
      mouse_y >= mute_y && mouse_y <= mute_y + mute_sq_size ? (
        // Toggle mute bit
        (slider24 & mute_bit) ? (
          slider24 = slider24 - mute_bit;
        ) : (
          slider24 = slider24 | mute_bit;
        );
        sliderchange(slider24);
        mouse_clicked_ui = 1;
      );
    );

    // Divergence vertical drag (hold mouse on divergence slider)
    mouse_cap == 1 && !mouse_clicked_ui ? (
      mouse_x >= bx && mouse_x <= bx + bar_w &&
      mouse_y >= div_y && mouse_y <= div_y + div_bar_h ? (
        new_div = max(0, min(1, 1.0 - (mouse_y - div_y) / div_bar_h));
        i == 0 ? (slider35 = new_div; sliderchange(slider35)) :
        i == 1 ? (slider32 = new_div; sliderchange(slider32)) :
        i == 2 ? (slider34 = new_div; sliderchange(slider34)) :
        i == 3 ? (slider33 = new_div; sliderchange(slider33)) :
                 (slider36 = new_div; sliderchange(slider36));
        mouse_clicked_ui = 1;
      );
    );

    // Right-click reset divergence
    mouse_cap & 2 && !(last_mouse_cap & 2) ? (
      mouse_x >= bx && mouse_x <= bx + bar_w &&
      mouse_y >= div_y && mouse_y <= div_y + div_bar_h ? (
        i == 0 ? (slider35 = 0; sliderchange(slider35)) :
        i == 1 ? (slider32 = 0; sliderchange(slider32)) :
        i == 2 ? (slider34 = 0; sliderchange(slider34)) :
        i == 3 ? (slider33 = 0; sliderchange(slider33)) :
                 (slider36 = 0; sliderchange(slider36));
      );
    );

    i += 1;
  );

  // dB scale on the right side of the meter panel (relative to target level)
  scale_x = panel_x0 + panel_w - panel_pad - scale_w;
  gfx_set(brd_r, brd_g, brd_b, 0.5);
  gfx_line(scale_x, bar_top, scale_x + scale_w, bar_top);
  gfx_line(scale_x, bar_top + bar_h, scale_x + scale_w, bar_top + bar_h);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_setfont(3);
  db_step = 6;
  db_span = 30;
  db_mark = 0;
  loop(11,
    offset_db = db_span - db_mark * db_step;
    ref_db = target_level + offset_db;
    db_y = center_y - (offset_db / scale_span) * bar_h;
    db_y >= bar_top && db_y <= (bar_top + bar_h) ? (
      gfx_set(brd_r, brd_g, brd_b, 0.3);
      gfx_line(meter_x0, db_y, scale_x - 2, db_y);
      sprintf(#step_str, "%d", ref_db);
      gfx_setfont(3);
      gfx_measurestr(#step_str, sw, sh);
      gfx_set(panel_r, panel_g, panel_b, 0.85);
      gfx_rect(scale_x + 1, db_y - sh * 0.5, sw + 2, sh + 2);
      gfx_set(txt_r, txt_g, txt_b, 0.6);
      gfx_x = scale_x + 2;
      gfx_y = db_y - sh * 0.5;
      gfx_drawstr(#step_str);
    );
    db_mark += 1;
  );

  // LUFS block - more prominent display
  lufs_block_h = max(56, (70 * sc)|0);
  lufs_y0_new = panel_y0 + panel_h - panel_pad - lufs_block_h;

  gfx_set(0.08, 0.08, 0.10, 0.95);
  gfx_rect(panel_x0 + panel_pad, lufs_y0_new, panel_w - panel_pad * 2, lufs_block_h);
  gfx_set(acc_r, acc_g, acc_b, 0.6);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new, panel_x0 + panel_w - panel_pad, lufs_y0_new);
  gfx_line(panel_x0 + panel_pad, lufs_y0_new + lufs_block_h, panel_x0 + panel_w - panel_pad, lufs_y0_new + lufs_block_h);

  gfx_setfont(2);
  lufs_row_h_new = lufs_block_h / 3;
  lufs_label_x_new = panel_x0 + panel_pad + 6;
  lufs_val_x_new = panel_x0 + panel_w - panel_pad - 6;

  // LUFS-I (Integrated) - most important, at top
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 0 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  gfx_drawstr("LUFS-I");
  gfx_measurestr(lufs_int_disp > -99 ? sprintf(#tmp, "%.1f", lufs_int_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(acc_r * 1.2, acc_g * 1.2, acc_b * 1.2, 1.0);
  lufs_int_disp > -99 ? gfx_drawnumber(lufs_int_disp, 1) : gfx_drawstr("-inf");

  // LUFS-S (Short-term) - middle
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 1 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.90, 0.90, 0.20, 0.95);
  gfx_drawstr("LUFS-S");
  gfx_measurestr(lufs_short_disp > -99 ? sprintf(#tmp, "%.1f", lufs_short_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.95, 0.95, 0.95, 1.0);
  lufs_short_disp > -99 ? gfx_drawnumber(lufs_short_disp, 1) : gfx_drawstr("-inf");

  // LUFS-M (Momentary) - bottom, fastest
  gfx_x = lufs_label_x_new;
  gfx_y = lufs_y0_new + lufs_row_h_new * 2 + (lufs_row_h_new - font_md) * 0.5;
  gfx_set(0.70, 0.70, 0.70, 0.90);
  gfx_drawstr("LUFS-M");
  gfx_measurestr(lufs_mom_disp > -99 ? sprintf(#tmp, "%.1f", lufs_mom_disp) : "-inf", vw, vh);
  gfx_x = lufs_val_x_new - vw;
  gfx_set(0.85, 0.85, 0.85, 0.95);
  lufs_mom_disp > -99 ? gfx_drawnumber(lufs_mom_disp, 1) : gfx_drawstr("-inf");

  // Mouse click detection for LUFS reset
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    mouse_x >= panel_x0 + panel_pad && mouse_x <= panel_x0 + panel_w - panel_pad &&
    mouse_y >= lufs_y0_new && mouse_y <= lufs_y0_new + lufs_block_h ? (
      // Reset LUFS Integrated
      lufs_int = -120;
      lufs_int_disp = -120;
      lufs_m_db = -100;
      lufs_s_db = -100;
      lufs_i_db = -100;
      lufs_win_pos = 0;
      lufs_win_cnt = 0;
      lufs_win_acc = 0;
      lufs_cur_buf = 0;
      lufs_cur_buf2 = 0;
      lufs_m_sum = 0;
      lufs_s_sum = 0;
      lufs_a_sum = 0;
      lufs_a_sum_cnt = 0;
      lufs_i_sum = 0;
      lufs_i_cnt = 0;
      i = 0;
      loop(lufs_m_win_cnt,
        lufs_buf[i] = 0;
        i += 1;
      );
      i = 0;
      loop(lufs_s_win_cnt,
        lufs_buf2[i] = 0;
        i += 1;
      );
      i = 0;
      loop(NUM_BINS * 2,
        lufs_a_hist[i] = 0;
        i += 1;
      );
    );
  );

  // =====================================================
  // LFE METER (horizontal bar at bottom of window)
  // =====================================================
  gfx_set(panel_r, panel_g, panel_b, 1);
  gfx_rect(pad, lfe_top, gfx_w - pad * 2, lfe_h);
  gfx_set(brd_r, brd_g, brd_b, 0.8);
  gfx_line(pad, lfe_top, gfx_w - pad, lfe_top);

  gfx_setfont(3);
  lfe_is_muted = (slider23 & 8) > 0;
  lfe_is_muted ? gfx_set(0.9, 0.25, 0.2, 1.0) : gfx_set(0.55, 0.40, 0.75, 0.8);
  gfx_x = pad + 4; gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  gfx_drawstr("LFE");
  lfe_is_muted ? (
    gfx_set(0.9, 0.25, 0.2, 0.8);
    gfx_drawstr(" M");
  );

  lfe_bar_x = pad + 36 * sc;
  lfe_bar_w = gfx_w - pad * 2 - 90 * sc;
  lfe_bar_h = max(8, lfe_h - 10 * sc);
  lfe_bar_y = lfe_top + (lfe_h - lfe_bar_h) * 0.5;

  // Background
  gfx_set(0.12, 0.12, 0.14, 0.7);
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_bar_w, lfe_bar_h);

  // Value
  meter_mode == 0 ? ( lfe_val = lfe_peak[0]; ) : ( lfe_val = lfe_rms[0]; );
  lfe_db = lfe_val > 0.00001 ? 20.0 * log10(lfe_val) : -60.0;
  lfe_norm = max(0.0, (lfe_db + 60.0) / 60.0);

  // LFE color: purple gradient
  lfe_norm < 0.6 ? ( gfx_set(0.30, 0.20, 0.60, 0.85); )
  : lfe_norm < 0.85 ? ( gfx_set(0.50, 0.30, 0.70, 0.85); )
  : ( gfx_set(0.90, 0.20, 0.15, 0.85); );
  gfx_rect(lfe_bar_x, lfe_bar_y, lfe_norm * lfe_bar_w, lfe_bar_h);

  // LFE peak hold
  lfe_cur_pk = meter_mode == 0 ? lfe_peak[0] : lfe_rms[0];
  lfe_cur_pk > lfe_hold[0] ? (
    lfe_hold[0] = lfe_cur_pk;
    lfe_hold_tm[0] = PEAK_HOLD_FRAMES;
  ) : (
    lfe_hold_tm[0] > 0 ? ( lfe_hold_tm[0] -= 1; ) : ( lfe_hold[0] *= PEAK_DECAY; );
  );
  lfe_hld_db = lfe_hold[0] > 0.00001 ? 20.0 * log10(lfe_hold[0]) : -60.0;
  lfe_hld_norm = max(0.0, (lfe_hld_db + 60.0) / 60.0);
  lfe_hld_x = lfe_bar_x + lfe_hld_norm * lfe_bar_w;
  gfx_set(1.0, 1.0, 1.0, 0.5);
  gfx_line(lfe_hld_x, lfe_bar_y, lfe_hld_x, lfe_bar_y + lfe_bar_h);

  // dB readout
  gfx_setfont(3);
  gfx_set(txt_r, txt_g, txt_b, 0.6);
  gfx_x = lfe_bar_x + lfe_bar_w + 6;
  gfx_y = lfe_top + (lfe_h - font_sm) * 0.5;
  lfe_db > -59.0 ? ( gfx_drawnumber(lfe_db, 1); gfx_drawstr(" dB"); )
  : ( gfx_drawstr("-inf dB"); );

  // LFE mute click (click on "LFE" label)
  mouse_cap == 1 && last_mouse_cap == 0 ? (
    mouse_x >= pad + 4 && mouse_x <= pad + 40 * sc &&
    mouse_y >= lfe_top && mouse_y <= lfe_top + lfe_h ? (
      (slider23 & 8) ? ( slider23 = slider23 - 8; ) : ( slider23 = slider23 | 8; );
      sliderchange(slider23);
    );
  );

  last_mouse_cap = mouse_cap;
