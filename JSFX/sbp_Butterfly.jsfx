desc: SBP_Butterfly Generator PhysModel
// @author SBP & AI
// @version 0.5
// @about A custom JSFX audio plugin that simulates the fluttering sound of butterfly wings. It uses a combination of LFOs, noise, and filters to create a dynamic and evolving soundscape that captures the delicate and chaotic nature of butterfly flight. Perfect for adding an organic, natural element to your music or sound design projects.
//        Flap Speed Control: Adjust the frequency of the wing flaps, allowing for slow, gentle fluttering or rapid, frantic movement.
//        Wing Sharpness: Control the shape of the flap envelope, from soft and rounded to sharp and percussive, to mimic different butterfly species or flight styles.
//        Air Resonance: A resonant filter that simulates the natural frequencies of air around the wings, adding a sense of space and realism to the sound.
//        Turbulence Control: Add high-frequency noise to simulate the chaotic air movement caused by the wings, with a mix control to blend it in with the main sound.
//        Wing Air Push: A low-frequency component that simulates the powerful push of air generated by the wings, adding depth and weight to the sound.
//        Stereo Width: Control the stereo spread of the sound, from mono to wide, to create a more immersive and dynamic soundscape.
//        Flight Chaos: An LFO that adds random modulation to the flap speed and turbulence, simulating the unpredictable nature of butterfly flight.
//        Inertia & Swarm Behavior: Smooth parameter transitions and a chaos LFO that creates a sense of inertia and swarm-like movement, making the sound feel alive and evolving over time. The plugin also includes a play switch and a start/stop ramp for smooth transitions in and out of the sound.

slider1:8<1,40,0.01>Flap Speed (Hz)
slider2:0.7<0.1,1,0.01>Wing Sharpness
slider3:900<100,3000,1>Air Resonance (Hz)
slider4:0.6<0,1,0.01>Turbulence (Chaos & Highs)
slider5:0.5<0,1,0.01>Wing Air Push (Lows)
slider6:0.8<0,1,0.01>Stereo Width
slider7:0.3<0,1,0.01>Flight Chaos (Alive LFO)
slider8:0<0,1,1{Off,On}>Play Switch
slider9:0.5<0,5,0.01>Start/Stop Ramp (s)
slider10:0<0,1,0.01>Start Phase Offset (0-1)

@init
v0L=0; v1L=0; v2L=0;
v0R=0; v1R=0; v2R=0;
phase = 0;

sm_mass = 0;
sm_turb = 0;
sm_spd = 8;

lfo_phase = 0;
chaos_val = 0;
chaos_target = 0;

ramp_mult = 0;

@slider
target_spd = slider1;
s_shrp = slider2 * 6;
s_res = slider3;
target_turb = slider4;
target_mass = slider5;
s_width = slider6;
s_chaos = slider7;

s_play = slider8;
s_ramp_time = slider9;
s_phase_offset = slider10;

@sample
// 1. Smoothing
sm_mass += (target_mass - sm_mass) * 0.002;
sm_turb += (target_turb - sm_turb) * 0.002;
sm_spd  += (target_spd - sm_spd) * 0.002;

// 2. Inertia
actual_ramp = max(s_ramp_time, 0.01);
s_play > 0.5 ? (
    ramp_mult += 1 / (actual_ramp * srate);
    ramp_mult > 1 ? ramp_mult = 1;
) : (
    ramp_mult -= 1 / (actual_ramp * srate);
    ramp_mult <= 0 ? (
        ramp_mult = 0;
        phase = s_phase_offset;
    );
);

// 3. Chaos LFO
ramp_mult > 0 ? (
    lfo_phase += 1 / srate;
    lfo_phase > 1 ? (
        lfo_phase -= 1;
        chaos_target = (rand(2) - 1) * s_chaos; 
    );
    chaos_val += (chaos_target - chaos_val) * 0.0005; 
);

// 4. Phase engine
mod_speed = sm_spd * (1 + chaos_val) * ramp_mult; 
dt = mod_speed / srate;
phase += dt;
phase > 1 ? phase -= 1;

env = pow(sin($pi * phase), s_shrp);

// ==========================================
// 5. DYNAMIC TURBULENCE (UPDATED)
// ==========================================
noiseL = (rand(2) - 1);
noiseR = (rand(2) - 1);

// Modulation range depends on turbulence
// Low turbulence → frequency wanders around 500 Hz. High → around 2500 Hz.
mod_depth = 500 + (sm_turb * 2000); 
cutoff = s_res + (env * mod_depth);
f = tan($pi * cutoff / srate);

// Filter resonance (Q) depends on turbulence
// Low turbulence (sm_turb near 0) → high Q (0.9), tonal/whistling
// High turbulence (sm_turb near 1) → low Q (0.3), wide/hissing sound
q = 0.9 - (sm_turb * 0.6); 

a1 = 1 / (1 + f/q + f*f);
a2 = f/q * a1;

v1L_n = a1*v1L + a2*(noiseL - v2L);
v2L = v2L + 2*v1L_n;
v1L = v1L_n;

v1R_n = a1*v1R + a2*(noiseR - v2R);
v2R = v2R + 2*v1R_n;
v1R = v1R_n;

// To compensate for volume drop with narrow filter,
// add a small gain curve (turb_gain)
turb_gain = 0.2 + (sm_turb * 0.8);

// 6. Soft air thump
safe_speed = max(mod_speed, 0.1); 
thump_freq = 45; 
thump_osc = sin(phase * $pi * 2 * (thump_freq / safe_speed));
thump_env = pow(sin(phase * $pi), 1.5); 
speed_attenuation = 8 / (sm_spd + 3);
thump = thump_osc * thump_env * sm_mass * speed_attenuation * 0.25;

// 7. Panning and output
pan_wander = chaos_val * 1.5; 
pan_wing = sin(2 * $pi * phase) * s_width * 0.5; 

panL = 1 - (pan_wing + pan_wander);
panR = 1 + (pan_wing + pan_wander);
panL = max(0, min(2, panL));
panR = max(0, min(2, panR));

// Now turb_gain handles volume and sm_turb itself distorts the filter
outL = (v1L * env * turb_gain + thump) * panL * ramp_mult;
outR = (v1R * env * turb_gain + thump) * panR * ramp_mult;

spl0 = outL * 0.7;
spl1 = outR * 0.7;