desc: UltraComb Stereo (Ableton Style)

slider1:25<1,100,0.1>Comb delay (ms)
slider2:0.85<0.0,0.99,0.01>Comb feedback
slider3:1.0<0.0,1.0,0.01>Comb level
slider4:8.0<0.5,30,0.1>Flanger depth (ms)
slider5:1.2<0.1,8,0.05>Flanger rate (Hz)
slider6:0.85<0.0,1.0,0.01>Flanger level
slider9:0.55<0.0,1.0,0.01>Wet mix
slider10:0.30<0.0,1.0,0.01>Stereo spread (Detune)
slider11:0.25<0.0,0.8,0.01>Drive amount
slider12:0.4<0.0,0.95,0.01>HF Damping
slider13:50<0,200,1>Freq Shift (Hz)

@init
comb_buf_l[0] = 0;
comb_buf_r[0] = 0;
flange_buf_l[0] = 0;
flange_buf_r[0] = 0;
comb_pos_l = 0;
comb_pos_r = 0;
flange_pos_l = 0;
flange_pos_r = 0;
flange_phase = 0;

// Filter memory
lp_l = 0;
lp_r = 0;

// Hilbert Transform memory (quadrature)
hilbert_mem_l = 0;
hilbert_mem_r = 0;

// Freq Shift modulation phase
fs_phase = 0;

// Comb delay smoothing
delay_slew = 1 - exp(-1 / (0.15 * srate));
delay_samp_l_s = (slider1 / 1000) * srate;
delay_samp_r_s = delay_samp_l_s;
// Flanger parameter smoothing
param_slew = 1 - exp(-1 / (0.15 * srate)); // ~150ms
phase_inc_s = slider5 / srate;
flange_depth_ms_s = slider4;
f_del_r_s = 0;

@sample
// Input Drive (Soft Saturation)
drive_gain = 1 + slider11 * 3;
function soft_clip(x) (
  x = x * 1.5;
  x / (1 + abs(x));
);

in_l = soft_clip(spl0 * drive_gain);
in_r = soft_clip(spl1 * drive_gain);

// --- COMB SECTION (Both channels) ---
base_delay_ms = slider1;
offset_factor = 1 + (slider10 * 0.15);

delay_target_l = (base_delay_ms / 1000) * srate;
delay_target_r = ((base_delay_ms * offset_factor) / 1000) * srate;

delay_target_l = max(5, min(delay_target_l, 49990));
delay_target_r = max(5, min(delay_target_r, 49990));

delay_samp_l_s = delay_samp_l_s + (delay_target_l - delay_samp_l_s) * delay_slew;
delay_samp_r_s = delay_samp_r_s + (delay_target_r - delay_samp_r_s) * delay_slew;
delay_samp_l = delay_samp_l_s;
delay_samp_r = delay_samp_r_s;

fb_mod = slider2;
damp = 1 - slider12;

// -- Comb Left --
r_pos = comb_pos_l - delay_samp_l;
r_pos += 50000 * (r_pos < 0);
idx = floor(r_pos); frac = r_pos - idx;
idx_n = (idx + 1) % 50000;
del_out_l = comb_buf_l[idx] * (1 - frac) + comb_buf_l[idx_n] * frac;
lp_l = lp_l + (del_out_l - lp_l) * damp;
feedback_sig_l = lp_l;
comb_out_l = del_out_l;
comb_buf_l[comb_pos_l] = in_l + feedback_sig_l * fb_mod;
comb_pos_l = (comb_pos_l + 1) % 50000;

// -- Comb Right --
r_pos = comb_pos_r - delay_samp_r;
r_pos += 50000 * (r_pos < 0);
idx = floor(r_pos); frac = r_pos - idx;
idx_n = (idx + 1) % 50000;
del_out_r = comb_buf_r[idx] * (1 - frac) + comb_buf_r[idx_n] * frac;
lp_r = lp_r + (del_out_r - lp_r) * damp;
feedback_sig_r = lp_r;
comb_out_r = del_out_r;
comb_buf_r[comb_pos_r] = in_r + feedback_sig_r * fb_mod;
comb_pos_r = (comb_pos_r + 1) % 50000;

// --- LEFT CHANNEL: Comb only ---
sum_l = comb_out_l * slider3;

// --- RIGHT CHANNEL: Comb + Flanger ---
// Smooth LFO rate change
phase_inc_target = slider5 / srate;
phase_inc_s = phase_inc_s + (phase_inc_target - phase_inc_s) * param_slew;
flange_phase += phase_inc_s;
flange_phase -= floor(flange_phase);

spread_ph = slider10 * 0.25;
lfo_r = 0.5 + 0.5 * sin(2 * $pi * (flange_phase + spread_ph));

// Smooth flanger depth and modulated delay
flange_depth_ms_s = flange_depth_ms_s + (slider4 - flange_depth_ms_s) * param_slew;
flange_depth_samp = (flange_depth_ms_s / 1000) * srate;
flange_base_samp = 0.0005 * srate;
f_del_r_target = flange_base_samp + flange_depth_samp * lfo_r;
f_del_r_target = max(5, min(f_del_r_target, 29990));
f_del_r_s = f_del_r_s + (f_del_r_target - f_del_r_s) * param_slew;
f_del_r = f_del_r_s;

// Flange R
r_pos = flange_pos_r - f_del_r;
r_pos += 30000 * (r_pos < 0);
idx = floor(r_pos); frac = r_pos - idx;
idx_n = (idx + 1) % 30000;
flange_out_r = flange_buf_r[idx] * (1-frac) + flange_buf_r[idx_n] * frac;
flange_buf_r[flange_pos_r] = comb_out_r;
flange_pos_r = (flange_pos_r + 1) % 30000;

sum_r = comb_out_r * slider3 + flange_out_r * slider6;

// --- FREQ SHIFT with Hilbert Transform (SSB) ---
fs_phase += (slider13 / srate);
fs_phase -= floor(fs_phase);

// Simple Hilbert approximation (90Â° phase shift)
// Using 1-tap delay for quadrature
hilbert_l = sum_l - hilbert_mem_l * 0.5;
hilbert_mem_l = sum_l;

hilbert_r = sum_r - hilbert_mem_r * 0.5;
hilbert_mem_r = sum_r;

// SSB modulation (I/Q mixer)
cos_carr = cos(2 * $pi * fs_phase);
sin_carr = sin(2 * $pi * fs_phase);

// Upper sideband: real * cos - hilbert * sin
shifted_l = sum_l * cos_carr - hilbert_l * sin_carr;
shifted_r = sum_r * cos_carr - hilbert_r * sin_carr;

// Output
out_l = shifted_l;
out_r = shifted_r;

// Wet/Dry mix
mix = slider9;
wet_w2 = sin(0.5 * $pi * mix);
dry_w2 = cos(0.5 * $pi * mix);
out_l = dry_w2 * spl0 + wet_w2 * out_l;
out_r = dry_w2 * spl1 + wet_w2 * out_r;

// Final Limiter
out_l = 2 * (1 / (1 + exp(-2 * out_l)) - 0.5);
out_r = 2 * (1 / (1 + exp(-2 * out_r)) - 0.5);

spl0 = out_l;
spl1 = out_r;