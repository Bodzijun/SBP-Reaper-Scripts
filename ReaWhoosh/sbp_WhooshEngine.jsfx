// @description sbp_WhooshEngine
// @version 3.5.2
// @author SBP & AI
// @changelog
//  v3.5.2 (2026-02-19):
//  Added Full Circles mode for unlimited rotations using internal phase accumulator
//  Surround modes now: Vector 3-point / Circle Arc 3-point / Full Circles
//  Removed Speed multiplier from Circle Arc mode (3-point automation defines timing)
//  Added Rotations Count & Start Angle parameters for Full Circles mode
//  Fixed proper VBAP 5.1 panning with mono source distribution
//  v3.5.1:
//  Fixed Surround Circle mode: removed broken play_position calculation, now uses sur_path_x/y automation
//  Implemented proper VBAP panning algorithm for ITU-R BS.775 5.1 layout
//  Fixed speaker position gaps causing audio dropouts during circular motion
//  v3.5.0:
//  Added dedicated Surround Path controls (Vector/Circle) with new automation sliders.
//  Surround output can now follow dedicated Sur Path X/Y stream from ReaWhoosh UI.
//  Ring Modulator has been enhanced.
//  v3.4.1:
//  Rename effect to "sbp_WhooshEngine" for better clarity and branding.
//  v3.4.0:
//  Added Physical Doppler Mode
//  Improved Audio Pitch algorithm for Doppler (Grain Jitter)
//  Added Grain Size selection for Audio Pitch/Doppler
//  Improved Pitch Logic (DC Blocking for low end)
// @link https://forum.cockos.com/showthread.php?t=305805
// @about effect core for SBP_ReaWhoosh.lua

desc: sbp_WhooshEngine v3.5.2
options:gmem=sbp_whoosh

// === 1. GLOBAL CONTROL ===
slider1:0.0<0,1,0.001>Global: Amp/Shape (Env)
slider2:0.0<-12,12,0.1>Global: Pitch Shift
slider3:-6.0<-60,12,0.1>Global: Output Gain (dB)
slider4:0<0,1,1{Stereo,Surround}>Output Mode
slider5:0.5<0,3,1{Pitch Shift,Freq Shift,Audio Pitch,Physical Doppler}>Global: Pitch Mode

// === 2. GENERATORS ===
// NOISE
slider6:0.5<0,2,0.001>Mix: Noise
slider7:0<0,2,1{White,Pink,Crackle}>Noise: Type
slider8:0.0<-1,1,0.01>Noise: Tone

// OSCILLATOR
slider9:0.5<0,2,0.001>Mix: Oscillator
slider10:1<0,3,1{Sine,Saw,Square,Triangle}>Osc: Wave Shape
slider11:0.1<0,1,0.001>Osc: PWM / Shape
slider12:0.0<-50,50,0.1>Osc: Detune (cents)
slider13:0.0<0,1,0.01>Osc: Drive
slider51:0.0<-24,24,0.1>Osc: Octave (st)
slider53:0.0<-1,1,0.01>Osc: Tone

// CHUA
slider14:0.5<0,2,0.001>Mix: Chua Osc
slider15:0.05<0.001,0.5,0.001>Chua: Rate
slider16:28.0<10,45,0.1>Chua: Shape
slider17:-2.0<-20,20,0.1>Chua: Timbre
slider18:15.6<-20,20,0.01>Chua: Alpha (Chaos)

// SUB & EXT
slider19:0.0<0,2,0.001>Mix: Sub Oscillator
slider20:55<30,120,1>Sub: Freq (Hz)
slider21:0.0<0,1,0.01>Sub: Saturation
slider22:0.0<0,2,0.001>Mix: External Input

// === 3. FILTER ===
slider23:0.5<0,1,0.001>Filt: Morph X
slider24:0.5<0,1,0.001>Filt: Morph Y
slider25:0.5<0,1,0.001>Filt: Cutoff
slider26:0.5<0,0.98,0.001>Filt: Resonance

// === 4. FX CHAIN ===
slider27:0.0<0,1,0.001>Flange: Mix
slider28:0.0<0,1,0.001>Flange: Feedback

slider29:0.0<0,1,0.001>Dbl: Mix
slider30:20<10,60,1>Dbl: Time (ms)
slider31:0.5<0,1,0.001>Dbl: Spread

slider32:0.0<0,1,0.001>Verb: Mix
slider33:0.5<0,1,0.001>Verb: Size
slider34:0.5<0,1,0.001>Verb: Damping
slider35:0.5<0,1,0.001>Verb: Tail (Decay)

slider36:0.0<0,1,0.01>Saturation: Drive
slider37:0.0<0,1,0.01>Bitcrush: Mix
slider38:1.0<0.1,1,0.01>Bitcrush: Rate
slider39:0.0<0,1,0.01>Punch: Attack Boost

slider50:0.0<0,1,0.01>Ring Mod: Metal Mix
slider52:0.0<-36,36,0.01>Global: Audio Pitch Shift (semi)
slider54:0<0,1,1{Clean,Pitched}>Noise: Routing
slider55:0.5<0,1,0.01>Doppler: Air Absorption

// Grain Size Selection
slider56:1<0,3,1{512 (Tiny),1024 (Short),2048 (Medium),4096 (Long)}>Pitch: Grain Size

// === 4B. SURROUND PATH ===
slider57:0<0,2,1{Vector 3-point,Circle Arc 3-point,Full Circles}>Surround: Path Mode
slider58:0.5<0,1,0.001>Surround: Path X (Vector/Arc)
slider59:0.0<0,1,0.001>Surround: Path Y (Vector/Arc)
slider60:0.9<0.05,0.9,0.001>Surround: Arc Length (0.05-0.9)
slider61:0.0<0,1,0.001>Surround: Arc Offset (0-1)
slider62:1.0<0.5,10.0,0.1>Surround: Full Circles - Rotations Count
slider63:0<0,1,1{CCW,CW}>Surround: Direction
slider64:0.25<0,1,0.001>Surround: Full Circles - Start Angle (0-1 = 0-360°)

// === 5. CHOPPER (POST FX) ===
slider40:0.0<0,1,0.001>Chop: Depth
slider41:0.5<0,1,0.001>Chop: Rate
slider42:0.0<0,1,0.001>Chop: Shape (Hard/Soft)

// === 6. PANNING & TRIMS ===
slider43:0.5<0,1,0.001>Pan X (L-R)
slider44:0.0<0,1,0.001>Pan Y (F-R)
slider45:0.0<0,1,0.001>Width

slider46:1.0<0,2,0.01>Trim: Noise
slider47:1.0<0,2,0.01>Trim: Osc
slider48:1.0<0,2,0.01>Trim: Chua
slider49:1.0<0,2,0.01>Trim: Ext

in_pin:Input L
in_pin:Input R
out_pin:Front L
out_pin:Front R
out_pin:Center
out_pin:LFE
out_pin:Rear L
out_pin:Rear R

@init
PI = 3.14159265359;
TWO_PI = 2 * PI;
SR = srate;

function DC5_init() ( this.R1=this.R2=this.R3=this.R4=this.R5=0; );
function DC5_aProc(x0, x1) local(h0,h1,h3,h5,h5x0,h3x0,h1x0) (
  h0=0.5; h1=0.3; h3=-0.06; h5=0.013; 
  h5x0=h5*x0; h3x0=h3*x0; h1x0=h1*x0;
  this.R6=this.R5+h5x0; this.R5=this.R4+h3x0; this.R4=this.R3+h1x0;
  this.R3=this.R2+h1x0+h0*x1; this.R2=this.R1+h3x0; this.R1=h5x0;
  this.R6;
);

// PolyBLEP helpers
function poly_blep(t, dt) ( t<dt?(x=t/dt; x+x-x*x-1) : t>1-dt?(x=(t-1)/dt; x*x+x+x+1) : 0 );
function osc_saw(ph, dt) ( v=2*ph-1; v-=poly_blep(ph,dt); v );
function osc_square(ph, dt) ( v=ph<0.5?1:-1; v+=poly_blep(ph,dt); ph2=ph+0.5; ph2>=1?ph2-=1; v-=poly_blep(ph2,dt); v );
function osc_square_pwm(ph, dt, d) ( d=max(0.01,min(0.99,d)); v=ph<d?1:-1; v+=poly_blep(ph,dt); phd=ph-d; phd<0?phd+=1; v-=poly_blep(phd,dt); v );

function lim(x) ( max(-1.0, min(1.0, x)) );
function safe(x) ( (x!=x) ? 0 : max(-4.0, min(4.0, x)); );
function sat(x, drv) ( x * (1.0 + drv * 2.0) / (1.0 + abs(x * drv * 0.5)); );

// One-pole LPF for Air Absorption
function lpf_doppler(sig, freq) instance(y) (
    y += (sig - y) * (1 - exp(-2 * PI * freq / srate));
    y;
);

// Anti-Thump DC Blocker
function hp_thump_removal(x) instance(y, x_prev) (
    y = x - x_prev + 0.997 * y; 
    x_prev = x;
    y;
);

// VBAP panning: calculate gains for speaker pair
// Returns: g1 (gain for first speaker), g2 (gain for second speaker)
function vbap_gain(src_ang, spk1_ang, spk2_ang) local(ang_span, ang_rel, t_norm, g1, g2) (
    ang_span = spk2_ang - spk1_ang;
    ang_span < -180 ? ang_span += 360;
    ang_span > 180 ? ang_span -= 360;
    
    ang_rel = src_ang - spk1_ang;
    ang_rel < -180 ? ang_rel += 360;
    ang_rel > 180 ? ang_rel -= 360;
    
    ang_rel < 0 || ang_rel > abs(ang_span) ? (
        this.g1 = 0; this.g2 = 0;
    ) : (
        t_norm = ang_rel / ang_span;
        this.g1 = cos(t_norm * $pi * 0.5);
        this.g2 = sin(t_norm * $pi * 0.5);
    );
);

dc_x.DC5_init(); 
chua_v.x=0.1; chua_v.y=0; chua_v.z=0;
b0=b1=b2=b3=b4=b5=b6=0; // Pink Noise

// Full Circles phase accumulator
circle_phase = 0;

flange_len = srate*0.02; fl_buf=0; fl_idx=0;
rvb_len = srate*0.5; rv_buf=fl_buf+flange_len+100; rv_idx=0;
wid_len = srate*0.05; wid_buf=rv_buf+rvb_len+100; wid_idx=0;
dbl_len = srate*0.1; dbl_buf=wid_buf+wid_len+100; dbl_idx=0;

// Audio Pitch Buffer
ps_len = 32768; 
ps_grain = 1024; // Default init, overridden by slider
ps_wr = 0; ps_rd1 = 0; ps_rd2 = ps_grain; ps_ratio = 1; ps_ratio_t = 1;
ps_bufL = dbl_buf + dbl_len + 1000;

sm_coeff = 1 - exp(-1/(srate*0.005));
param_sm_coeff = 1 - exp(-1/(srate*0.02)); 
amp_sm_coeff = 1 - exp(-1/(srate*0.005)); 
gate_sm_coeff = 1 - exp(-1/(srate*0.01)); 

// Pre-calculate Noise Tone pole
piv_hz = 2000; pole = exp(-2 * PI * piv_hz / srate);

// Cubic Interpolation
function interpolate_cubic(buf, idx, len) local(i0, i1, i2, i3, fr, a0, a1, a2, a3) (
    i1 = floor(idx); fr = idx - i1;
    i0 = (i1 - 1 + len) % len;
    i2 = (i1 + 1) % len;
    i3 = (i1 + 2) % len;
    a0 = buf[i3] - buf[i2] - buf[i0] + buf[i1];
    a1 = buf[i0] - buf[i1] - a0;
    a2 = buf[i2] - buf[i0];
    a3 = buf[i1];
    (a0 * fr * fr * fr) + (a1 * fr * fr) + (a2 * fr) + a3;
);

@block
play_state == 1 && beat_position == 0 ? (
    sub_ph=0; fl_ph=0; osc_ph1=0; osc_ph2=0; chop_ph=0;
    tri_int1=0; tri_int2=0; chua_v.x=0.1;
    cur_env=0; gate_env=0; note_on=0;
    memset(fl_buf, 0, flange_len); memset(dbl_buf, 0, dbl_len);
    memset(rv_buf, 0, rvb_len); memset(wid_buf, 0, wid_len);
    memset(ps_bufL, 0, ps_len);
    fl_idx=0; dbl_idx=0; rv_idx=0; wid_idx=0;
    // Note: circle_phase NOT reset here to allow loop continuation
);
play_state != 1 ? ( cur_env=0; gate_env=0; );

while (midirecv(offset, msg1, msg2, msg3)) (
    status = msg1 & 0xF0;
    status == 0x90 && msg3 > 0 ? ( 
        note_on = 1;
        circle_phase = 0; // Reset phase on note trigger for Full Circles mode
        b0=b1=b2=b3=b4=b5=b6=0; tri_int1=0; tri_int2=0;
        chua_v.x=0.1; chua_v.y=0; chua_v.z=0; 
    ) : status == 0x80 || (status == 0x90 && msg3 == 0) ? ( note_on = 0; );
    midisend(offset, msg1, msg2, msg3);
);

@slider
t_env_val = slider1;
pitch_shift = slider2;
master_gain = 10^(slider3/20);
out_mode = slider4;
pitch_mode = slider5; 
audio_pitch = slider52;
ps_ratio_t = 2 ^ (audio_pitch / 12);
noise_routing = slider54;
doppler_air = slider55;
sur_mode = slider57;
sur_path_x = slider58;
sur_path_y = slider59;
sur_arc_len = slider60;
sur_arc_off = slider61;
sur_full_rotations = slider62;
sur_direction = slider63;
sur_full_offset = slider64;

// Grain Size Selection
slider56 == 0 ? ps_grain = 512 :
slider56 == 1 ? ps_grain = 1024 :
slider56 == 2 ? ps_grain = 2048 :
ps_grain = 4096;

// Gens
t_v_wn = slider6; noise_type = slider7; noise_tone = slider8;
t_v_osc = slider9; osc_shape = slider10; osc_pwm = slider11; osc_detune = slider12; osc_drive = slider13; osc_octave = slider51; osc_tone = slider53;
t_v_ch = slider14; c_k = slider15; c_be = slider16; c_ga = slider17; c_al = slider18;
t_v_sub = slider19; sub_hz = slider20; sub_sat = slider21; t_v_ext = slider22;

// Filt
t_mx = slider23; t_my = slider24; f_sc = slider25; t_res = slider26;

// FX
fl_mix = slider27; fl_feed = slider28; dbl_mix = slider29; dbl_time_ms = slider30; dbl_wide = slider31;
rv_mix = slider32; rv_size = 0.2 + slider33*0.75; rv_damp = slider34; rv_tail = slider35;
sat_drive = slider36; crush_mix = slider37; crush_rate = slider38; punch_amt = slider39;
ring_metal = slider50;

// Chop
chop_depth = slider40; chop_rate_norm = slider41; chop_shape = slider42;

// Out
t_p_x = slider43; t_p_y = slider44; wid = slider45;

// Trims
trim_w = slider46; trim_o = slider47; trim_c = slider48; trim_e = slider49;

// Calcs
t_cut = 20 * (1000 ^ f_sc); t_cut = max(20, min(20000, t_cut));
doppler_ratio = (pitch_mode < 0.5) ? (2 ^ (pitch_shift / 12)) : 1;
freq_shift_hz = (pitch_mode >= 0.5 && pitch_mode < 2) ? (sub_hz * (2 ^ (pitch_shift / 12) - 1)) : 0;
base_hz = max(10, sub_hz * doppler_ratio + freq_shift_hz);
ring_shift_hz = (pitch_mode >= 0.5 && pitch_mode < 2) ? freq_shift_hz : sub_hz;
ring_step = (ring_shift_hz * TWO_PI) / srate;
sub_step = (base_hz * TWO_PI) / srate;

detune_factor = 2 ^ (osc_detune / 1200);
osc_octave_mult = 2 ^ (osc_octave / 12);
t_osc_step1 = (base_hz * osc_octave_mult) / srate; 
t_osc_step2 = (base_hz * detune_factor * osc_octave_mult) / srate;

c_beta_base = 28.58; c_a = -1.14; c_b = -0.71;
piv_hz = 2000; pole = exp(-2 * PI * piv_hz / srate);

@sample
gate_target = note_on ? 1 : 0;
gate_env += (gate_target - gate_env) * gate_sm_coeff;

(note_on || gate_env > 0.0001) ? (

    cur_env += (t_env_val - cur_env) * amp_sm_coeff; 
    v_wn += (t_v_wn - v_wn) * param_sm_coeff;
    v_osc += (t_v_osc - v_osc) * param_sm_coeff;
    v_ch += (t_v_ch - v_ch) * param_sm_coeff;
    v_ext += (t_v_ext - v_ext) * param_sm_coeff;
    v_sub += (t_v_sub - v_sub) * param_sm_coeff;
    osc_step1 += (t_osc_step1 - osc_step1) * param_sm_coeff;
    osc_step2 += (t_osc_step2 - osc_step2) * param_sm_coeff;
    p_x += (t_p_x - p_x) * param_sm_coeff;
    p_y += (t_p_y - p_y) * param_sm_coeff;
    sur_x += (sur_path_x - sur_x) * param_sm_coeff;
    sur_y += (sur_path_y - sur_y) * param_sm_coeff;
    cut_hz += (t_cut - cut_hz) * sm_coeff;
    res += (t_res - res) * sm_coeff;
    mx += (t_mx - mx) * sm_coeff;
    my += (t_my - my) * sm_coeff;

    // --- 1. GENERATORS ---
    // NOISE
    raw_white = (rand(2)-1);
    noise_type == 0 ? noise_sig = raw_white : 
    noise_type == 1 ? ( 
        b0 = 0.99886 * b0 + raw_white * 0.0555179; b1 = 0.99332 * b1 + raw_white * 0.0750759; b2 = 0.96900 * b2 + raw_white * 0.1538520;
        b3 = 0.86650 * b3 + raw_white * 0.3104856; b4 = 0.55000 * b4 + raw_white * 0.5329522; b5 = -0.7616 * b5 - raw_white * 0.0168980;
        noise_sig = (b0+b1+b2+b3+b4+b5+b6+raw_white*0.5362)*0.11; b6 = raw_white * 0.115926;
    ) : (rand(100) > 98 ? noise_sig = (rand(2)-1)*5.0 : noise_sig = 0);
    tilt = max(-1, min(1, noise_tone));
    last_nf += (noise_sig - last_nf) * (1 - pole);
    low = last_nf; high = noise_sig - low;
    w_low = 0.5 - 0.5 * tilt; w_high = 0.5 + 0.5 * tilt;
    noise_filt = (low * w_low + high * w_high) / (w_low + w_high);
    noise_filt *= 1.0 / (0.75 + abs(tilt) * 0.35);
    wn_out = noise_filt * v_wn * trim_w * cur_env;

    // SUB
    sub_ph += sub_step; sub_ph > TWO_PI ? sub_ph -= TWO_PI;
    sub_sig = sat(sin(sub_ph), sub_sat * 0.3) * v_sub * cur_env;

    // OSC
    osc_ph1 += osc_step1; osc_ph1 >= 1 ? osc_ph1 -= 1;
    osc_ph2 += osc_step2; osc_ph2 >= 1 ? osc_ph2 -= 1;
    dt1 = osc_step1; dt2 = osc_step2;
    osc_shape == 0 ? (
        oct = 2; fm_depth = osc_pwm * 0.3; fm = fm_depth * sin(osc_ph1 * TWO_PI * oct);
        osc_raw = (sin((osc_ph1*oct + fm) * TWO_PI) + sin((osc_ph2*oct + fm) * TWO_PI)) * 0.5;
    ) : osc_shape == 1 ? (
        gamma = 0.2 + 1.6 * osc_pwm;
        s1 = osc_saw(osc_ph1, dt1); s2 = osc_saw(osc_ph2, dt2);
        s1 = s1 >= 0 ? pow(s1, gamma) : -pow(-s1, gamma); s2 = s2 >= 0 ? pow(s2, gamma) : -pow(-s2, gamma);
        osc_raw = (s1 + s2) * 0.5 * 1.15;
    ) : osc_shape == 2 ? (
        duty = 0.5 + (osc_pwm - 0.5) * 0.98;
        osc_raw = (osc_square_pwm(osc_ph1, dt1, duty) + osc_square_pwm(osc_ph2, dt2, duty)) * 0.5;
        osc_raw *= 0.707 / sqrt(max(0.05, min(0.95, duty)));
    ) : (
        sq1 = osc_square(osc_ph1, dt1); sq2 = osc_square(osc_ph2, dt2);
        tri_int1 += (sq1 - tri_int1) * dt1; tri_int2 += (sq2 - tri_int2) * dt2;
        shape_gamma = 0.2 + 1.6 * osc_pwm;
        tri_sum = tri_int1 + tri_int2;
        tri_shaped = tri_sum >= 0 ? pow(tri_sum, shape_gamma) : -pow(-tri_sum, shape_gamma);
        osc_raw = tri_shaped * 1.35;
    );
    osc_tone_amt = max(-1, min(1, osc_tone));
    last_osc_lp += (osc_raw - last_osc_lp) * (1 - pole);
    osc_low = last_osc_lp; osc_high = osc_raw - osc_low;
    osc_w_low = 0.5 - 0.5 * osc_tone_amt; osc_w_high = 0.5 + 0.5 * osc_tone_amt;
    osc_tilt = (osc_low * osc_w_low + osc_high * osc_w_high) / (osc_w_low + osc_w_high);
    osc_tilt *= 1.0 / (0.75 + abs(osc_tone_amt) * 0.35);
    osc_out = sat(osc_tilt, osc_drive) * v_osc * trim_o;

    // CHUA
    k_mod = min(c_k * doppler_ratio, 0.5); 
    dx=k_mod*c_al*(chua_v.y-chua_v.x-c_b*chua_v.x-0.5*(c_a-c_b)*(abs(chua_v.x+1)-abs(chua_v.x-1)));
    dy=k_mod*(chua_v.x-chua_v.y+chua_v.z);
    dz=k_mod*(-c_be*chua_v.y-c_ga*chua_v.z);
    chua_v.x+=dx; chua_v.y+=dy; chua_v.z+=dz;
    chua_v.x=max(-10,min(10,chua_v.x)); chua_v.y=max(-10,min(10,chua_v.y)); chua_v.z=max(-10,min(10,chua_v.z));
    c_al = max(5.0, c_al);
    chua_raw = safe(dc_x.DC5_aProc(fch, chua_v.x)*0.3);
    chua_sig = chua_raw - last_chua + 0.995 * chua_sig; last_chua = chua_raw;
    chua_out = chua_sig * v_ch * trim_c;

    ext = (spl0+spl1)*0.5 * v_ext * trim_e;

    // === AUDIO PITCH ENGINE ===
    sig_noise_clean = wn_out;
    sig_mix_pre_ps = osc_out + chua_out + ext;

    // Determine routing
    // [FIXED] Routing should respect noise_routing even in Doppler Mode.
    // However, if we pitch shift Ext/Osc/Chua, they always go to buffer.
    
    ps_input_base = sig_mix_pre_ps;
    
    // Add noise to pitch buffer ONLY if routing is set to 1 (Pitched)
    ps_input = ps_input_base + (noise_routing == 1 ? sig_noise_clean : 0);

    // Audio Pitch Buffer Write
    ps_ratio += (ps_ratio_t - ps_ratio) * param_sm_coeff;
    ps_wr = (ps_wr + 1) % ps_len;
    ps_bufL[ps_wr] = ps_input;

    // Read Heads
    ps_rd1 += ps_ratio; ps_rd2 += ps_ratio;
    ps_rd1 >= ps_grain ? ( ps_rd1 -= ps_grain; ps_rd1 += (rand(20)-10); );
    ps_rd2 >= ps_grain ? ( ps_rd2 -= ps_grain; ps_rd2 += (rand(20)-10); );

    // CUBIC INTERPOLATION
    idx1 = (ps_wr - ps_grain + ps_rd1 + ps_len) % ps_len;
    out1 = interpolate_cubic(ps_bufL, idx1, ps_len);
    win1 = 0.5 - 0.5 * cos(ps_rd1 / ps_grain * TWO_PI);
    
    idx2 = (ps_wr - ps_grain + ps_rd2 + ps_len) % ps_len;
    out2 = interpolate_cubic(ps_bufL, idx2, ps_len);
    win2 = 0.5 - 0.5 * cos(ps_rd2 / ps_grain * TWO_PI);

    sig_pitched = (out1 * win1) + (out2 * win2);
    
    // Anti-Thump
    sig_pitched = fix_thump.hp_thump_removal(sig_pitched);

    // MUX: Combine Signals
    sig_in = 0;
    
    // If noise is CLEAN, we need to add it back separately.
    dry_noise_signal = (noise_routing == 0 ? sig_noise_clean : 0);
    
    pitch_mode == 3 ? ( 
        // === MODE 3: PHYSICAL DOPPLER ===
        dist_f = min(1.0, abs(audio_pitch) / 12);
        dop_min = 200 + (1-doppler_air) * 10000;
        dop_cut = 20000 - (20000 - dop_min) * dist_f;
        dop_cut = max(100, dop_cut);
        
        // Filter the pitched signal (Osc/Chua/Ext + maybe Noise)
        // Add Dry Noise (if any) bypassing the filter
        sig_in = dp_filt.lpf_doppler(sig_pitched, dop_cut) + dry_noise_signal;
        
    ) : pitch_mode == 2 ? (
        // === MODE 2: AUDIO PITCH ===
        sig_in = safe(sig_pitched + dry_noise_signal);
        
    ) : (
        // === MODE 0/1: SYNTH SHIFT ===
        // Bypass Audio PS completely
        sig_in = safe(sig_noise_clean + sig_mix_pre_ps);
    );

    // === FX CHAIN START ===
    
    // REVERB PRE-FILTER
    rv_mix > 0.001 ? (
        rv_rt = rvb_len * (0.15 + rv_size * 0.45); 
        rv_fb = min(0.75, 0.18 + rv_tail * 0.45);
        rv_in = sig_in;
        rd = (rv_idx - rv_rt + rvb_len)%rvb_len; 
        ri = floor(rd); rf = rd-ri;
        val_r = rv_buf[ri]*(1-rf) + rv_buf[(ri+1)%rvb_len]*rf;
        val_r = val_r + (last_r - val_r) * (1.0 - rv_damp); last_r = val_r;
        val_r = sat(val_r, 0.35);
        fb_in = rv_in + val_r * rv_fb;
        rv_dc = fb_in - last_rv_in + 0.995 * rv_dc; last_rv_in = fb_in;
        rv_saturated = rv_dc * (1 + rv_dc*rv_dc*0.1) / (1 + abs(rv_dc)*0.5);
        rv_buf[rv_idx] = max(-1.5, min(1.5, rv_saturated)); 
        rv_idx = (rv_idx+1)%rvb_len;
        sig_in = safe(rv_in + val_r * rv_mix);
    );

    // FILTER
    g = tan(PI * cut_hz / (srate*2)); k_damp = 2 - 2*res;
    os_loop = 0;
    loop(2,
        in_s = sig_in - 0.1 * (z1 * abs(z1)); 
        v_hp = (in_s - k_damp*z1 - z2) / (1 + g*k_damp + g*g);
        v_bp = g*v_hp + z1; v_lp = g*v_bp + z2;
        z1 = safe(g*v_hp + v_bp); z2 = safe(g*v_bp + v_lp);
        ls = v_lp * (1-my) + v_hp * my; 
        rs = v_bp * (1-my) + (v_hp+v_lp) * my;
        out_os = ls * (1-mx) + rs * mx;
        os_loop == 0 ? samp1 = out_os : samp2 = out_os;
        os_loop += 1;
    );
    sig_filt = (samp1 + samp2) * 0.5;

    // Ring Mod - амплітудна модуляція з металевим тембром (більша глибина)
    ring_metal > 0.001 ? (
        ring_ph += ring_step; ring_ph > TWO_PI ? ring_ph -= TWO_PI;
        ring_mod_val = sin(ring_ph);
        mod_gain = 1.0 + (ring_metal * ring_mod_val * 0.5);
        sig_filt *= mod_gain;
    );

    // ENVELOPE
    sig_shaped = sig_filt * cur_env;
    sat_drive > 0.001 ? sig_shaped = sat(sig_shaped, sat_drive * 3.0);

    // BITCRUSH
    crush_mix > 0.001 ? (
        c_step = (1.0 / crush_rate); c_cnt += 1;
        c_cnt >= c_step ? ( c_cnt = 0; c_held = floor(sig_shaped * 256 + 0.5) / 256; );
        sig_shaped = sig_shaped * (1-crush_mix) + c_held * crush_mix;
    );

    // FLANGER
    fl_mix > 0.001 ? (
        fl_ph += (TWO_PI*0.2)/srate; fl_ph>TWO_PI ? fl_ph-=TWO_PI;
        fl_d = (sin(fl_ph)+1)*0.5*0.005*srate;
        rd = (fl_idx - fl_d + flange_len)%flange_len; ri=floor(rd); rf=rd-ri;
        val_d = fl_buf[ri]*(1-rf) + fl_buf[(ri+1)%flange_len]*rf;
        fl_buf[fl_idx] = (sig_shaped+sig_shaped)*0.5 + val_d * fl_feed; fl_idx = (fl_idx+1)%flange_len;
        s_fL = sig_shaped*(1-fl_mix) + val_d*fl_mix; s_fR = sig_shaped*(1-fl_mix) + val_d*fl_mix;
    ) : (
        s_fL = sig_shaped; s_fR = sig_shaped; 
        fl_buf[fl_idx] = sig_shaped; fl_idx = (fl_idx+1)%flange_len;
    );

    // DOUBLER
    dbl_mix > 0.001 ? (
        dbl_s = (dbl_time_ms * 0.001) * srate;
        rdL = (dbl_idx - dbl_s + dbl_len)%dbl_len;
        rdR = (dbl_idx - dbl_s * (1.0 + dbl_wide*0.5) + dbl_len)%dbl_len;
        dbl_buf[dbl_idx] = s_fL; dbl_idx = (dbl_idx+1)%dbl_len; 
        s_dL = s_fL + dbl_buf[floor(rdL)] * dbl_mix;
        s_dR = s_fR + dbl_buf[floor(rdR)] * dbl_mix;
    ) : (
        s_dL = s_fL; s_dR = s_fR; dbl_buf[dbl_idx] = s_fL; dbl_idx = (dbl_idx+1)%dbl_len;
    );

    // WIDTH
    wid > 0.001 ? (
        wid_buf[wid_idx] = (s_dL + s_dR)*0.5;
        rdL = (wid_idx - (srate*0.005) + wid_len)%wid_len; rdR = (wid_idx - (srate*0.013) + wid_len)%wid_len;
        L_base = s_dL + wid_buf[floor(rdL)] * wid * 0.5; R_base = s_dR + wid_buf[floor(rdR)] * wid * 0.5;
        wid_idx = (wid_idx+1)%wid_len;
    ) : ( L_base = s_dL; R_base = s_dR; );

    // PUNCH
    punch_amt > 0.0001 ? (
        punch_gain = min(3.0, 1 + punch_amt * pow(cur_env, 0.5) * 1.6);
        L_base *= punch_gain; R_base *= punch_gain;
    );

    // CHOPPER
    chop_depth > 0.001 ? (
        chop_rate = 1.0 + chop_rate_norm * 39.0;
        chop_ph += chop_rate / srate; chop_ph > 1.0 ? chop_ph -= 1.0;
        gate_raw = (chop_ph < 0.5) ? 1.0 : 0.0;
        slew = 0.05 + 0.945 * chop_shape;
        gate_smooth = gate_smooth * slew + gate_raw * (1.0 - slew);
        gain_mod = 1.0 - (chop_depth * (1.0 - gate_smooth));
        L_base *= gain_mod; R_base *= gain_mod;
    ) : gain_mod = 1.0;

    // DC BLOCK & OUT
    dc_L = L_base - dc_l_s + 0.995*dc_L; dc_l_s=L_base; L_base=dc_L;
    dc_R = R_base - dc_r_s + 0.995*dc_R; dc_r_s=R_base; R_base=dc_R;
    
    L_base *= gate_env; R_base *= gate_env; sub_sig *= gate_env;

    sub_out = sat(sub_sig * 0.25, 0.1);

    out_mode < 0.5 ? ( 
        ang = p_x * PI * 0.5; 
        spl0 = (L_base * cos(ang)) + sub_out; spl1 = (R_base * sin(ang)) + sub_out;
        spl2=spl3=spl4=spl5=0;
    ) : (
        // Surround 5.1: Use sur_x/sur_y from automation (both Vector and Circle modes)
        
        // Mode 2: Full Circles - use internal phase accumulator
        sur_mode >= 1.5 ? (
            // Full Circles mode: phase driven by envelope intensity
            // Advance phase continuously while whoosh is active
            cur_env > 0.001 ? (
                // Use cur_env as velocity multiplier for smooth acceleration/deceleration
                // Assume 1.5 sec average whoosh duration for 1 full rotation
                phase_step = (sur_full_rotations * TWO_PI * cur_env) / (srate * 1.5);
                direction = sur_direction >= 0.5 ? -1 : 1;
                circle_phase += phase_step * direction;
            );
            
            // Apply offset and calculate position
            angle_rad = circle_phase + (sur_full_offset * TWO_PI);
            
            // Convert to X/Y coordinates (centered at 0.5, 0.5 with radius 0.42)
            path_r = 0.42;
            p_x_sur = 0.5 + path_r * cos(angle_rad);
            p_y_sur = 0.5 + path_r * sin(angle_rad);
        ) : (
            // Mode 0/1: Vector or Circle Arc - use automation values
            p_x_sur = max(0, min(1, sur_x));
            p_y_sur = max(0, min(1, sur_y));
        );

        // Convert normalized X/Y to angle (-180 to +180, 0=front)
        dx_pos = p_x_sur - 0.5;
        dy_pos = p_y_sur - 0.5;
        src_angle = atan2(dx_pos, dy_pos) * 180 / $pi;
        
        // Create mono source for proper VBAP panning
        mono_src = (L_base + R_base) * 0.5;
        
        // ITU-R BS.775 speaker angles
        ang_C = 0;  ang_L = -30;  ang_R = 30;
        ang_Ls = -110;  ang_Rs = 110;
        
        // Normalize source angle to [0, 360) for sector detection
        src_norm = src_angle;
        src_norm < 0 ? src_norm += 360;
        
        // Normalize speaker angles to [0, 360)
        norm_C = 0;  norm_R = 30;  norm_Rs = 110;
        norm_Ls = 250;  norm_L = 330;
        
        // Initialize gains
        g_L = 0; g_R = 0; g_C = 0; g_Ls = 0; g_Rs = 0;
        
        // Find active speaker pair and calculate gains (proper VBAP)
        // Only TWO adjacent speakers should be active at any time
        
        src_norm >= 0 && src_norm < 30 ? (
            // Sector: C -> R (0° to 30°)
            t = src_norm / 30;
            g_C = cos(t * $pi * 0.5);
            g_R = sin(t * $pi * 0.5);
        ) :
        src_norm >= 30 && src_norm < 110 ? (
            // Sector: R -> Rs (30° to 110°)
            t = (src_norm - 30) / 80;
            g_R = cos(t * $pi * 0.5);
            g_Rs = sin(t * $pi * 0.5);
        ) :
        src_norm >= 110 && src_norm < 250 ? (
            // Sector: Rs -> Ls (110° to 250°, rear arc)
            t = (src_norm - 110) / 140;
            g_Rs = cos(t * $pi * 0.5);
            g_Ls = sin(t * $pi * 0.5);
        ) :
        src_norm >= 250 && src_norm < 330 ? (
            // Sector: Ls -> L (250° to 330°)
            t = (src_norm - 250) / 80;
            g_Ls = cos(t * $pi * 0.5);
            g_L = sin(t * $pi * 0.5);
        ) :
        (
            // Sector: L -> C (330° to 360°/0°, wraps around)
            t = (src_norm - 330) / 30;
            g_L = cos(t * $pi * 0.5);
            g_C = sin(t * $pi * 0.5);
        );
        
        // Distribute mono signal to all speakers
        spl0 = mono_src * g_L;   // Front L
        spl1 = mono_src * g_R;   // Front R
        spl2 = mono_src * g_C;   // Center
        spl3 = sub_out;          // LFE
        spl4 = mono_src * g_Ls;  // Rear L
        spl5 = mono_src * g_Rs;  // Rear R
    );

    m_dec = 0.9998;
    gmem[0] = max(gmem[0]*m_dec, abs(wn_out));
    gmem[1] = max(gmem[1]*m_dec, abs(osc_out));
    gmem[2] = max(gmem[2]*m_dec, abs(chua_out));
    gmem[3] = max(gmem[3]*m_dec, abs(ext));

    out_mode < 0.5 ? (
        ch0 = abs(spl0 * master_gain); ch1 = abs(spl1 * master_gain); ch2 = 0; ch3 = abs(sub_out * master_gain); ch4 = 0; ch5 = 0;
    ) : (
        ch0 = abs(spl0 * master_gain); ch1 = abs(spl1 * master_gain); ch2 = abs(spl2 * master_gain);
        ch3 = abs(spl3 * master_gain); ch4 = abs(spl4 * master_gain); ch5 = abs(spl5 * master_gain);
    );
    gmem[4] = max(gmem[4]*m_dec, ch0); gmem[5] = max(gmem[5]*m_dec, ch1);
    gmem[6] = max(gmem[6]*m_dec, ch2); gmem[7] = max(gmem[7]*m_dec, ch3);
    gmem[8] = max(gmem[8]*m_dec, ch4); gmem[9] = max(gmem[9]*m_dec, ch5);

    gmem[10] = spl0; gmem[11] = spl1;

    spl0 = lim(spl0 * master_gain); spl1 = lim(spl1 * master_gain);
    spl2 = lim(spl2 * master_gain); spl3 = lim(spl3 * master_gain);
    spl4 = lim(spl4 * master_gain); spl5 = lim(spl5 * master_gain);

) : (
    spl0=spl1=spl2=spl3=spl4=spl5=0;
    gmem[0]*=0.99; gmem[1]*=0.99; gmem[2]*=0.99; gmem[3]*=0.99;
    gmem[4]*=0.99; gmem[5]*=0.99; gmem[6]*=0.99; gmem[7]*=0.99; gmem[8]*=0.99; gmem[9]*=0.99;
);
