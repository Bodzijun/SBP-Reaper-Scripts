desc: sbp_WhooshEngine
author: SBP & Gemini 
version: 2.5
options:gmem=sbp_whoosh

// === 1. MIXER MATRIX (Range 0..2.0 for Boost) ===
slider1:0.5<0,2,0.001>Mix: White Noise
slider2:0.5<0,2,0.001>Mix: Sawtooth
slider3:0.5<0,2,0.001>Mix: Chua Osc
slider4:0.0<0,2,0.001>Mix: External Input

// === 2. GENERATOR PARAMS ===
slider5:55<30,120,1>Base: Frequency (Hz)
slider6:0.0<0,2,0.001>Sub: Volume
slider7:0.05<0.001,0.5,0.001>Chua: Rate
slider8:28.0<10,45,0.1>Chua: Shape
slider9:-2.0<-20,20,0.1>Chua: Timbre
slider27:0.1<0,1,0.001>Saw: PWM
slider32:0.0<-50,50,0.1>Saw: Detune (cents)

// === 3. FILTER ===
slider10:0.5<0,1,0.001>Filter: Morph X
slider11:0.5<0,1,0.001>Filter: Morph Y
slider12:0.5<0,1,0.001>Filter: Cutoff
slider13:0.5<0,0.98,0.001>Filter: Resonance

// === 4. EFFECTS ===
slider14:0.0<0,1,0.001>Flange: Feedback
slider15:0.0<0,1,0.001>Flange: Mix
slider16:0.5<0,1,0.001>Reverb: Size
slider17:0.0<0,1,0.001>Reverb: Mix
slider28:0.5<0,1,0.001>Reverb: Damping
slider29:0.0<0,1,0.001>Dbl: Mix
slider30:20<10,60,1>Dbl: Delay
slider31:0.5<0,1,0.001>Dbl: Spread

// === 5. CHOPPER (Trance Gate) ===
slider33:0.0<0,1,0.001>Chop: Depth
slider34:0.5<0,1,0.001>Chop: Rate
slider35:0.0<0,1,0.001>Chop: Shape (Hard/Soft)

// === 6. OUTPUT & SPACE ===
slider18:0.5<0,1,0.001>Pan X (L-R)
slider19:0.0<0,1,0.001>Pan Y (Front-Rear)
slider20:0.0<0,1,0.001>Width
slider21:0<0,1,1{Stereo,5.1}>Output Mode
slider22:-6.0<-60,12,0.1>MASTER VOL (dB)

// === 7. TRIMS (Range 0..2.0) ===
slider23:1.0<0,2,0.01>Trim: White
slider24:1.0<0,2,0.01>Trim: Saw
slider25:1.0<0,2,0.01>Trim: Chua
slider26:1.0<0,2,0.01>Trim: Ext

// Internal
slider40:15.6<-20,20,0.01>-Chua Alpha
slider41:28.58<-20,40,0.01>-Chua Beta Base
slider42:-1.14<-5,5,0.01>-Chua A
slider43:-0.71<-5,5,0.01>-Chua B
slider44:0.0<-12,12,0.1>-Global Pitch Shift

in_pin:Input L
in_pin:Input R
out_pin:Front L
out_pin:Front R
out_pin:Center
out_pin:LFE
out_pin:Rear L
out_pin:Rear R

@init
PI = 3.14159265359;
SR = srate;

function DC5_init() ( this.R1=this.R2=this.R3=this.R4=this.R5=0; );
function DC5_aProc(x0, x1) local(h0,h1,h3,h5,h5x0,h3x0,h1x0) (
  h0=0.5; h1=0.3; h3=-0.06; h5=0.013; 
  h5x0=h5*x0; h3x0=h3*x0; h1x0=h1*x0;
  this.R6=this.R5+h5x0; this.R5=this.R4+h3x0; this.R4=this.R3+h1x0;
  this.R3=this.R2+h1x0+h0*x1; this.R2=this.R1+h3x0; this.R1=h5x0;
  this.R6;
);
function lim(x) ( max(-1.0, min(1.0, x)) );
function safe(x) ( (x!=x) ? 0 : max(-4.0, min(4.0, x)); ); 

dc_x.DC5_init(); 
chua_v.x=0.1; chua_v.y=0; chua_v.z=0;

// Memory Allocation
flange_len = srate*0.02; fl_buf=0; fl_idx=0;
rvb_len = srate*0.5; rv_buf=fl_buf+flange_len+100; rv_idx=0;

wid_len = srate*0.05; wid_buf=rv_buf+rvb_len+100; wid_idx=0;
dbl_len = srate*0.1; dbl_buf=wid_buf+wid_len+100; dbl_idx=0;

// Granulator Buffer (kept for safety)
gran_len = srate * 1.0; gran_buf = dbl_buf + dbl_len + 1000; 

sm_coeff = 1 - exp(-1/(srate*0.005));      
param_sm_coeff = 1 - exp(-1/(srate*0.02)); 

z1=0; z2=0;
sub_ph = 0; fl_ph = 0; saw_ph1 = 0; saw_ph2 = 0;

note_gate = 0; 
amp_env = 0;
rel_coeff = exp(-1/(srate*0.01)); 

// Chopper State
chop_ph = 0;
gate_smooth = 0;

// States
dc_l_s=0; dc_r_s=0; dc_sub_s=0;
last_r=0; last_rv_in=0; rv_dc=0;

@block
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & 0xF0;
  (status == 0x90 && msg3 > 0) ? (
    note_gate = 1;
    sub_ph = 0; fl_ph = 0; saw_ph1 = 0; saw_ph2 = 0;
    chua_v.x=0.1; chua_v.y=0; chua_v.z=0;
    // Reset Chopper
    chop_ph = 0; gate_smooth = 1.0;
  );
  (status == 0x80 || (status == 0x90 && msg3 == 0)) ? ( note_gate = 0; );
  (status == 0xB0 && msg2 == 123) ? ( note_gate = 0; );
);

@slider
// Generators
t_v_wn=slider1; t_v_saw=slider2; t_v_ch=slider3; t_v_ext=slider4;
sub_hz=slider5; t_v_sub_dir=slider6; 
c_k=slider7; c_be=slider8; c_ga=slider9;
saw_pwm=slider27;
saw_detune=slider32; 

// Filter
t_mx=slider10; t_my=slider11; f_sc=slider12; t_res=slider13;

// FX
fl_feed=slider14; fl_mix=slider15;
rv_size=0.2+slider16*0.75; rv_mix=slider17; rv_damp=slider28;
dbl_mix=slider29; dbl_time_ms=slider30; dbl_wide=slider31;

// Chopper
chop_depth=slider33; chop_rate_norm=slider34; chop_shape=slider35;

// Output
t_p_x=slider18; t_p_y=slider19; wid=slider20; mode=slider21;
master_gain = 10^(slider22/20);

// Trims
trim_w=slider23; trim_s=slider24; trim_c=slider25; trim_e=slider26;

// Internal
pitch_mod_st=slider44; 
c_al=slider40; c_a=slider42; c_b=slider43;

// Calcs
t_cut = 20 * (1000 ^ f_sc); t_cut = max(20, min(20000, t_cut));
doppler_ratio = 2 ^ (pitch_mod_st / 12);
sub_step = 2 * $pi * (sub_hz * doppler_ratio) / srate;

detune_factor = 2 ^ (saw_detune / 1200);
saw_step1 = sub_step;
saw_step2 = sub_step * detune_factor;

@sample
target_amp = note_gate ? 1.0 : 0.0;
amp_env = target_amp + (amp_env - target_amp) * rel_coeff;

v_wn += (t_v_wn - v_wn) * param_sm_coeff;
v_saw += (t_v_saw - v_saw) * param_sm_coeff;
v_ch += (t_v_ch - v_ch) * param_sm_coeff;
v_ext += (t_v_ext - v_ext) * param_sm_coeff;
v_sub_dir += (t_v_sub_dir - v_sub_dir) * param_sm_coeff;
p_x += (t_p_x - p_x) * param_sm_coeff;
p_y += (t_p_y - p_y) * param_sm_coeff;

cut_hz = cut_hz + (t_cut - cut_hz) * sm_coeff;
res    = res    + (t_res - res)    * sm_coeff;
mx     = mx     + (t_mx - mx)      * sm_coeff;
my     = my     + (t_my - my)      * sm_coeff;

m_dec = 0.9998; 

// FORCE SILENCE FOR SCOPE IF AMP IS LOW
abs(amp_env) < 0.001 ? (
    spl0=spl1=spl2=spl3=spl4=spl5=0;
    gmem[0]*=m_dec; gmem[1]*=m_dec; gmem[2]*=m_dec; gmem[3]*=m_dec; gmem[4]*=m_dec; gmem[5]*=m_dec; gmem[6]*=m_dec;
    gmem[7]=0; gmem[8]=0;
) : (
    
    // --- 1. GENERATORS ---
    wn = (rand(2)-1) * v_wn * trim_w;

    sub_ph += sub_step; sub_ph > 2*$pi ? sub_ph -= 2*$pi;
    sub_direct_sig = sin(sub_ph) * v_sub_dir; 
    
    saw_ph1 += saw_step1; saw_ph1 > 2*$pi ? saw_ph1 -= 2*$pi;
    saw_ph2 += saw_step2; saw_ph2 > 2*$pi ? saw_ph2 -= 2*$pi;
    
    pwm_f = 1.0 + saw_pwm*0.02;
    s1 = ((1.0 - saw_ph1/$pi) + (1.0 - (saw_ph1*pwm_f%(2*$pi))/$pi)) * 0.5;
    s2 = ((1.0 - saw_ph2/$pi) + (1.0 - (saw_ph2*pwm_f%(2*$pi))/$pi)) * 0.5;
    saw_raw = (s1 + s2) * 0.5;
    
    k_mod = min(c_k * doppler_ratio, 0.5); 
    dx=k_mod*c_al*(chua_v.y-chua_v.x-c_b*chua_v.x-0.5*(c_a-c_b)*(abs(chua_v.x+1)-abs(chua_v.x-1)));
    dy=k_mod*(chua_v.x-chua_v.y+chua_v.z);
    dz=k_mod*(-c_be*chua_v.y-c_ga*chua_v.z);
    
    chua_v.x+=dx; chua_v.y+=dy; chua_v.z+=dz;
    chua_v.x=max(-10,min(10,chua_v.x)); 
    chua_v.y=max(-10,min(10,chua_v.y)); 
    chua_v.z=max(-10,min(10,chua_v.z));
    
    chua_raw = safe(dc_x.DC5_aProc(fch, chua_v.x)*0.3);
    chua_sig = chua_raw - last_chua + 0.995 * chua_sig; last_chua = chua_raw;
    chua_out = chua_sig * v_ch * trim_c;

    gmem[0] = max(gmem[0]*m_dec, abs(wn));
    gmem[1] = max(gmem[1]*m_dec, abs(saw_raw * v_saw * trim_s));
    gmem[2] = max(gmem[2]*m_dec, abs(chua_out));
    gmem[3] = max(gmem[3]*m_dec, abs(ext));

    ext = (spl0+spl1)*0.5 * v_ext * trim_e;
    sig_in = safe(wn + (saw_raw * v_saw * trim_s) + chua_out + ext);

    // --- 2. FILTER ---
    os_loop = 0;
    loop(2,
      g = tan($pi * cut_hz / (srate*2)); k_damp = 2 - 2*res;
      in_s = sig_in - 0.1 * (z1 * abs(z1)); 
      v_hp = (in_s - k_damp*z1 - z2) / (1 + g*k_damp + g*g);
      v_bp = g*v_hp + z1; v_lp = g*v_bp + z2;
      z1 = safe(g*v_hp + v_bp); z2 = safe(g*v_bp + v_lp);
      ls = v_lp * (1-my) + v_hp * my; rs = v_bp * (1-my) + (v_hp+v_lp) * my;
      out_os = ls * (1-mx) + rs * mx;
      os_loop == 0 ? samp1 = out_os : samp2 = out_os;
      os_loop += 1;
    );
    sig_post = (samp1 + samp2) * 0.5 * amp_env;

    // --- 3. EFFECTS ---
    
    // CHOPPER (Trance Gate) with Shape
    chop_depth > 0.001 ? (
        // Rate: 1Hz to 40Hz
        chop_rate = 1.0 + chop_rate_norm * 39.0;
        
        chop_ph += chop_rate / srate;
        chop_ph > 1.0 ? chop_ph -= 1.0;
        
        // Hard Square
        gate_raw = (chop_ph < 0.5) ? 1.0 : 0.0;
        
        // Smoothing coefficient
        slew = 0.5 + 0.499 * chop_shape;
        
        // Slew Limiter
        gate_smooth = gate_smooth * slew + gate_raw * (1.0 - slew);
        
        // Apply Depth
        gain_mod = 1.0 - (chop_depth * (1.0 - gate_smooth));
        
        sig_post *= gain_mod;
    );

    // Doubler
    dbl_mix > 0.001 ? (
       dbl_s = (dbl_time_ms * 0.001) * srate;
       rdL = (dbl_idx - dbl_s + dbl_len)%dbl_len;
       rdR = (dbl_idx - dbl_s * (1.0 + dbl_wide*0.5) + dbl_len)%dbl_len;
       dbl_buf[dbl_idx] = sig_post; dbl_idx = (dbl_idx+1)%dbl_len;
       s_dL = sig_post + dbl_buf[floor(rdL)] * dbl_mix;
       s_dR = sig_post + dbl_buf[floor(rdR)] * dbl_mix;
    ) : (
       s_dL = s_dR = sig_post; dbl_buf[dbl_idx] = sig_post; dbl_idx = (dbl_idx+1)%dbl_len;
    );

    // Flanger
    fl_mix > 0.001 ? (
      fl_ph += (2*$pi*0.2)/srate; fl_ph>2*$pi ? fl_ph-=2*$pi;
      fl_d = (sin(fl_ph)+1)*0.5*0.005*srate;
      rd = (fl_idx - fl_d + flange_len)%flange_len; ri=floor(rd); rf=rd-ri;
      val_d = fl_buf[ri]*(1-rf) + fl_buf[(ri+1)%flange_len]*rf;
      fl_buf[fl_idx] = (s_dL+s_dR)*0.5 + val_d * fl_feed; fl_idx = (fl_idx+1)%flange_len;
      s_fL = s_dL*(1-fl_mix) + val_d*fl_mix; s_fR = s_dR*(1-fl_mix) + val_d*fl_mix;
    ) : (
      s_fL = s_dL; s_fR = s_dR; fl_buf[fl_idx] = (s_dL+s_dR)*0.5; fl_idx = (fl_idx+1)%flange_len;
    );

    // Reverb
    rv_mix > 0.001 ? (
      rv_rt = rvb_len * rv_size;
      rd = (rv_idx - rv_rt + rvb_len)%rvb_len; 
      ri = floor(rd); rf = rd-ri;
      val_r = rv_buf[ri]*(1-rf) + rv_buf[(ri+1)%rvb_len]*rf;
      val_r = val_r + (last_r - val_r) * (1.0 - rv_damp); last_r = val_r;
      fb_in = (s_fL+s_fR)*0.5 + val_r * 0.85;
      rv_dc = fb_in - last_rv_in + 0.995 * rv_dc; last_rv_in = fb_in;
      rv_buf[rv_idx] = max(-1.5, min(1.5, rv_dc)); 
      rv_idx = (rv_idx+1)%rvb_len;
      s_rL = s_fL + val_r * rv_mix; s_rR = s_fR + val_r * rv_mix;
    ) : (
      s_rL = s_fL; s_rR = s_fR; rv_buf[rv_idx] = (s_fL+s_fR)*0.5 * 0.5; rv_idx = (rv_idx+1)%rvb_len;
    );

    // Width
    wid > 0.001 ? (
      wid_buf[wid_idx] = (s_rL + s_rR)*0.5;
      rdL = (wid_idx - (srate*0.005) + wid_len)%wid_len;
      rdR = (wid_idx - (srate*0.013) + wid_len)%wid_len;
      L_base = s_rL + wid_buf[floor(rdL)] * wid * 0.5;
      R_base = s_rR + wid_buf[floor(rdR)] * wid * 0.5;
      wid_idx = (wid_idx+1)%wid_len;
    ) : (
      L_base = s_rL; R_base = s_rR;
    );
    
    // DC BLOCKING
    dc_L = L_base - dc_l_s + 0.995*dc_L; dc_l_s=L_base; L_base=dc_L;
    dc_R = R_base - dc_r_s + 0.995*dc_R; dc_r_s=R_base; R_base=dc_R;
    dc_Sub = sub_direct_sig - dc_sub_s + 0.995*dc_Sub; dc_sub_s=sub_direct_sig; sub_direct_sig=dc_Sub;

    // Output Metering 
    gmem[4] = max(gmem[4]*m_dec, abs(L_base * master_gain));
    gmem[5] = max(gmem[5]*m_dec, abs(R_base * master_gain));
    gmem[6] = max(gmem[6]*m_dec, abs(sub_direct_sig * master_gain));

    // SCOPE RAW VALUES (7=L Raw, 8=R Raw)
    gmem[7] = L_base * master_gain;
    gmem[8] = R_base * master_gain;

    // --- 4. OUTPUT MATRIX ---
    mode < 0.5 ? (
      ang = p_x * $pi * 0.5; 
      spl0 = (L_base * cos(ang)) + sub_direct_sig; 
      spl1 = (R_base * sin(ang)) + sub_direct_sig;
      spl2=spl3=spl4=spl5=0;
    ) : (
      gL = cos(p_x * $pi * 0.5); gR = sin(p_x * $pi * 0.5);
      spl0 = L_base * p_y * gL;        
      spl1 = R_base * p_y * gR;        
      spl2 = (spl0+spl1)*0.5 * 0.5;    
      spl3 = sub_direct_sig;           
      spl4 = L_base * (1.0 - p_y) * gL; 
      spl5 = R_base * (1.0 - p_y) * gR; 
    );

    spl0 = lim(spl0 * master_gain);
    spl1 = lim(spl1 * master_gain);
    spl2 = lim(spl2 * master_gain);
    spl3 = lim(spl3 * master_gain);
    spl4 = lim(spl4 * master_gain);
    spl5 = lim(spl5 * master_gain);
);