desc: sbp_WhooshEngine
author: SBP & Gemini 
version: 1.0

// === 1. MIXER MATRIX ===
slider1:0.5<0,1,0.001>Mix: White Noise
slider2:0.5<0,1,0.001>Mix: Sawtooth
slider3:0.5<0,1,0.001>Mix: Chua Osc
slider4:0.0<0,1,0.001>Mix: External Input

// === 2. GENERATOR PARAMS ===
slider5:55<30,120,1>Base: Frequency (Hz)
slider6:0.0<0,1,0.001>Sub: Volume
slider7:0.05<0.001,0.5,0.001>Chua: Rate
slider8:28.0<10,45,0.1>Chua: Shape
slider9:-2.0<-20,20,0.1>Chua: Timbre
slider27:0.1<0,1,0.001>Saw: PWM
slider32:0.0<-50,50,0.1>Saw: Detune (cents)

// === 3. FILTER ===
slider10:0.5<0,1,0.001>Filter: Morph X
slider11:0.5<0,1,0.001>Filter: Morph Y
slider12:0.5<0,1,0.001>Filter: Cutoff
slider13:0.5<0,0.98,0.001>Filter: Resonance

// === 4. EFFECTS ===
slider14:0.0<0,1,0.001>Flange: Feedback
slider15:0.0<0,1,0.001>Flange: Mix
slider16:0.5<0,1,0.001>Reverb: Size
slider17:0.0<0,1,0.001>Reverb: Mix
slider28:0.5<0,1,0.001>Reverb: Damping
slider29:0.0<0,1,0.001>Doubler: Mix
slider30:20<10,60,1>Doubler: Delay
slider31:0.5<0,1,0.001>Doubler: Wide

// === 5. OUTPUT & SPACE ===
slider18:0.5<0,1,0.001>Pan X (L-R)
slider19:0.0<0,1,0.001>Pan Y (Front-Rear)
slider20:0.0<0,1,0.001>Width
slider21:0<0,1,1{Stereo,5.1}>Output Mode
slider22:-6.0<-60,12,0.1>MASTER VOL (dB)

// === 6. TRIMS ===
slider23:1.0<0,1,0.01>Trim: White
slider24:1.0<0,1,0.01>Trim: Saw
slider25:1.0<0,1,0.01>Trim: Chua
slider26:1.0<0,1,0.01>Trim: Ext

// Internal
slider40:15.6<-20,20,0.01>-Chua Alpha
slider41:28.58<-20,40,0.01>-Chua Beta Base
slider42:-1.14<-5,5,0.01>-Chua A
slider43:-0.71<-5,5,0.01>-Chua B
slider44:0.0<-12,12,0.1>-Global Pitch Shift

in_pin:Input L
in_pin:Input R
out_pin:Front L
out_pin:Front R
out_pin:Center
out_pin:LFE
out_pin:Rear L
out_pin:Rear R

@init
PI = 3.14159265359;
SR = srate;

function DC5_init() ( this.R1=this.R2=this.R3=this.R4=this.R5=0; );
function DC5_aProc(x0, x1) local(h0,h1,h3,h5,h5x0,h3x0,h1x0) (
  h0=0.5; h1=0.3; h3=-0.06; h5=0.013; 
  h5x0=h5*x0; h3x0=h3*x0; h1x0=h1*x0;
  this.R6=this.R5+h5x0; this.R5=this.R4+h3x0; this.R4=this.R3+h1x0;
  this.R3=this.R2+h1x0+h0*x1; this.R2=this.R1+h3x0; this.R1=h5x0;
  this.R6;
);
function lim(x) ( max(-1.0, min(1.0, x)) );

dc_x.DC5_init(); 
chua_v.x=0.1; chua_v.y=0; chua_v.z=0;

flange_len = srate*0.02; fl_buf=0; fl_idx=0;
rvb_len = srate*0.5; rv_buf=fl_buf+flange_len+100; rv_idx=0;
wid_len = srate*0.05; wid_buf=rv_buf+rvb_len+100; wid_idx=0;
dbl_len = srate*0.1; dbl_buf=wid_buf+wid_len+100; dbl_idx=0;

sm_coeff = 1 - exp(-1/(srate*0.005)); 
z1=0; z2=0; 
sub_ph = 0; fl_ph = 0; saw_ph1 = 0; saw_ph2 = 0;

note_gate = 0; 
amp_env = 0;
rel_coeff = exp(-1/(srate*0.01)); 

@block
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & 0xF0;
  (status == 0x90 && msg3 > 0) ? (
    note_gate = 1;
    z1=0; z2=0; 
    sub_ph = 0; fl_ph = 0; saw_ph1 = 0; saw_ph2 = 0;
    chua_v.x=0.1; chua_v.y=0; chua_v.z=0;
    memset(fl_buf, 0, flange_len); 
    memset(rv_buf, 0, rvb_len);
    memset(wid_buf, 0, wid_len);
    memset(dbl_buf, 0, dbl_len);
    fl_idx=0; rv_idx=0; wid_idx=0; dbl_idx=0;
  );
  (status == 0x80 || (status == 0x90 && msg3 == 0)) ? ( note_gate = 0; );
  (status == 0xB0 && msg2 == 123) ? ( note_gate = 0; );
);

@slider
v_wn=slider1; v_saw=slider2; v_ch=slider3; v_ext=slider4;
sub_hz=slider5; v_sub_dir=slider6; 
c_k=slider7; c_be=slider8; c_ga=slider9;
saw_pwm=slider27;
saw_detune=slider32; 

t_mx=slider10; t_my=slider11; f_sc=slider12; t_res=slider13;
fl_feed=slider14; fl_mix=slider15;
rv_size=0.2+slider16*0.75; rv_mix=slider17; rv_damp=slider28;
dbl_mix=slider29; dbl_time_ms=slider30; dbl_wide=slider31;
p_x=slider18; p_y=slider19; wid=slider20; mode=slider21;
master_gain = 10^(slider22/20);
trim_w=slider23; trim_s=slider24; trim_c=slider25; trim_e=slider26;
pitch_mod_st=slider44; 
c_al=slider40; c_a=slider42; c_b=slider43;

t_cut = 20 * (1000 ^ f_sc); t_cut = max(20, min(20000, t_cut));
doppler_ratio = 2 ^ (pitch_mod_st / 12);
sub_step = 2 * $pi * (sub_hz * doppler_ratio) / srate;

// DETUNE CALCULATION
detune_factor = 2 ^ (saw_detune / 1200);
saw_step1 = sub_step;
saw_step2 = sub_step * detune_factor;

@sample
target_amp = note_gate ? 1.0 : 0.0;
amp_env = target_amp + (amp_env - target_amp) * rel_coeff;

abs(amp_env) < 0.001 ? (
    spl0=spl1=spl2=spl3=spl4=spl5=0;
) : (
    cut_hz = cut_hz + (t_cut - cut_hz) * sm_coeff;
    res    = res    + (t_res - res)    * sm_coeff;
    mx     = mx     + (t_mx - mx)      * sm_coeff;
    my     = my     + (t_my - my)      * sm_coeff;

    // --- 1. GENERATORS ---
    wn = (rand(2)-1) * v_wn * trim_w;

    sub_ph += sub_step; sub_ph > 2*$pi ? sub_ph -= 2*$pi;
    sub_direct_sig = sin(sub_ph) * v_sub_dir; 
    
    // Dual Saw (Unison)
    saw_ph1 += saw_step1; saw_ph1 > 2*$pi ? saw_ph1 -= 2*$pi;
    saw_ph2 += saw_step2; saw_ph2 > 2*$pi ? saw_ph2 -= 2*$pi;
    
    pwm_f = 1.0 + saw_pwm*0.02;
    s1 = ((1.0 - saw_ph1/$pi) + (1.0 - (saw_ph1*pwm_f%(2*$pi))/$pi)) * 0.5;
    s2 = ((1.0 - saw_ph2/$pi) + (1.0 - (saw_ph2*pwm_f%(2*$pi))/$pi)) * 0.5;
    saw_raw = (s1 + s2) * 0.5;
    
    k_mod = c_k * doppler_ratio;
    dx=k_mod*c_al*(chua_v.y-chua_v.x-c_b*chua_v.x-0.5*(c_a-c_b)*(abs(chua_v.x+1)-abs(chua_v.x-1)));
    dy=k_mod*(chua_v.x-chua_v.y+chua_v.z); dz=k_mod*(-c_be*chua_v.y-c_ga*chua_v.z);
    chua_v.x+=dx; chua_v.y+=dy; chua_v.z+=dz;
    chua_v.x=max(-8,min(8,chua_v.x)); chua_v.y=max(-8,min(8,chua_v.y)); chua_v.z=max(-8,min(8,chua_v.z));
    chua_raw = dc_x.DC5_aProc(fch, chua_v.x)*0.3;
    chua_sig = chua_raw - last_chua + 0.995 * chua_sig; last_chua = chua_raw;
    chua_out = chua_sig * v_ch * trim_c;

    ext = (spl0+spl1)*0.5 * v_ext * trim_e;
    sig_in = wn + (saw_raw * v_saw * trim_s) + chua_out + ext;

    // --- 2. FILTER ---
    os_loop = 0;
    loop(2,
      g = tan($pi * cut_hz / (srate*2)); k_damp = 2 - 2*res;
      in_s = sig_in - 0.1 * (z1 * abs(z1)); 
      v_hp = (in_s - k_damp*z1 - z2) / (1 + g*k_damp + g*g);
      v_bp = g*v_hp + z1; v_lp = g*v_bp + z2;
      z1 = g*v_hp + v_bp; z2 = g*v_bp + v_lp;
      ls = v_lp * (1-my) + v_hp * my; rs = v_bp * (1-my) + (v_hp+v_lp) * my;
      out_os = ls * (1-mx) + rs * mx;
      os_loop == 0 ? samp1 = out_os : samp2 = out_os;
      os_loop += 1;
    );
    sig_post = (samp1 + samp2) * 0.5 * amp_env;

    // --- 3. EFFECTS ---
    // Doubler
    dbl_mix > 0.001 ? (
       dbl_s = (dbl_time_ms * 0.001) * srate;
       rdL = (dbl_idx - dbl_s + dbl_len)%dbl_len;
       rdR = (dbl_idx - dbl_s * (1.0 + dbl_wide*0.5) + dbl_len)%dbl_len;
       dbl_buf[dbl_idx] = sig_post; dbl_idx = (dbl_idx+1)%dbl_len;
       s_dL = sig_post + dbl_buf[floor(rdL)] * dbl_mix;
       s_dR = sig_post + dbl_buf[floor(rdR)] * dbl_mix;
    ) : (
       s_dL = s_dR = sig_post; dbl_buf[dbl_idx] = sig_post; dbl_idx = (dbl_idx+1)%dbl_len;
    );

    // Flanger
    fl_mix > 0.001 ? (
      fl_ph += (2*$pi*0.2)/srate; fl_ph>2*$pi ? fl_ph-=2*$pi;
      fl_d = (sin(fl_ph)+1)*0.5*0.005*srate;
      rd = (fl_idx - fl_d + flange_len)%flange_len; ri=floor(rd); rf=rd-ri;
      val_d = fl_buf[ri]*(1-rf) + fl_buf[(ri+1)%flange_len]*rf;
      fl_buf[fl_idx] = (s_dL+s_dR)*0.5 + val_d * fl_feed; fl_idx = (fl_idx+1)%flange_len;
      s_fL = s_dL*(1-fl_mix) + val_d*fl_mix; s_fR = s_dR*(1-fl_mix) + val_d*fl_mix;
    ) : (
      s_fL = s_dL; s_fR = s_dR; fl_buf[fl_idx] = (s_dL+s_dR)*0.5; fl_idx = (fl_idx+1)%flange_len;
    );

    // Reverb
    rv_mix > 0.001 ? (
      rv_rt = rvb_len * rv_size;
      rd = (rv_idx - rv_rt + rvb_len)%rvb_len; val_r = rv_buf[floor(rd)];
      val_r = val_r + (last_r - val_r) * (1.0 - rv_damp); last_r = val_r;
      rv_buf[rv_idx] = (s_fL+s_fR)*0.5 + val_r * 0.85; rv_idx = (rv_idx+1)%rvb_len;
      s_rL = s_fL + val_r * rv_mix; s_rR = s_fR + val_r * rv_mix;
    ) : (
      s_rL = s_fL; s_rR = s_fR; rv_buf[rv_idx] = (s_fL+s_fR)*0.5 * 0.5; rv_idx = (rv_idx+1)%rvb_len;
    );

    // Width
    wid > 0.001 ? (
      wid_buf[wid_idx] = (s_rL + s_rR)*0.5;
      rdL = (wid_idx - (srate*0.005) + wid_len)%wid_len;
      rdR = (wid_idx - (srate*0.013) + wid_len)%wid_len;
      L_base = s_rL + wid_buf[floor(rdL)] * wid * 0.5;
      R_base = s_rR + wid_buf[floor(rdR)] * wid * 0.5;
      wid_idx = (wid_idx+1)%wid_len;
    ) : (
      L_base = s_rL; R_base = s_rR;
    );

    // --- 4. OUTPUT MATRIX ---
    mode == 0 ? (
      ang = p_x * $pi * 0.5; 
      spl0 = (L_base * cos(ang)) + sub_direct_sig; 
      spl1 = (R_base * sin(ang)) + sub_direct_sig;
      spl2=spl3=spl4=spl5=0;
    ) : (
      gL = cos(p_x * $pi * 0.5); gR = sin(p_x * $pi * 0.5);
      spl0 = L_base * p_y * gL; spl1 = R_base * p_y * gR;
      spl2 = (spl0+spl1)*0.5 * 0.5; spl3 = sub_direct_sig;
      spl4 = L_base * (1.0 - p_y) * gL; spl5 = R_base * (1.0 - p_y) * gR;
    );

    dc_L = spl0 - liL + 0.995*dc_L; liL=spl0; spl0=dc_L;
    dc_R = spl1 - liR + 0.995*dc_R; liR=spl1; spl1=dc_R;
    spl0*=master_gain; spl1*=master_gain;
    spl2*=master_gain; spl3*=master_gain; spl4*=master_gain; spl5*=master_gain;
    spl0=lim(spl0); spl1=lim(spl1);

);
